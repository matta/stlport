#line 1 "hmap1.cpp"
#line 1 "../../stlport/iostream"

#line 1 "../../stlport/stl/_prolog.h"

#line 1 "../../stlport/stl/_config.h"

#line 1 "../../stlport/stl_user_config.h"

#line 63 "../../stlport/stl/_config.h"

#line 1 "../../stlport/stl/_config_compat.h"

#line 68 "../../stlport/stl/_config.h"

#line 1 "../../stlport/stl/_site_config.h"

#line 72 "../../stlport/stl/_config.h"

#line 1 "../../stlport/config/stlcomp.h"

#line 1 "../../stlport/config/stl_hpacc.h"

#line 86 "../../stlport/config/stlcomp.h"

#line 75 "../../stlport/stl/_config.h"

#line 1 "../../stlport/config/stl_confix.h"

#line 84 "../../stlport/stl/_config.h"


#line 469
namespace std { }

#line 470
namespace __std_alias = std;

#line 525
 namespace _STL { }

#line 527
 namespace stlport = _STL ;
#line 11 "../../stlport/stl/_prolog.h"

#line 1 "../../stlport/config/_prolog.h"

#line 17 "../../stlport/stl/_prolog.h"

#line 25 "../../stlport/iostream"

#line 1 "../../stlport/stl/_iosfwd.h"

#line 1 "../../stlport/stl/char_traits.h"

#line 1 "/opt/aCC/include/cstddef"

#line 1 "/usr/include/stddef.h"

#line 1 "/usr/include/sys/stdsyms.h"

#line 7 "/usr/include/stddef.h"

#line 1 "/usr/include/sys/_null.h"

#line 21 "/usr/include/stddef.h"

#line 1 "/usr/include/sys/_size_t.h"


#line 25
 typedef unsigned long size_t;

#line 27 "/usr/include/stddef.h"

#line 1 "/usr/include/sys/_wchar_t.h"

#line 31 "/usr/include/stddef.h"


#line 34
 typedef long ptrdiff_t;

#line 5 "/opt/aCC/include/cstddef"

#line 28 "../../stlport/stl/char_traits.h"

#line 1 "../../stlport/stl/_cwchar.h"

#line 1 "/opt/aCC/include/cwchar"

#line 1 "/usr/include/errno.h"

#line 27

 extern int errno;
#line 1 "/usr/include/sys/errno.h"


#line 42
 extern "C" {

#line 48
 extern int errno;

#line 52
 }
#line 31 "/usr/include/errno.h"


#line 34
extern "C" {

#line 36
 extern void perror(const char*);
 extern char *strerror (int);

#line 39
 extern int sys_nerr;
 extern char *sys_errlist[];
}
#line 7 "/opt/aCC/include/cwchar"

#line 1 "/usr/include/ctype.h"


#line 17
extern "C" {

#line 23
 extern int isalnum(int);
 extern int isalpha(int);
 extern int iscntrl(int);
 extern int isdigit(int);
 extern int isgraph(int);
 extern int islower(int);
 extern int isprint(int);
 extern int ispunct(int);
 extern int isspace(int);
 extern int isupper(int);
 extern int isxdigit(int);

#line 49


#line 50
 extern unsigned char *__ctype;
 extern unsigned char *__ctype2;

#line 53
 extern unsigned char *__upshift;
 extern unsigned char *__downshift;

#line 71
extern int tolower(int);
extern int toupper(int);

#line 90


#line 91
 extern int isascii(int);
 extern int toascii(int);

#line 115
extern int __tolower(int);
extern int __toupper(int);

#line 162
 extern int isctype(int, unsigned int);
 extern int isblank(int);

#line 170
 extern unsigned int *__SB_masks;

#line 172
 extern int _isalnum(int);
 extern int _isalpha(int);
 extern int _iscntrl(int);
 extern int _isdigit(int);
 extern int _isgraph(int);
 extern int _islower(int);
 extern int _isprint(int);
 extern int _ispunct(int);
 extern int _isspace(int);
 extern int _isupper(int);
 extern int _isxdigit(int);

#line 238
}
#line 9 "/opt/aCC/include/cwchar"

#line 1 "/usr/include/stdio.h"

#line 1 "/usr/include/sys/types.h"

#line 1 "/usr/include/sys/_inttypes.h"


#line 86
typedef char int8_t;

#line 87
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned int uint32_t;

#line 93
typedef int intfast_t;
typedef unsigned int uintfast_t;

#line 99
typedef long long int64_t;
typedef unsigned long long uint64_t;

#line 106
typedef int64_t intmax_t;
typedef uint64_t uintmax_t;

#line 116
typedef long intptr_t;
typedef unsigned long uintptr_t;

#line 127
typedef char int_least8_t;

#line 130
typedef unsigned char uint_least8_t;

#line 133
typedef int int_fast8_t;

#line 136
typedef unsigned int uint_fast8_t;

#line 139
typedef short int_least16_t;

#line 142
typedef unsigned short uint_least16_t;

#line 145
typedef int int_fast16_t;

#line 148
typedef unsigned int uint_fast16_t;

#line 151
typedef int int_least32_t;

#line 154
typedef unsigned int uint_least32_t;

#line 157
typedef int int_fast32_t;

#line 160
typedef unsigned int uint_fast32_t;

#line 166
typedef int64_t int_least64_t;

#line 169
typedef int64_t int_fast64_t;

#line 172
typedef uint64_t uint_least64_t;

#line 175
typedef uint64_t uint_fast64_t;

#line 192
typedef uint32_t ptr32_t;

#line 194
typedef uint64_t ptr64_t;
#line 42 "/usr/include/sys/types.h"


#line 54
 typedef int mqd_t;

#line 60
 typedef int32_t dev_t;

#line 66
 typedef uint32_t ino32_t;

#line 73
 typedef uint64_t ino64_t;

#line 88
 typedef unsigned long ino_t;

#line 94
 typedef uint16_t mode_t;

#line 99
 typedef uint16_t nlink_t;

#line 104
 typedef int32_t fpos32_t;

#line 110
 typedef int64_t fpos64_t;

#line 119


#line 120
 typedef long fpos_t;

#line 126


#line 127
 typedef uint32_t fsblkcnt32_t;

#line 133
 typedef uint64_t fsblkcnt64_t;

#line 143
 typedef unsigned long fsblkcnt_t;

#line 149
 typedef int32_t off32_t;

#line 154
 typedef int32_t sbsize32_t;
 typedef uint32_t bsize32_t;

#line 161
 typedef int64_t off64_t;

#line 168
 typedef int64_t sbsize64_t;
 typedef uint64_t bsize64_t;

#line 179
 typedef long off_t;

#line 190
 typedef long sbsize_t;
 typedef unsigned long bsize_t;

#line 197
 typedef uint32_t fsfilcnt32_t;

#line 203
 typedef uint64_t fsfilcnt64_t;

#line 213
 typedef unsigned long fsfilcnt_t;

#line 219
 typedef int32_t blkcnt32_t;

#line 225
 typedef int64_t blkcnt64_t;

#line 235
 typedef long blkcnt_t;

#line 241
 typedef int32_t pid_t;

#line 246
 typedef int32_t lwpid_t;

#line 251
 typedef int32_t gid_t;

#line 256
 typedef int32_t uid_t;

#line 261
 typedef int32_t tid_t;

#line 266
 typedef long ssize_t;

#line 271
 typedef uint16_t __site_t;

#line 276
 typedef uint16_t __cnode_t;

#line 288


#line 289
 typedef long time_t;

#line 304
 typedef uint32_t clock_t;

#line 311


#line 312
 typedef int32_t key_t;

#line 315
 typedef unsigned short __ushort;

#line 317
 typedef int32_t __daddr_t;
 typedef char *__caddr_t;
 typedef int32_t __swblk_t;

#line 326
 typedef __caddr_t caddr_t;

#line 334
 typedef int32_t id_t;

#line 339
 typedef uint32_t useconds_t;

#line 346
 typedef uint32_t rlim32_t;

#line 352
 typedef uint64_t rlim64_t;

#line 364
 typedef unsigned long rlim_t;

#line 369
 typedef __site_t site_t;

#line 373
 typedef unsigned char u_char;
 typedef unsigned short u_short;
 typedef unsigned int u_int;
 typedef unsigned long u_long;
 typedef unsigned int uint;
 typedef unsigned short ushort;
 typedef unsigned char ubit8;
 typedef unsigned short ubit16;
 typedef uint32_t ubit32;
 typedef char sbit8;
 typedef short sbit16;
 typedef int32_t sbit32;

#line 386
 typedef __swblk_t swblk_t;
 typedef __daddr_t daddr_t;
 typedef __cnode_t cnode_t;
#line 1 "/usr/include/machine/vmtypes.h"


#line 45
 typedef uintptr_t paddr_t;

#line 57
 typedef intptr_t page_t;
 typedef int32_t pgcnt_t;
 typedef uint32_t upgcnt_t;

#line 63
 typedef uint32_t physpfn_t;
 typedef uintptr_t iophyspfn_t;
 typedef uintptr_t pgaddr_t;

#line 67
 typedef uint32_t space_t;
 typedef uint32_t prot_t;
#line 392 "/usr/include/sys/types.h"


#line 395
 typedef unsigned long ulong_t;

#line 398
 typedef int16_t cnt_t;
 typedef uint32_t cdno_t;
 typedef uint16_t use_t;

#line 402
 typedef struct _physadr { intptr_t r[1]; } *physadr;
 typedef struct _quad { long val[2]; } quad;

#line 405
 typedef int spu_t;
 typedef int ldom_t;

#line 412
 typedef short cpu_t;

#line 417
typedef struct lkinfo {
 char *lk_name;
 int lk_flags;
 long lk_pad[2];
} lkinfo_t;

#line 423
typedef unsigned long pl_t;

#line 427
 typedef int32_t aid_t;

#line 436
 typedef pid_t sid_t;
#line 1 "/usr/include/sys/_fd_macros.h"


#line 82
typedef int32_t __fd_mask;

#line 91
 typedef struct fd_set {
 long fds_bits[ (((2048)+(((sizeof(long) * 8))-1))/((sizeof(long) * 8))) ];
 } fd_set;

#line 97
 extern "C" {

#line 143
 }
#line 449 "/usr/include/sys/types.h"


#line 457
 typedef __fd_mask fd_mask;

#line 462
 extern "C" {

#line 496
 }

#line 511
 typedef int32_t dir_off_t;
#line 11 "/usr/include/stdio.h"


#line 19
extern "C" {

#line 38
 typedef struct {
 int __cnt;
 unsigned char *__ptr;
 unsigned char *__base;
 unsigned short __flag;
 unsigned char __fileL;
 unsigned char __fileH;
 } FILE;

#line 48
 typedef struct {
 int __cnt;
 unsigned char *__ptr;
 unsigned char *__base;
 unsigned short __flag;
 unsigned char __fileL;
 unsigned char __fileH;
 unsigned char *__bufendp;
 unsigned char *__newbase;
 unsigned char __smbuf[ 8 +2*4];

#line 61
 void *__unused;

#line 67
 int __filler1;
 char __filler2[8];

#line 70
 } _FILEX;
#line 1 "/usr/include/sys/_null.h"

#line 98 "/usr/include/stdio.h"


#line 133
 typedef double *__va_list;

#line 172
 extern FILE __iob[];

#line 224
 extern int remove(const char *);

#line 226
 extern int rename(const char *, const char *);

#line 228
 extern char *tmpnam(char *);
 extern int fclose(FILE *);
 extern int fflush(FILE *);
 extern void setbuf(FILE *, char *);
 extern int setvbuf(FILE *, char *, int, size_t);
 extern int fprintf(FILE *, const char *, ...);
 extern int fscanf(FILE *, const char *,...);
 extern int printf(const char *,...);
 extern int scanf(const char *,...);
 extern int sprintf(char *, const char *,...);
 extern int sscanf(const char *, const char *,...);
 extern int fgetc(FILE *);
 extern char *fgets(char *, int, FILE *);
 extern int fputc(int, FILE *);
 extern int fputs(const char *, FILE *);
 extern int getc(FILE *);
 extern int getchar(void);
 extern char *gets(char *);
 extern int putc(int, FILE *);
 extern int putchar(int);
 extern int puts(const char *);
 extern int ungetc(int, FILE *);

#line 251
 extern FILE *tmpfile(void);
 extern int fgetpos(FILE *, fpos_t *);
 extern int fsetpos(FILE *, const fpos_t *);
 extern FILE *fopen(const char *, const char *);
 extern FILE *freopen(const char *, const char *, FILE *);

#line 265
 extern int fseek(FILE *, long int, int);
 extern long int ftell(FILE *);
 extern void rewind(FILE *);
 extern void clearerr(FILE *);
 extern int feof(FILE *);
 extern int ferror(FILE *);
 extern void perror(const char *);

#line 360


#line 362
 extern size_t fread(void *, size_t, size_t, FILE *);
 extern size_t fwrite(const void *, size_t, size_t, FILE *);

#line 385


#line 386
 extern int __flsbuf(unsigned char, FILE *);
 extern int __filbuf( FILE *);

#line 464
 extern char *ctermid(char *);
 extern int fileno( FILE *);
 extern FILE *fdopen(int, const char *);

#line 496
 typedef double *va_list;

#line 505


#line 507
 extern char *optarg;
 extern int opterr;
 extern int optind;
 extern int optopt;

#line 520
 extern int getopt(int, char * const [], const char *);
 extern char *cuserid(char *);

#line 540
 extern int getw( FILE *);
 extern int putw(int, FILE *);
 extern int pclose( FILE *);
 extern FILE *popen(const char *, const char *);
 extern char *tempnam(const char *, const char *);

#line 568


#line 569
 extern int vprintf(const char *, va_list);
 extern int vfprintf(FILE *, const char *, va_list);
 extern int vsprintf(char *, const char *, va_list);

#line 592


#line 593
 extern int snprintf(char *, size_t , const char *,...);
 extern int vsnprintf(char *, size_t , const char *, va_list );
 extern int vscanf(const char *, __va_list);
 extern int vfscanf( FILE *, const char *, __va_list);
 extern int vsscanf(char *, const char *, __va_list);
 extern void flockfile( FILE *);
 extern int ftrylockfile( FILE *);
 extern void funlockfile( FILE *);

#line 647
 extern unsigned char *__bufendtab[];

#line 791
}
#line 10 "/opt/aCC/include/cwchar"

#line 1 "/usr/include/stdlib.h"


#line 30
 inline int abs(int d) { return (d>0)?d:-d; }

#line 39


#line 40
extern "C" {

#line 47
 extern int __nl_char_size;

#line 61
 typedef struct {
 int quot;
 int rem;
 } div_t;
 typedef struct {
 long int quot;
 long int rem;
 } ldiv_t;

#line 102


#line 105


#line 106
 extern double atof(const char *);

#line 108
 extern int atoi(const char *);
 extern long int atol(const char *);
 extern double strtod(const char *, char **);
 extern long int strtol(const char *, char **, int);
 extern unsigned long int strtoul(const char *, char **, int);
 extern int rand(void);
 extern void srand(unsigned int);
 extern int atexit(void (*) (void));
 extern void exit(int);
 extern char *getenv(const char *);
 extern int system(const char *);
 extern div_t div(int, int);
 extern ldiv_t ldiv(long int, long int);
 extern long int labs(long int);
 extern int mblen(const char *, size_t);
 extern int mbtowc(wchar_t *, const char *, size_t);
 extern int wctomb(char *, wchar_t);
 extern size_t mbstowcs(wchar_t *, const char *, size_t);
 extern size_t wcstombs(char *, const wchar_t *, size_t);
 extern void free(void *);
 extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));

#line 167


#line 169
 extern void abort(void);
 extern void *bsearch(const void *, const void *, size_t, size_t, int (*) (const void *, const void *));
 extern void *calloc(size_t, size_t);
 extern void *malloc(size_t);
 extern void *realloc(void *, size_t);

#line 228


#line 229
 extern void setkey(const char *);
 extern void lcong48( unsigned short [] );

#line 250
 extern double drand48(void);
 extern double erand48(unsigned short []);
 extern long jrand48(unsigned short []);
 extern long lrand48(void);
 extern long mrand48(void);
 extern long nrand48(unsigned short []);
 extern void srand48(long);
 extern unsigned short *seed48(unsigned short []);
 extern int putenv(const char *);

#line 281
 extern int clearenv(void);
 extern int getopt(int, char * const [], const char *);
 extern char *getpass(const char *);
 extern void *memalign( size_t , size_t );

#line 292
 extern char *optarg;
 extern int optind;
 extern int opterr;
#line 1 "/usr/include/sys/wait.h"


#line 66
 extern "C" {

#line 74
 extern pid_t wait(int *);
 extern pid_t waitpid(pid_t, int *, int);

#line 83
 }
#line 1 "/usr/include/sys/resource.h"

#line 1 "/usr/include/sys/time.h"

#line 1 "/usr/include/sys/sigevent.h"


#line 47
typedef union sigval {

#line 51
 struct {

#line 55
 int __svi_int;
 } __svi_int_s;
 void * __sival_ptr;
 } sigval_t;

#line 70
typedef struct sigevent {

#line 74
 int __sigev_notify;
 int __sigev_signo;
 sigval_t __sigev_value;

#line 92
 void *__pad[2];

#line 95
 int __sigev_reserved[8];

#line 97
 } sigevent_t;

#line 100
 enum __sigev_types {
 __SIGEV_NONE = 1,
 __SIGEV_SIGNAL

#line 106
 };
#line 29 "/usr/include/sys/time.h"


#line 101
 struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 };

#line 119


#line 121
 struct timespec {
 time_t tv_sec;
 long tv_nsec;
};
typedef struct timespec timestruc_t;

#line 131
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};

#line 137
typedef enum __clockid_t {
 CLOCK_INVALID = 0,
 CLOCK_REALTIME = 1,
 CLOCK_VIRTUAL = 2,
 CLOCK_PROFILE = 4,
 RTTIMER0 = 8,
 RTTIMER1 = 16
} clockid_t;

#line 148
 typedef unsigned long timer_t;

#line 163
 struct timeval {

#line 165
 time_t tv_sec;

#line 169
 long tv_usec;
 };

#line 174
 struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
 };

#line 184
 struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
 };

#line 191
 typedef struct __cycles {
 uint32_t hi;
 uint32_t lo;
 } cycles_t;

#line 204
 extern "C" {

#line 219


#line 220
 extern double difftime(time_t, time_t);

#line 225
 extern time_t mktime(struct tm *);

#line 230
 extern time_t time(time_t *);

#line 234
 extern char *asctime(const struct tm *);

#line 239
 extern char *ctime(const time_t *);

#line 244
 extern struct tm *gmtime(const time_t *);

#line 249
 extern struct tm *localtime(const time_t *);

#line 254
 extern size_t strftime(char *, size_t, const char *, const struct tm *);

#line 391


#line 393
 extern clock_t clock(void);

#line 410


#line 411
 extern void tzset(void);

#line 420
 extern char *tzname[2];

#line 427
 extern int clock_settime(clockid_t, const struct timespec *);
 extern int clock_gettime(clockid_t, struct timespec *);
 extern int clock_getres(clockid_t, struct timespec *);
 extern int timer_create(clockid_t, struct sigevent *, timer_t *);
 extern int timer_delete(timer_t);
 extern int timer_settime(timer_t, int, const struct itimerspec *,
 struct itimerspec *);
 extern int timer_gettime(timer_t, struct itimerspec *);
 extern int timer_getoverrun(timer_t);
 extern int nanosleep(const struct timespec *, struct timespec *);

#line 461
 extern char *strptime(const char *, const char *, struct tm *);

#line 472
 extern long timezone;

#line 477
 extern int daylight;

#line 484
 }

#line 496
 extern "C" {

#line 500
 extern int getitimer(int, struct itimerval *);
 extern int setitimer(int, const struct itimerval *, struct itimerval *);
 extern int utimes(const char *, const struct timeval[2] );
 extern int gettimeofday(struct timeval *, void *);

#line 507
 extern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);

#line 518
 }

#line 525
 extern "C" {

#line 530
 extern int adjtime(const struct timeval *, struct timeval *);

#line 534
 extern struct tm *getdate(const char *);

#line 544
 extern int settimeofday(const struct timeval *, const struct timezone *);
 extern int stime(const time_t *);
 extern void profil(const void *, size_t , size_t , int);

#line 574
 extern int getdate_err;

#line 581
 }

#line 625
 struct ki_timeval {
 uint32_t pad1;
 uint32_t pad2;
 };

#line 645
typedef uint64_t kt_t;
#line 51 "/usr/include/sys/resource.h"

#line 1 "/usr/include/sys/_rlimit_body.h"


#line 43
struct rlimit {

#line 44
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
#line 60 "/usr/include/sys/resource.h"


#line 105
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;

#line 109
 long ru_maxrss;

#line 111
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_ioch;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;

#line 126
};

#line 146
 extern "C" {

#line 149
 extern int getpriority (int, id_t) ;
 extern int getrusage (int, struct rusage *) ;
 extern int setpriority (int, id_t, int) ;

#line 153
 extern int getrlimit (int, struct rlimit *) ;
 extern int setrlimit (int, const struct rlimit *) ;

#line 184
 }
#line 92 "/usr/include/sys/wait.h"


#line 102
 extern "C" {

#line 109
 extern pid_t wait3(int *, int, struct rusage *);

#line 119
 }
#line 1 "/usr/include/sys/signal.h"

#line 1 "/usr/include/sys/siginfo.h"


#line 45
enum __si_codes {
 SI_QUEUE = -2,
 SI_USER = -1,
 SI_TIMER = 1,
 SI_ASYNCIO= 2,
 SI_MESGQ = 3
};

#line 60
typedef struct __siginfo {

#line 64
 int si_signo;
 int si_code;
 int si_errno;
 sigval_t si_value;
 union {
 struct {
 pid_t __pid;
 union {
 struct {
 uid_t __uid;
 } __kill;
 struct {
 int __status;
 } __SIGCLD;
 } __pdata;
 } __proc;
 struct {
 void *__addr;
 } __fault;
 struct {
 int __fd;
 long __band;
 } __file;
 struct {
 void *__addr;
 void *__lockpage;
 long __dev_id;
 } __gfault;
 } __data;

#line 94
 long __pad[ 9 ];
} siginfo_t;
#line 43 "/usr/include/sys/signal.h"

#line 1 "/usr/include/sys/newsig.h"


#line 49
 typedef struct __sigset_t {

#line 50
 unsigned int sigset[8];
 } sigset_t;
#line 1 "/usr/include/machine/save_state.h"


#line 213
typedef struct __fp_dbl_block {

#line 215
 double ss_fp0;
 double ss_fp1;
 double ss_fp2;
 double ss_fp3;
 double ss_fp4;
 double ss_fp5;
 double ss_fp6;
 double ss_fp7;
 double ss_fp8;
 double ss_fp9;
 double ss_fp10;
 double ss_fp11;
 double ss_fp12;
 double ss_fp13;
 double ss_fp14;
 double ss_fp15;
 double ss_fp16;
 double ss_fp17;
 double ss_fp18;
 double ss_fp19;
 double ss_fp20;
 double ss_fp21;
 double ss_fp22;
 double ss_fp23;
 double ss_fp24;
 double ss_fp25;
 double ss_fp26;
 double ss_fp27;
 double ss_fp28;
 double ss_fp29;
 double ss_fp30;
 double ss_fp31;
} fp_dbl_block_t;

#line 252
typedef struct __fp_int_block {

#line 254
 int ss_fpstat;
 int ss_fpexcept1;
 int ss_fpexcept2;
 int ss_fpexcept3;
 int ss_fpexcept4;
 int ss_fpexcept5;
 int ss_fpexcept6;
 int ss_fpexcept7;
 int ss_fp4_hi;
 int ss_fp4_lo;
 int ss_fp5_hi;
 int ss_fp5_lo;
 int ss_fp6_hi;
 int ss_fp6_lo;
 int ss_fp7_hi;
 int ss_fp7_lo;
 int ss_fp8_hi;
 int ss_fp8_lo;
 int ss_fp9_hi;
 int ss_fp9_lo;
 int ss_fp10_hi;
 int ss_fp10_lo;
 int ss_fp11_hi;
 int ss_fp11_lo;
 int ss_fp12_hi;
 int ss_fp12_lo;
 int ss_fp13_hi;
 int ss_fp13_lo;
 int ss_fp14_hi;
 int ss_fp14_lo;
 int ss_fp15_hi;
 int ss_fp15_lo;
 int ss_fp16_hi;
 int ss_fp16_lo;
 int ss_fp17_hi;
 int ss_fp17_lo;
 int ss_fp18_hi;
 int ss_fp18_lo;
 int ss_fp19_hi;
 int ss_fp19_lo;
 int ss_fp20_hi;
 int ss_fp20_lo;
 int ss_fp21_hi;
 int ss_fp21_lo;
 int ss_fp22_hi;
 int ss_fp22_lo;
 int ss_fp23_hi;
 int ss_fp23_lo;
 int ss_fp24_hi;
 int ss_fp24_lo;
 int ss_fp25_hi;
 int ss_fp25_lo;
 int ss_fp26_hi;
 int ss_fp26_lo;
 int ss_fp27_hi;
 int ss_fp27_lo;
 int ss_fp28_hi;
 int ss_fp28_lo;
 int ss_fp29_hi;
 int ss_fp29_lo;
 int ss_fp30_hi;
 int ss_fp30_lo;
 int ss_fp31_hi;
 int ss_fp31_lo;
} fp_int_block_t;

#line 379
typedef struct __reg64 {

#line 381
 int64_t ss_reserved;
 int64_t ss_gr1;
 int64_t ss_rp;
 int64_t ss_gr3;
 int64_t ss_gr4;
 int64_t ss_gr5;
 int64_t ss_gr6;
 int64_t ss_gr7;
 int64_t ss_gr8;
 int64_t ss_gr9;
 int64_t ss_gr10;
 int64_t ss_gr11;
 int64_t ss_gr12;
 int64_t ss_gr13;
 int64_t ss_gr14;
 int64_t ss_gr15;
 int64_t ss_gr16;
 int64_t ss_gr17;
 int64_t ss_gr18;
 int64_t ss_gr19;
 int64_t ss_gr20;
 int64_t ss_gr21;
 int64_t ss_gr22;
 int64_t ss_arg3;
 int64_t ss_arg2;
 int64_t ss_arg1;
 int64_t ss_arg0;
 uint64_t ss_dp;
 uint64_t ss_ret0;
 uint64_t ss_ret1;
 uint64_t ss_sp;
 uint64_t ss_gr31;
 uint64_t ss_cr11;
 uint64_t ss_pcoq_head;
 uint64_t ss_pcsq_head;
 uint64_t ss_pcoq_tail;
 uint64_t ss_pcsq_tail;
 uint64_t ss_cr15;
 uint64_t ss_cr19;
 uint64_t ss_cr20;
 uint64_t ss_cr21;
 uint64_t ss_cr22;
 uint64_t ss_cpustate;
 uint64_t ss_sr4;
 uint64_t ss_sr0;
 uint64_t ss_sr1;
 uint64_t ss_sr2;
 uint64_t ss_sr3;
 uint64_t ss_sr5;
 uint64_t ss_sr6;
 uint64_t ss_sr7;
 uint64_t ss_cr0;
 uint64_t ss_cr8;
 uint64_t ss_cr9;
 uint64_t ss_cr10;
 uint64_t ss_cr12;
 uint64_t ss_cr13;
 uint64_t ss_cr24;
 uint64_t ss_cr25;
 uint64_t ss_cr26;
 uint64_t ss_cr27;
 uint64_t ss_reserved2[2];
 uint32_t ss_oldcksum;
 uint32_t ss_newcksum;

#line 448
} __reg64_t;

#line 454
typedef struct __reg32 {
 uint32_t ss_reserved[2];
 uint32_t ss_gr1_hi;
 uint32_t ss_gr1_lo;
 uint32_t ss_rp_hi;
 uint32_t ss_rp_lo;
 uint32_t ss_gr3_hi;
 uint32_t ss_gr3_lo;
 uint32_t ss_gr4_hi;
 uint32_t ss_gr4_lo;
 uint32_t ss_gr5_hi;
 uint32_t ss_gr5_lo;
 uint32_t ss_gr6_hi;
 uint32_t ss_gr6_lo;
 uint32_t ss_gr7_hi;
 uint32_t ss_gr7_lo;
 uint32_t ss_gr8_hi;
 uint32_t ss_gr8_lo;
 uint32_t ss_gr9_hi;
 uint32_t ss_gr9_lo;
 uint32_t ss_gr10_hi;
 uint32_t ss_gr10_lo;
 uint32_t ss_gr11_hi;
 uint32_t ss_gr11_lo;
 uint32_t ss_gr12_hi;
 uint32_t ss_gr12_lo;
 uint32_t ss_gr13_hi;
 uint32_t ss_gr13_lo;
 uint32_t ss_gr14_hi;
 uint32_t ss_gr14_lo;
 uint32_t ss_gr15_hi;
 uint32_t ss_gr15_lo;
 uint32_t ss_gr16_hi;
 uint32_t ss_gr16_lo;
 uint32_t ss_gr17_hi;
 uint32_t ss_gr17_lo;
 uint32_t ss_gr18_hi;
 uint32_t ss_gr18_lo;
 uint32_t ss_gr19_hi;
 uint32_t ss_gr19_lo;
 uint32_t ss_gr20_hi;
 uint32_t ss_gr20_lo;
 uint32_t ss_gr21_hi;
 uint32_t ss_gr21_lo;
 uint32_t ss_gr22_hi;
 uint32_t ss_gr22_lo;
 uint32_t ss_arg3_hi;
 uint32_t ss_arg3_lo;
 uint32_t ss_arg2_hi;
 uint32_t ss_arg2_lo;
 uint32_t ss_arg1_hi;
 uint32_t ss_arg1_lo;
 uint32_t ss_arg0_hi;
 uint32_t ss_arg0_lo;
 unsigned int ss_dp_hi;
 unsigned int ss_dp_lo;
 unsigned int ss_ret0_hi;
 unsigned int ss_ret0_lo;
 unsigned int ss_ret1_hi;
 unsigned int ss_ret1_lo;
 unsigned int ss_sp_hi;
 unsigned int ss_sp_lo;
 unsigned int ss_gr31_hi;
 unsigned int ss_gr31_lo;
 unsigned int ss_cr11_hi;
 unsigned int ss_cr11_lo;
 unsigned int ss_pcoq_head_hi;
 unsigned int ss_pcoq_head_lo;
 unsigned int ss_pcsq_head_hi;
 unsigned int ss_pcsq_head_lo;
 unsigned int ss_pcoq_tail_hi;
 unsigned int ss_pcoq_tail_lo;
 unsigned int ss_pcsq_tail_hi;
 unsigned int ss_pcsq_tail_lo;
 unsigned int ss_cr15_hi;
 unsigned int ss_cr15_lo;
 unsigned int ss_cr19_hi;
 unsigned int ss_cr19_lo;
 unsigned int ss_cr20_hi;
 unsigned int ss_cr20_lo;
 unsigned int ss_cr21_hi;
 unsigned int ss_cr21_lo;
 unsigned int ss_cr22_hi;
 unsigned int ss_cr22_lo;
 unsigned int ss_cpustate_hi;
 unsigned int ss_cpustate_lo;
 unsigned int ss_sr4_hi;
 unsigned int ss_sr4_lo;
 unsigned int ss_sr0_hi;
 unsigned int ss_sr0_lo;
 unsigned int ss_sr1_hi;
 unsigned int ss_sr1_lo;
 unsigned int ss_sr2_hi;
 unsigned int ss_sr2_lo;
 unsigned int ss_sr3_hi;
 unsigned int ss_sr3_lo;
 unsigned int ss_sr5_hi;
 unsigned int ss_sr5_lo;
 unsigned int ss_sr6_hi;
 unsigned int ss_sr6_lo;
 unsigned int ss_sr7_hi;
 unsigned int ss_sr7_lo;
 unsigned int ss_cr0_hi;
 unsigned int ss_cr0_lo;
 unsigned int ss_cr8_hi;
 unsigned int ss_cr8_lo;
 unsigned int ss_cr9_hi;
 unsigned int ss_cr9_lo;
 unsigned int ss_cr10_hi;
 unsigned int ss_cr10_lo;
 unsigned int ss_cr12_hi;
 unsigned int ss_cr12_lo;
 unsigned int ss_cr13_hi;
 unsigned int ss_cr13_lo;
 unsigned int ss_cr24_hi;
 unsigned int ss_cr24_lo;
 unsigned int ss_cr25_hi;
 unsigned int ss_cr25_lo;
 unsigned int ss_cr26_hi;
 unsigned int ss_cr26_lo;
 unsigned int ss_cr27_hi;
 unsigned int ss_cr27_lo;
 unsigned int ss_reserved2[4];
 unsigned int ss_oldcksum;
 unsigned int ss_newcksum;
} __reg32_t;

#line 584
typedef struct __ss_narrow {

#line 586
 int ss_gr1;
 int ss_rp;
 int ss_gr3;
 int ss_gr4;
 int ss_gr5;
 int ss_gr6;
 int ss_gr7;
 int ss_gr8;
 int ss_gr9;
 int ss_gr10;
 int ss_gr11;
 int ss_gr12;
 int ss_gr13;
 int ss_gr14;
 int ss_gr15;
 int ss_gr16;
 int ss_gr17;
 int ss_gr18;
 int ss_gr19;
 int ss_gr20;
 int ss_gr21;
 int ss_gr22;
 int ss_arg3;
 int ss_arg2;
 int ss_arg1;
 int ss_arg0;
 unsigned int ss_dp;
 unsigned int ss_ret0;
 unsigned int ss_ret1;
 unsigned int ss_sp;
 unsigned int ss_gr31;
 unsigned int ss_cr11;
 unsigned int ss_pcoq_head;
 unsigned int ss_pcsq_head;
 unsigned int ss_pcoq_tail;
 unsigned int ss_pcsq_tail;
 unsigned int ss_cr15;
 unsigned int ss_cr19;
 unsigned int ss_cr20;
 unsigned int ss_cr21;
 unsigned int ss_cr22;
 unsigned int ss_cpustate;
 unsigned int ss_sr4;
 unsigned int ss_sr0;
 unsigned int ss_sr1;
 unsigned int ss_sr2;
 unsigned int ss_sr3;
 unsigned int ss_sr5;
 unsigned int ss_sr6;
 unsigned int ss_sr7;
 unsigned int ss_cr0;
 unsigned int ss_cr8;
 unsigned int ss_cr9;
 unsigned int ss_cr10;
 unsigned int ss_cr12;
 unsigned int ss_cr13;
 unsigned int ss_cr24;
 unsigned int ss_cr25;
 unsigned int ss_cr26;
 unsigned int ss_cr27;
 unsigned int ss_mpsfu_low;
 unsigned int ss_mpsfu_ovflo;

#line 653
} __ss_narrow_t;

#line 655
typedef int ssflags_t;

#line 664
typedef struct __save_state {

#line 666
 ssflags_t ss_flags;
 __ss_narrow_t ss_narrow;
 int ss_pad;
 union {

#line 671
 fp_dbl_block_t fpdbl;
 fp_int_block_t fpint;

#line 677
 } ss_fpblock;
 char ss_xor[4*32];
 union {

#line 707
 __reg64_t ss_64;
 __reg32_t ss_32;
 } ss_wide;
} save_state_t;
#line 64 "/usr/include/sys/newsig.h"


#line 65
 typedef struct __stack {
 void *ss_sp;
 int ss_flags;
 size_t ss_size;
 } stack_t;

#line 72
typedef save_state_t mcontext_t;

#line 81
struct __sub_ctxt {
 struct __ucontext *__uc_link;
 sigset_t __uc_sigmask;
 stack_t __uc_stack;
};
typedef struct __sub_ctxt __sub_ctxt_t;

#line 97
typedef struct __ucontext {
 mcontext_t uc_mcontext;
 int uc_spares[8];

#line 101
 unsigned int uc_created_by_getcontext:1;
 unsigned int uc_reserved_flags:31;
 struct __sub_ctxt uc_subcontext;

#line 105
} ucontext_t;
#line 44 "/usr/include/sys/signal.h"


#line 67
 typedef unsigned int sig_atomic_t;

#line 71


#line 79
 struct sigaction {
 union {

#line 84
 void (*__sa_sigaction)(int, siginfo_t *, void *);

#line 92
 void (*__sa_handler)( int );
 } __handler;

#line 95
 sigset_t sa_mask;
 int sa_flags;
 };

#line 143
 struct sigstack {

#line 145
 void *ss_sp;

#line 149
 int ss_onstack;
 };

#line 160
 struct sigvec {
 void (*sv_handler)( int );
 int sv_mask;
 int sv_flags;
 };

#line 176
 extern "C" {

#line 182
 extern void (*signal(int, void (*) ( int )))( int );
 extern int raise(int);

#line 192


#line 193
 extern int kill(pid_t, int);
 extern int sigemptyset(sigset_t *);
 extern int sigfillset(sigset_t *);
 extern int sigaddset(sigset_t *, int);
 extern int sigdelset(sigset_t *, int);
 extern int sigismember(const sigset_t *, int);
 extern int sigaction(int, const struct sigaction *, struct sigaction *);
 extern int sigprocmask(int, const sigset_t *, sigset_t *);
 extern int sigsuspend(const sigset_t *);
 extern int sigpending(sigset_t *);

#line 235
 extern int sigwaitinfo(const sigset_t *set, siginfo_t *info);
 extern int sigtimedwait(const sigset_t *set, siginfo_t * info,
 const struct timespec *timeout);
 extern int sigqueue(pid_t pid, int signo,
 const union sigval value);

#line 249
 extern void (*bsd_signal(int, void(*)(int)))(int);
 extern int killpg(pid_t, int);

#line 252
 extern int sigstack(struct sigstack *, struct sigstack *);

#line 256
 extern int sigaltstack(const stack_t *, stack_t *);
 extern int siginterrupt(int, int);

#line 268
 extern void (*sigset(int, void (*)( int )))( int );
 extern int sighold(int);
 extern int sigrelse(int);
 extern int sigignore(int);
 extern int sigpause(int);

#line 286
 extern long sigblock(long);
 extern long sigsetmask(long);
 extern int sigvector(int, const struct sigvec *, struct sigvec *);
 extern int (*ssignal(int, int (*) ( int )))( int );

#line 293
 extern ssize_t sigspace(ssize_t);
 extern int gsignal(int);

#line 313
 }

#line 384
 extern long ___sysconf(int);
#line 1 "/usr/include/machine/save_state.h"

#line 516 "/usr/include/sys/signal.h"

#line 1 "/usr/include/machine/frame.h"


#line 68
typedef struct frame_marker {

#line 69
 int fm_edp;
 int fm_esr4;
 int fm_erp;
 int fm_crp;
 int fm_sl;
 int fm_clup;
 int fm_ep;
 int fm_psp;
} frame_marker_t;
#line 546 "/usr/include/sys/signal.h"

#line 1 "/usr/include/sys/syscall.h"

#line 1 "/usr/include/sys/scall_define.h"

#line 54 "/usr/include/sys/syscall.h"

#line 1 "/usr/include/machine/sys/syscall.h"

#line 68 "/usr/include/sys/syscall.h"

#line 547 "/usr/include/sys/signal.h"


#line 558
 struct siglocal_misc {

#line 559
 int sm_syscall;
 int sm_onstack;
 int sm_omask;
 char sm_syscall_action;
 char sm_eosys;
 unsigned short sm_error;
 long sm_rval1;
 long sm_rval2;
 long sm_arg[ 4 ];
 };
 typedef struct siglocal_misc siglocal_misc_t;

#line 571
 struct siglocal {
 struct siglocal_misc sl_misc;
 save_state_t sl_ss;
 };

#line 590
 struct siglocalx {
 struct siglocal_misc sl_misc;
 ucontext_t sl_uc;
 siginfo_t sl_si;
 };

#line 610
 struct __xsi {
 struct __sub_ctxt sc;

#line 613
 int __padding;

#line 617
 siginfo_t si;
 };
 typedef struct __xsi __xsi_t;
#line 1 "/usr/include/machine/sys/sigcontext.h"


#line 45
 struct sigcontext {
 union {
 struct siglocal sl;
 struct siglocalx sx;
 } sc_ctxt;

#line 54
 long sc_args[ 4 ];

#line 58
 struct frame_marker sc_sfm;

#line 60
 };
#line 629 "/usr/include/sys/signal.h"

#line 127 "/usr/include/sys/wait.h"


#line 161
typedef enum {
 P_PID,
 P_PGID,
 P_SID,
 P_UID,
 P_GID,
 P_CID,
 P_ALL,
 P_LWPID
} idtype_t;

#line 176
 extern "C" {

#line 180
 extern int waitid(idtype_t, id_t, siginfo_t *, int);

#line 186
 }

#line 197
 union wait {
 int w_status;

#line 202
 struct {
 unsigned short w_pad;
 unsigned int w_Retcode:8;
 unsigned int w_Coredump:1;
 unsigned int w_Termsig:7;
 } w_T;

#line 213
 struct {
 unsigned short w_pad;
 unsigned int w_Stopsig:8;
 unsigned int w_Stopval:8;
 } w_S;
 };
#line 299 "/usr/include/stdlib.h"


#line 311
 extern int mkstemp(char *);
 extern char *mktemp(char *);
 extern int ttyslot(void);

#line 335
 extern long a64l(const char *);
 extern char *l64a(long);

#line 339
 extern char *fcvt(double, int, int *, int *);
 extern char *ecvt(double, int, int *, int *);

#line 343
 extern char *gcvt(double, int, char *);
 extern int getsubopt(char **, char * const *, char **);
 extern int grantpt(int);
 extern char *ptsname(int);
 extern char *realpath(const char *, char *);
 extern int unlockpt(int);
 extern void *valloc( size_t );
 extern char *initstate(unsigned int, char *, size_t );
 extern char *setstate(const char *);
 extern void srandom(unsigned int);
 extern long random(void);

#line 400
 struct mallinfo {
 int32_t arena;
 int32_t ordblks;
 int32_t smblks;
 int32_t hblks;
 int32_t hblkhd;
 int32_t usmblks;
 int32_t fsmblks;
 int32_t uordblks;
 int32_t fordblks;
 int32_t keepcost;
 };

#line 416
 typedef struct {
 uint32_t word1, word2, word3, word4;
 } long_double;
#line 1 "/usr/include/pwd.h"


#line 20
extern "C" {

#line 25
 struct passwd {
 char *pw_name;
 char *pw_passwd;
 uid_t pw_uid;
 gid_t pw_gid;
 char *pw_age;
 char *pw_comment;
 char *pw_gecos;
 char *pw_dir;
 char *pw_shell;
 int32_t pw_audid;
 int pw_audflg;
 };

#line 58
 extern struct passwd *getpwuid(uid_t);
 extern struct passwd *getpwnam(const char *);

#line 89
 extern void endpwent(void);
 extern struct passwd *getpwent(void);
 extern void setpwent(void);

#line 100
 struct s_passwd {
 char *pw_name;
 char *pw_passwd;
 char *pw_age;
 int32_t pw_audid;
 int pw_audflg;
 };

#line 120
 extern int putpwent(const struct passwd *, FILE *);
 extern struct passwd *fgetpwent( FILE *);
 extern struct s_passwd *getspwent(void);
 extern struct s_passwd *getspwuid(uid_t);
 extern struct s_passwd *getspwaid(int32_t);
 extern struct s_passwd *getspwnam(char *);
 extern struct s_passwd *fgetspwent( FILE *);
 extern void setspwent(void);
 extern void endspwent(void);

#line 177
}
#line 431 "/usr/include/stdlib.h"


#line 437
 extern char *_ldecvt(long_double, int, int *, int *);
 extern char *_ldfcvt(long_double, int, int *, int *);
 extern char *_ldgcvt(long_double, int, char *);
 extern int getpw(int, char *);
 extern void l3tol(long *, const char *, int);
 extern void ltol3(char *, const long *, int);
 extern char *ltostr(long, int);
 extern char *ultostr(unsigned long, int);
 extern char *ltoa(long);
 extern char *ultoa(unsigned long);
 extern void memorymap(int);
 extern struct mallinfo mallinfo(void);
 extern int mallopt(int, int);
 extern long_double strtold(const char *, char **);

#line 510
}
#line 11 "/opt/aCC/include/cwchar"

#line 1 "/usr/include/time.h"


#line 33
 extern int get_expiration_time (struct timespec *,struct timespec *) ;

#line 38
 extern "C" {

#line 41
 }
#line 12 "/opt/aCC/include/cwchar"

#line 1 "/usr/include/wchar.h"

#line 1 "/opt/aCC/include/limits.h"

#line 1 "/usr/include/limits.h"

#line 1 "/usr/include/sys/param.h"

#line 1 "/usr/include/sys/sysmacros.h"

#line 36 "/usr/include/sys/param.h"

#line 1 "/usr/include/machine/param.h"

#line 1 "/usr/include/machine/param_shm.h"

#line 46 "/usr/include/machine/param.h"

#line 38 "/usr/include/sys/param.h"

#line 412 "/usr/include/limits.h"

#line 5 "/opt/aCC/include/limits.h"

#line 31 "/usr/include/wchar.h"


#line 34
extern "C" {

#line 44


#line 45
 typedef unsigned int wint_t;

#line 50
 typedef unsigned int wctype_t;

#line 59


#line 92


#line 95
 extern wchar_t *wcscat (wchar_t *, const wchar_t *) ;
 extern wchar_t *wcsncat (wchar_t *, const wchar_t *, size_t) ;
 extern wchar_t *wcscpy (wchar_t *, const wchar_t *) ;
 extern wchar_t *wcsncpy (wchar_t *, const wchar_t *, size_t) ;
 extern size_t wcslen (const wchar_t *) ;
 extern size_t wcsspn (const wchar_t *, const wchar_t *) ;
 extern size_t wcscspn (const wchar_t *, const wchar_t *) ;
 extern int wcscmp (const wchar_t *, const wchar_t *) ;
 extern int wcsncmp (const wchar_t *, const wchar_t *, size_t) ;

#line 110
 extern size_t wcsftime (wchar_t *, size_t, const char *, const struct tm *) ;

 extern wchar_t *wcstok (wchar_t *, const wchar_t *) ;

#line 119
 extern wchar_t *wcschr (const wchar_t *, wchar_t) ;
 extern wchar_t *wcsrchr (const wchar_t *, wchar_t) ;

#line 125
 extern wchar_t *wcspbrk (const wchar_t *, const wchar_t *) ;

#line 130
 extern wchar_t *wcswcs (const wchar_t *, const wchar_t *) ;

#line 137
 extern int wcscoll (const wchar_t *, const wchar_t *) ;
 extern size_t wcsxfrm (wchar_t *, const wchar_t *, size_t) ;

#line 140


#line 141
 extern int wcwidth (wchar_t) ;

#line 147
 extern int wcswidth (const wchar_t *, size_t) ;

#line 151
 extern int iswalnum (wint_t) ;
 extern int iswalpha (wint_t) ;
 extern int iswcntrl (wint_t) ;
 extern int iswdigit (wint_t) ;
 extern int iswgraph (wint_t) ;
 extern int iswlower (wint_t) ;
 extern int iswprint (wint_t) ;
 extern int iswpunct (wint_t) ;
 extern int iswspace (wint_t) ;
 extern int iswupper (wint_t) ;
 extern int iswxdigit (wint_t) ;
 extern wint_t towlower (wint_t) ;
 extern wint_t towupper (wint_t) ;
 extern wctype_t wctype (const char *) ;
 extern int iswctype (wint_t, wctype_t) ;

#line 168
 extern wint_t fgetwc (FILE *) ;
 extern wchar_t *fgetws (wchar_t *, int, FILE *) ;
 extern wint_t fputwc (wint_t, FILE *) ;
 extern int fputws (const wchar_t *, FILE *) ;
 extern wint_t getwc (FILE *) ;
 extern wint_t getwchar (void) ;
 extern wint_t putwc (wint_t, FILE *) ;
 extern wint_t putwchar (wint_t) ;
 extern wint_t ungetwc (wint_t, FILE *) ;

#line 179
 extern double wcstod (const wchar_t *, wchar_t **) ;
 extern long int wcstol (const wchar_t *, wchar_t **, int) ;
 extern unsigned long int wcstoul (const wchar_t *, wchar_t **, int) ;

#line 184


#line 185
 extern wchar_t *getws (wchar_t *) ;
 extern int putws (const wchar_t *) ;

#line 195
 extern int iswblank (wint_t) ;

#line 215
}
#line 29 "/opt/aCC/include/cwchar"


#line 94
 typedef struct {
 unsigned char __parse_size:3;
 unsigned char __dummy:4;
 unsigned char __shift_state:1;
 char __parse_buf[7];
 } mbstate_t;
#line 20 "../../stlport/stl/_cwchar.h"

#line 32 "../../stlport/stl/char_traits.h"

#line 1 "/opt/aCC/include/cstring"

#line 1 "/usr/include/string.h"


#line 17
extern "C" {
#line 1 "/usr/include/sys/_null.h"

#line 24 "/usr/include/string.h"


#line 61
 extern int memcmp(const void *, const void *, size_t);

#line 62
 extern char *strncat(char *, const char *, size_t);
 extern int strncmp(const char *, const char *, size_t);
 extern void *memmove(void *, const void *, size_t);
 extern char *strcpy(char *, const char *);
 extern char *strncpy(char *, const char *, size_t);
 extern char *strcat(char *, const char *);
 extern int strcmp(const char *, const char *);
 extern int strcoll(const char *, const char *);
 extern size_t strxfrm(char *, const char *, size_t);

#line 75
 extern char *strchr(const char *, int);
 extern char *strpbrk(const char *, const char *);
 extern char *strrchr(const char *, int);
 extern char *strstr(const char *, const char *);

#line 82
 extern char *strtok(char *, const char *);
 extern char *strerror(int);

#line 193


#line 195
 extern void *memcpy(void *, const void *, size_t);

#line 200
 extern void *memchr(const void *, int, size_t);

#line 204
 extern void *memset(void *, int, size_t);
 extern size_t strcspn(const char *, const char *);
 extern size_t strspn(const char *, const char *);

#line 210


#line 212
 extern size_t strlen(const char *);

#line 253


#line 254
 extern void *memccpy(void *, const void *, int, size_t );

#line 280
 extern char *strdup(const char *);

#line 304
 extern char *strrstr(const char *, const char *);
 extern int strcasecmp(const char *, const char *);
 extern int strncasecmp(const char *, const char *, size_t );

#line 315
}
#line 19 "/opt/aCC/include/cstring"

#line 36 "../../stlport/stl/char_traits.h"

#line 1 "../../stlport/stl/type_traits.h"


#line 62
 namespace _STL {

#line 64
 struct __true_type {};
struct __false_type {};

#line 68
template <int _Is> struct __bool2type {
 typedef __false_type _Ret;
};

#line 72
 template<>
 struct __bool2type<1> { typedef __true_type _Ret; };

#line 75
 template<>
 struct __bool2type<0> { typedef __false_type _Ret; };

#line 79
template <class _P1, class _P2, class _P3>
struct _Land3 {
 typedef __false_type _Ret;
};

#line 84
 template<>
 struct _Land3<__true_type, __true_type, __true_type> {
 typedef __true_type _Ret;
};

#line 91
template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
 typedef __false_type has_trivial_default_constructor;
 typedef __false_type has_trivial_copy_constructor;
 typedef __false_type has_trivial_assignment_operator;
 typedef __false_type has_trivial_destructor;
 typedef __false_type is_POD_type;
};

#line 100
 template<>
 struct __type_traits_aux<0> {
 typedef __false_type has_trivial_default_constructor;
 typedef __false_type has_trivial_copy_constructor;
 typedef __false_type has_trivial_assignment_operator;
 typedef __false_type has_trivial_destructor;
 typedef __false_type is_POD_type;
};

#line 109
 template<>
 struct __type_traits_aux<1> {
 typedef __true_type has_trivial_default_constructor;
 typedef __true_type has_trivial_copy_constructor;
 typedef __true_type has_trivial_assignment_operator;
 typedef __true_type has_trivial_destructor;
 typedef __true_type is_POD_type;
};

#line 187
template <class _Tp>
struct __type_traits {
 typedef __true_type this_dummy_member_must_be_first;

#line 205
 typedef __false_type has_trivial_default_constructor;
 typedef __false_type has_trivial_copy_constructor;
 typedef __false_type has_trivial_assignment_operator;
 typedef __false_type has_trivial_destructor;
 typedef __false_type is_POD_type;
};

#line 213
template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
 static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
 static __false_type _Ret() { return __false_type();}
};

#line 221
template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };

#line 228
template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
 static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
 static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };

#line 245
 template<> struct __type_traits<bool> : __type_traits_aux<1> {};

#line 247
 template<> struct __type_traits<char> : __type_traits_aux<1> {};

#line 249
 template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

#line 251
 template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};

#line 253
 template<> struct __type_traits<wchar_t> : __type_traits_aux<1> {};

#line 256
 template<> struct __type_traits<short> : __type_traits_aux<1> {};
 template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
 template<> struct __type_traits<int> : __type_traits_aux<1> {};
 template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
 template<> struct __type_traits<long> : __type_traits_aux<1> {};
 template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};

#line 264
 template<> struct __type_traits< long long > : __type_traits_aux<1> {};
 template<> struct __type_traits<unsigned long long > : __type_traits_aux<1> {};

#line 268
 template<> struct __type_traits<float> : __type_traits_aux<1> {};
 template<> struct __type_traits<double> : __type_traits_aux<1> {};

#line 272
 template<> struct __type_traits<long double> : __type_traits_aux<1> {};

#line 276
template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};

#line 282
template <class _Tp> struct _Is_integer {
 typedef __false_type _Integral;
};

#line 288
 template<> struct _Is_integer<bool> {
 typedef __true_type _Integral;
};

#line 294
 template<> struct _Is_integer<char> {
 typedef __true_type _Integral;
};

#line 300
 template<> struct _Is_integer<signed char> {
 typedef __true_type _Integral;
};

#line 305
 template<> struct _Is_integer<unsigned char> {
 typedef __true_type _Integral;
};

#line 311
 template<> struct _Is_integer<wchar_t> {
 typedef __true_type _Integral;
};

#line 317
 template<> struct _Is_integer<short> {
 typedef __true_type _Integral;
};

#line 321
 template<> struct _Is_integer<unsigned short> {
 typedef __true_type _Integral;
};

#line 325
 template<> struct _Is_integer<int> {
 typedef __true_type _Integral;
};

#line 329
 template<> struct _Is_integer<unsigned int> {
 typedef __true_type _Integral;
};

#line 333
 template<> struct _Is_integer<long> {
 typedef __true_type _Integral;
};

#line 337
 template<> struct _Is_integer<unsigned long> {
 typedef __true_type _Integral;
};

#line 343
 template<> struct _Is_integer< long long > {
 typedef __true_type _Integral;
};

#line 347
 template<> struct _Is_integer<unsigned long long > {
 typedef __true_type _Integral;
};

#line 353
template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
 enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
 typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
 typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
 typedef typename __bool2type< _Same >::_Ret _Tr3;
 typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
 static _Type _Ret() { return _Type(); }
};

#line 363
template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
 return _OKToMemCpy<_Tp1, _Tp2>();
}

#line 368
template <class _Tp>
struct _IsPOD {
 typedef typename __type_traits<_Tp>::is_POD_type _Type;
 static _Type _Ret() { return _Type(); }
};

#line 374
template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }

#line 410
 }
#line 40 "../../stlport/stl/char_traits.h"


#line 53
 namespace _STL {

#line 57
 template <class _Tp> class allocator;

#line 67
typedef long streamoff;

#line 70
typedef ptrdiff_t streamsize;

#line 75
template <class _StateT> class fpos
{
public:
 fpos(streamoff __pos) : _M_pos(__pos), _M_st( _StateT() ) {}
 fpos() : _M_pos(0), _M_st( _StateT() ) {}

#line 81
 operator streamoff() const { return _M_pos; }

#line 83
 bool operator==(const fpos<_StateT>& __y) const
 { return _M_pos == __y._M_pos; }
 bool operator!=(const fpos<_StateT>& __y) const
 { return _M_pos != __y._M_pos; }

#line 88
 fpos<_StateT>& operator+=(streamoff __off) {
 _M_pos += __off;
 return *this;
 }
 fpos<_StateT>& operator-=(streamoff __off) {
 _M_pos -= __off;
 return *this;
 }

#line 97
 fpos<_StateT> operator+(streamoff __off) {
 fpos<_StateT> __tmp(*this);
 __tmp += __off;
 return __tmp;
 }
 fpos<_StateT> operator-(streamoff __off) {
 fpos<_StateT> __tmp(*this);
 __tmp -= __off;
 return __tmp;
 }

#line 108
public:
 _StateT state() const { return _M_st; }
 void state(_StateT __st) { _M_st = __st; }
private:
 streamoff _M_pos;
 _StateT _M_st;
};

#line 116
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

#line 122
template <class _CharT, class _IntT> class __char_traits_base {
public:
 typedef _CharT char_type;
 typedef _IntT int_type;

#line 127
 typedef streamoff off_type;
 typedef streampos pos_type;

#line 132
 typedef mbstate_t state_type;

#line 136
 static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
 static bool eq(const _CharT& __c1, const _CharT& __c2)
 { return __c1 == __c2; }
 static bool lt(const _CharT& __c1, const _CharT& __c2)
 { return __c1 < __c2; }

#line 142
 static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {
 for (size_t __i = 0; __i < __n; ++__i)
 if (!eq(__s1[__i], __s2[__i]))
 return __s1[__i] < __s2[__i] ? -1 : 1;
 return 0;
 }

#line 149
 static size_t length(const _CharT* __s) {
 const _CharT _NullChar = _CharT() ;
 size_t __i;
 for (__i = 0; !eq(__s[__i], _NullChar); ++__i)
 {}
 return __i;
 }

#line 157
 static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c) {
 for ( ; __n > 0 ; ++__s, --__n)
 if (eq(*__s, __c))
 return __s;
 return 0;
 }

#line 165
 static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t _Sz) {
 return (_Sz == 0 ? __s1 : (_CharT*)memmove(__s1, __s2, _Sz * sizeof(_CharT)));
 }

#line 169
 static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {
 return (__n == 0 ? __s1 :
 (_CharT*)memcpy(__s1, __s2, __n * sizeof(_CharT)));
 }

#line 174
 static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {
 for (size_t __i = 0; __i < __n; ++__i)
 __s[__i] = __c;
 return __s;
 }

#line 180
 static int_type not_eof(const int_type& __c) {
 return !eq_int_type(__c, eof()) ? __c : static_cast<int_type>(0) ;
 }

#line 184
 static char_type to_char_type(const int_type& __c) {
 return (char_type)__c;
 }

#line 188
 static int_type to_int_type(const char_type& __c) {
 return (int_type)__c;
 }

#line 192
 static bool eq_int_type(const int_type& __c1, const int_type& __c2) {
 return __c1 == __c2;
 }

#line 196
 static int_type eof() {
 return (int_type)-1;

#line 199
 }
};

#line 207
template <class _CharT> class char_traits
 : public __char_traits_base<_CharT, _CharT>
{};

#line 213
 template<> class char_traits<char>
 : public __char_traits_base<char, int>
{
public:
 typedef char char_type;
 typedef int int_type;

#line 220
 typedef streamoff off_type;

#line 222
 typedef streampos pos_type;
 typedef mbstate_t state_type;

#line 227
 static char to_char_type(const int& __c) {
 return (char)(unsigned char)__c;
 }

#line 231
 static int to_int_type(const char& __c) {
 return (unsigned char)__c;
 }

#line 235
 static int compare(const char* __s1, const char* __s2, size_t __n)
 { return memcmp(__s1, __s2, __n); }

#line 238
 static size_t length(const char* __s) { return strlen(__s); }

#line 240
 static void assign(char& __c1, const char& __c2) { __c1 = __c2; }

#line 242
 static char* assign(char* __s, size_t __n, char __c)
 { memset(__s, __c, __n); return __s; }
};

#line 248
 template<> class char_traits<wchar_t>
 : public __char_traits_base<wchar_t, wint_t>
{};

#line 253
 }
#line 23 "../../stlport/stl/_iosfwd.h"


#line 25
 namespace _STL {

#line 27
 class ios_base;

#line 29
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

#line 32
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

#line 35
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

#line 38
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

#line 41
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

#line 44
template <class _CharT, class _Traits = char_traits<_CharT> ,
 class _Allocator = allocator<_CharT> >
class basic_stringbuf;

#line 48
template <class _CharT, class _Traits = char_traits<_CharT> ,
 class _Allocator = allocator<_CharT> >
class basic_istringstream;

#line 52
template <class _CharT, class _Traits = char_traits<_CharT> ,
 class _Allocator = allocator<_CharT> >
class basic_ostringstream;

#line 56
template <class _CharT, class _Traits = char_traits<_CharT> ,
 class _Allocator = allocator<_CharT> >
class basic_stringstream;

#line 60
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;

#line 63
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;

#line 66
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;

#line 69
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

#line 72
template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

#line 75
template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

#line 78
typedef basic_ios<char, char_traits<char> > ios;

#line 81
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;

#line 85
class locale;

#line 95
template <class _Facet> inline const _Facet& use_facet(const locale&);

#line 98
template <class _CharT> class ctype;
template <class _CharT> class ctype_byname;
template <class _CharT> class collate;
template <class _CharT> class collate_byname;

#line 103
 template<> class ctype<char>;
 template<> class ctype_byname<char>;
 template<> class collate<char>;
 template<> class collate_byname<char>;

#line 109
 template<> class ctype<wchar_t>;
 template<> class ctype_byname<wchar_t>;
 template<> class collate<wchar_t>;
 template<> class collate_byname<wchar_t>;

#line 117
 template<> class basic_streambuf<char, char_traits<char> >;

#line 120
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_streambuf<char,char_traits<char> > streambuf;

#line 125
typedef basic_stringbuf<char, char_traits<char>, allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>, allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>, allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>, allocator<char> > stringstream;

#line 130
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

#line 137
typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;

#line 142
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringstream;

#line 147
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;

#line 153
 }
#line 34 "../../stlport/iostream"

#line 1 "../../stlport/stl/_istream.h"

#line 1 "../../stlport/stl/_ios.h"

#line 1 "../../stlport/stl/_ios_base.h"

#line 1 "../../stlport/stdexcept"

#line 1 "/opt/aCC/include/exception"


#line 46
 extern const char* __no_named_exception;

#line 47
extern const char* __bad_exception;

#line 53
 class exception {
 public:
 exception() throw() {}
 exception(const exception&) throw() {}
 exception& operator=(const exception&) throw() { return *this; }
 virtual ~exception() throw() ;
 virtual const char* what() const throw() {
 return __no_named_exception;
 }
 };

#line 64
 class bad_exception : public exception {
 public:
 bad_exception() throw() {}
 virtual ~bad_exception() throw() {}
 virtual const char* what() const throw() {
 return __bad_exception;
 }
 };

#line 73
 typedef void (*unexpected_handler)();
 unexpected_handler set_unexpected(unexpected_handler f) throw() ;
 void unexpected();
 typedef void (*terminate_handler)();
 terminate_handler set_terminate(terminate_handler f) throw() ;
 void terminate();
 bool uncaught_exception();
#line 38 "../../stlport/stdexcept"

#line 1 "../../stlport/stl/_alloc.h"

#line 1 "/opt/aCC/include/cstdlib"


#line 14
inline long abs (long a) { return labs( a ); }

#line 15
inline ldiv_t div (long a, long b) { return ldiv( a, b ); }
#line 40 "../../stlport/stl/_alloc.h"

#line 1 "../../stlport/stl/_new.h"

#line 1 "/opt/aCC/include/new"


#line 36
extern const char* __bad_alloc_exception;

#line 42
 class bad_alloc : public exception {
 public:
 bad_alloc() throw() {}
 virtual ~bad_alloc() throw() {}
 virtual const char* what() const throw() {
 return __bad_alloc_exception;
 }
 };

#line 51
 struct nothrow_t {};
 const nothrow_t nothrow = {};

#line 54
 typedef void (*new_handler)();

#line 56
 new_handler set_new_handler(new_handler new_p) throw() ;

#line 81
void* operator new( size_t size) throw(bad_alloc) ;
void* operator new( size_t size, const nothrow_t &) throw() ;
void operator delete(void* ptr) throw() ;
void operator delete(void* ptr, const nothrow_t &) throw() ;
void* operator new[]( size_t size) throw(bad_alloc) ;
void* operator new[]( size_t size, const nothrow_t &) throw() ;
void operator delete[](void* ptr) throw() ;
void operator delete[](void* ptr, const nothrow_t &) throw() ;

#line 97
inline void* operator new ( size_t size, void* ptr) throw() { return ptr; }
inline void* operator new[]( size_t size, void* ptr) throw() { return ptr; }
inline void operator delete (void* ptr, void*) throw() {}
inline void operator delete[](void* ptr, void*) throw() {}
#line 47 "../../stlport/stl/_new.h"


#line 51
 namespace _STL {
 using ::bad_alloc;
 using ::nothrow_t;
 using ::nothrow;

#line 60
 using ::new_handler;
 using ::set_new_handler;

#line 64
 }

#line 76
 namespace _STL {

#line 82
 inline void* __stl_new(size_t __n) { return ::operator new(__n) ; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

#line 85
 }
#line 61 "../../stlport/stl/_alloc.h"

#line 1 "../../stlport/stl/_threads.h"


#line 56
 typedef size_t __stl_atomic_t;
#line 1 "/usr/include/pthread.h"

#line 1 "/usr/include/sys/pthread.h"

#line 1 "/usr/include/sys/pset.h"

#line 1 "/usr/include/sys/procset.h"


#line 71
typedef enum {

#line 72
 POP_AND,
 POP_OR,
 POP_XOR,
 POP_DIFF
} idop_t;

#line 81
typedef struct {

#line 83
 idtype_t p_lidtype;
 id_t p_lid;

#line 87
 idop_t p_op;

#line 90
 idtype_t p_ridtype;
 id_t p_rid;
} procset_t;

#line 98
 extern "C" {

#line 103
 extern int sigsend(idtype_t, id_t, int);
 extern int sigsendset(const procset_t *, int);

#line 113
 extern int sigsend(idtype_t, id_t, int);
 extern int sigsendset(const procset_t *, int);

#line 123
 extern int sigsend(idtype_t, id_t, int);
 extern int sigsendset(const procset_t *, int);

#line 132
 }
#line 27 "/usr/include/sys/pset.h"


#line 31
typedef int psetid_t;

#line 94
typedef enum pset_request {
 PSET_GETNUMPSETS = 1,
 PSET_GETFIRSTPSET = 2,
 PSET_GETNEXTPSET = 3,
 PSET_GETDFLTPSET = 4,
 PSET_GETCURRENTPSET = 5,
 PSET_GETNUMSPUS = 5,
 PSET_GETFIRSTSPU = 6,
 PSET_GETNEXTSPU = 7,
 PSET_SPUTOPSET = 8,
 PSET_GETNUMLDOMS = 9,
 PSET_GETFIRSTLDOM = 10,
 PSET_GETNEXTLDOM = 11,
 PSET_LDOMSPUS = 12
} pset_request_t ;

#line 124
typedef enum pset_attrtype {
 PSET_ATTR_OWNID = 1,
 PSET_ATTR_GRPID = 2,
 PSET_ATTR_PERM = 3,
 PSET_ATTR_IOINTR = 4,
 PSET_ATTR_NONEMPTY = 5,
 PSET_ATTR_EMPTY = 6,
 PSET_ATTR_LASTSPU = 7
} pset_attrtype_t ;

#line 137
typedef long pset_attrval_t;

#line 179
 extern "C" {

#line 184
 extern int pset_create ( psetid_t *pset );
 extern int pset_destroy ( psetid_t pset );
 extern int pset_assign ( psetid_t pset, spu_t spu, psetid_t* opset);
 extern int pset_bind ( psetid_t pset, idtype_t idtype,
 id_t id, psetid_t *opset);
 extern int pset_getattr ( psetid_t pset,
 pset_attrtype_t type, pset_attrval_t* value);
 extern int pset_setattr ( psetid_t pset,
 pset_attrtype_t type, pset_attrval_t value);
 extern int pset_ctl ( pset_request_t req, psetid_t pset, id_t id );

#line 208
 }
#line 44 "/usr/include/sys/pthread.h"

#line 1 "/usr/include/sys/sched.h"


#line 43
struct sched_param {
 int sched_priority;
 int sched_reserved[7];
};

#line 68
enum __sched_policy {
 SCHED_INVALID = -1,
 SCHED_FIFO = 0,
 SCHED_RR = 1,
 SCHED_HPUX = 2,

#line 76
 SCHED_RR2 = 5,
 SCHED_RTPRIO = 6,
 SCHED_NOCHANGE = 7,
 SCHED_NOAGE = 8
};

#line 95
 extern "C" {

#line 104
 extern int sched_setparam(pid_t, const struct sched_param *);
 extern int sched_getparam(pid_t, struct sched_param *);
 extern int sched_setscheduler(pid_t, int, const struct sched_param *);
 extern int sched_getscheduler(pid_t);
 extern int sched_yield(void);
 extern int sched_get_priority_max(int);
 extern int sched_get_priority_min(int);
 extern int sched_rr_get_interval(pid_t, struct timespec *);

#line 124
 }
#line 46 "/usr/include/sys/pthread.h"


#line 86
typedef int pthread_t;

#line 91
typedef int pthread_attr_t;

#line 94
typedef int pthread_mutexattr_t;
typedef int pthread_condattr_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_key_t;
typedef int pthread_spu_t;
typedef int pthread_ldom_t;

#line 147
struct pthread_mutex {
 short m_short[2];
 int m_int;
 int m_int1[4];
 int m_pad; void *m_ptr ;
 int m_int2[2];
 int m_int3[4];
 short m_short2[2];
 int m_int4[5];
 int m_int5[2];
};

#line 161
typedef struct pthread_mutex pthread_mutex_t;

#line 221
struct pthread_cond {
 short c_short[2];
 int c_int;
 int c_int1[4];
 int c_pad; void *c_ptr ;
 int c_int2[2];
 int c_int3[2];
 int c_int4[2];
};

#line 232
typedef struct pthread_cond pthread_cond_t;

#line 258
struct pthread_rwlock {
 short rw_short[2];
 int rw_int;
 int rw_int1[4];
 int rw_pad; void *rw_ptr ;
 int rw_int2[2];
 short rw_short2[2];
 int rw_int3[5];
 int rw_int4[2];
};

#line 270
typedef struct pthread_rwlock pthread_rwlock_t;

#line 288
typedef struct {
 char po_executing;
 char po_completed;
 pthread_mutex_t po_mutex;
 pthread_cond_t po_executed;
} pthread_once_t;

#line 315
typedef struct __pthread_cleanup_handler_t {
 struct __pthread_cleanup_handler_t *__next_handler;

#line 318
 void (*__handler_function)(void *);

#line 322
 void *__handler_arg;
} __pthread_cleanup_handler_t;

#line 326
 extern "C" {

#line 330
extern __pthread_cleanup_handler_t **__pthread_cancel_stack(void);

#line 336
 }

#line 447
typedef struct _pthread_stack_info {
 int stk_flags;

#line 451
 short stk_stacksize_valid;
 size_t stk_stacksize;

#line 455
 short stk_guardsize_valid;
 size_t stk_guardsize;

#line 459
 short stk_reserved1_valid;
 size_t stk_reserved1_size;

#line 462
 short stk_reserved2_valid;
 size_t stk_reserved2_size;

#line 466
 void *stk_stack_base;

#line 469
 void *stk_reserved3_base;

#line 472
 void *stk_sp;

#line 475
 void *stk_reserved4_ptr;

#line 478
 void *stk_pc;

#line 481
 void *stk_reserved[25];
} _pthread_stack_info_t;

#line 490
 extern "C" {

#line 495
 extern int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));

#line 502
 extern int __pthread_create_system(pthread_t *tid,
 const pthread_attr_t *attr,
 void *(*start_routine)(void *),
 void *arg);

#line 508
 inline int pthread_create(

#line 512
 pthread_t *tid,
 const pthread_attr_t *attr,
 void *(*start_routine)(void *),
 void *arg)
 { return(__pthread_create_system(tid, attr, start_routine, arg)); }

#line 520
 extern void pthread_exit(void *);
 extern int pthread_join(pthread_t, void **);
 extern int pthread_once(pthread_once_t *, void (*)(void));
 extern int pthread_detach(pthread_t);
 extern pthread_t pthread_self(void);
 extern int pthread_equal(pthread_t, pthread_t);
 extern int pthread_getschedparam(pthread_t, int *,
 struct sched_param *);
 extern int pthread_setschedparam(pthread_t, int, const struct sched_param *);
 extern int pthread_default_stacksize_np(size_t, size_t *);

#line 565
 extern int __pthread_attr_init_system(pthread_attr_t *attr);

#line 568
 inline int pthread_attr_init(

#line 572
 pthread_attr_t *attr)
 { return(__pthread_attr_init_system(attr)); }

#line 577
 extern int pthread_attr_destroy(pthread_attr_t *);
 extern int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
 extern int pthread_attr_setdetachstate(pthread_attr_t *, int);
 extern int pthread_attr_getinheritsched(const pthread_attr_t *, int *);
 extern int pthread_attr_getschedparam(const pthread_attr_t *,
 struct sched_param *);
 extern int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
 extern int pthread_attr_getscope(const pthread_attr_t *, int *);
 extern int pthread_attr_setinheritsched(pthread_attr_t *, int);
 extern int pthread_attr_setschedparam(pthread_attr_t *,
 const struct sched_param *);
 extern int pthread_attr_setschedpolicy(pthread_attr_t *, int);
 extern int pthread_attr_setscope(pthread_attr_t *, int);
 extern int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
 extern int pthread_attr_setstacksize(pthread_attr_t *, size_t);
 extern int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
 extern int pthread_attr_setstackaddr(pthread_attr_t *, void *);
 extern int pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
 extern int pthread_attr_setguardsize(pthread_attr_t *, size_t);
 extern int pthread_attr_getprocessor_np(const pthread_attr_t *, pthread_spu_t *, int *type);
 extern int pthread_attr_setprocessor_np(pthread_attr_t *, pthread_spu_t, int type);

#line 635
 extern int pthread_mutexattr_init(pthread_mutexattr_t *);
 extern int pthread_mutexattr_destroy(pthread_mutexattr_t *);
 extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *,
 int *);
 extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
 extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *,
 int *);
 extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
 extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *
 , int *);
 extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
 extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *);
 extern int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
 extern int pthread_mutexattr_getspin_np(const pthread_mutexattr_t *,
 int *);
 extern int pthread_mutexattr_setspin_np(pthread_mutexattr_t *, int);

#line 670
 extern int pthread_mutex_init(pthread_mutex_t *,
 const pthread_mutexattr_t *);
 extern int pthread_mutex_destroy(pthread_mutex_t *);
 extern int pthread_mutex_lock(pthread_mutex_t *);
 extern int pthread_mutex_trylock(pthread_mutex_t *);
 extern int pthread_mutex_unlock(pthread_mutex_t *);
 extern int pthread_mutex_getprioceiling(pthread_mutex_t *, int *);
 extern int pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);
 extern int pthread_mutex_getyieldfreq_np(int *);
 extern int pthread_mutex_setyieldfreq_np(int);

#line 696
 extern int pthread_condattr_destroy(pthread_condattr_t *);
 extern int pthread_condattr_init(pthread_condattr_t *);
 extern int pthread_condattr_getpshared(const pthread_condattr_t *,
 int *);
 extern int pthread_condattr_setpshared(pthread_condattr_t *, int);

#line 712
 extern int pthread_cond_destroy(pthread_cond_t *);
 extern int pthread_cond_init(pthread_cond_t *,
 const pthread_condattr_t *);
 extern int pthread_cond_signal(pthread_cond_t *);
 extern int pthread_cond_broadcast(pthread_cond_t *);
 extern int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
 extern int pthread_cond_timedwait(pthread_cond_t *,
 pthread_mutex_t *, const struct timespec *);

#line 733
 extern int pthread_rwlockattr_init(pthread_rwlockattr_t *);
 extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
 extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,int *);
 extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

#line 748
 extern int pthread_rwlock_init(pthread_rwlock_t *,
 const pthread_rwlockattr_t *);
 extern int pthread_rwlock_destroy(pthread_rwlock_t *);
 extern int pthread_rwlock_rdlock(pthread_rwlock_t *);
 extern int pthread_rwlock_wrlock(pthread_rwlock_t *);
 extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
 extern int pthread_rwlock_trywrlock(pthread_rwlock_t *);
 extern int pthread_rwlock_unlock(pthread_rwlock_t *);

#line 770
 extern int pthread_key_create(pthread_key_t *, void (*)(void *));
 extern int pthread_key_delete(pthread_key_t);
 extern void *pthread_getspecific(pthread_key_t);
 extern int pthread_setspecific(pthread_key_t, const void *);

#line 785
 extern int pthread_cancel(pthread_t);
 extern int pthread_setcancelstate(int, int *);
 extern int pthread_setcanceltype(int, int *);
 extern void pthread_testcancel(void);

#line 800
 extern int pthread_kill(pthread_t, int);
 extern int pthread_sigmask(int, const sigset_t *, sigset_t *);

#line 811
 extern int pthread_suspend(pthread_t);
 extern int pthread_resume_np(pthread_t, int);
 extern int pthread_continue(pthread_t);
 extern int pthread_setconcurrency(int);
 extern int pthread_getconcurrency(void);
 extern int pthread_num_processors_np(void);
 extern int pthread_processor_id_np(int, pthread_spu_t *,
 pthread_spu_t);
 extern int pthread_processor_bind_np(int, pthread_spu_t *,
 pthread_spu_t, pthread_t);
 extern int pthread_pset_bind_np(psetid_t *, psetid_t, pthread_t);
 extern int pthread_num_ldoms_np(void);
 extern int pthread_num_ldomprocs_np(int *, pthread_ldom_t);
 extern int pthread_ldom_id_np(int, pthread_ldom_t *, pthread_ldom_t);
 extern int pthread_spu_to_ldom_np(pthread_spu_t, pthread_ldom_t *);
 extern int pthread_ldom_bind_np(pthread_ldom_t *, pthread_ldom_t,
 pthread_t);
 extern int pthread_launch_policy_np(int, int *, pthread_t);
 extern int _pthread_stack_info_np(pthread_t id, struct _pthread_stack_info *state);
 extern int _pthread_getstate_np(pthread_t id, struct __ucontext *state);
 extern int _pthread_callback_np(int type, void (*fp)(pthread_t parent, pthread_t child, const _pthread_stack_info_t *stack_info));

#line 854
 }
#line 8 "/usr/include/pthread.h"

#line 78 "../../stlport/stl/_threads.h"


#line 207
 namespace _STL {

#line 210
 template <int __inst>
struct _STLP_mutex_spin {
 enum { __low_max = 30, __high_max = 1000 };

#line 214
 static unsigned __max;
 static unsigned __last;
 static void _M_do_lock(volatile __stl_atomic_t* __lock);
 static void _S_nsec_sleep(int __log_nsec);
};

#line 235
struct _STLP_mutex_base
{

#line 334
 inline void _M_initialize() {}
 inline void _M_destroy() {}
 inline void _M_acquire_lock() {}
 inline void _M_release_lock() {}

#line 339
};

#line 346
struct _STLP_mutex_indirect
{
 void* _M_lock;

#line 351
 inline void _M_initialize() {
 _M_lock = (void*) ::calloc(1,sizeof(pthread_mutex_t));
 pthread_mutex_init((pthread_mutex_t*)_M_lock, 0 );
 }
 inline void _M_destroy() {
 pthread_mutex_destroy((pthread_mutex_t*)_M_lock);
 free((char*)_M_lock);
 }
 inline void _M_acquire_lock() {
 pthread_mutex_lock((pthread_mutex_t*)_M_lock);
 }
 inline void _M_release_lock() { pthread_mutex_unlock((pthread_mutex_t*)_M_lock); }

#line 396
};

#line 402
struct _STLP_mutex : public _STLP_mutex_indirect {
 inline _STLP_mutex () {
 _M_initialize();
 }
 inline ~_STLP_mutex () {
 _M_destroy();
 }
private:
 _STLP_mutex(const _STLP_mutex&);
 void operator=(const _STLP_mutex&);
};

#line 418
struct _Refcount_Base
{

#line 421
 volatile __stl_atomic_t _M_ref_count;

#line 424
 _STLP_mutex _M_mutex;

#line 428
 _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}

#line 446
 void _M_incr() { ++_M_ref_count; }
 void _M_decr() { --_M_ref_count; }

#line 449
};

#line 461
template<int __dummy>
struct _Swap_lock_struct {
 static _STLP_mutex_base _S_swap_lock;
};

#line 470
inline __stl_atomic_t _Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
 _Swap_lock_struct<0>::_S_swap_lock._M_acquire_lock();
 __stl_atomic_t __result = *__p;
 *__p = __q;
 _Swap_lock_struct<0>::_S_swap_lock._M_release_lock();
 return __result;
}

#line 493
struct _STLP_auto_lock
{
 _STLP_mutex_base & _M_lock;

#line 497
 _STLP_auto_lock( _STLP_mutex_base & __lock) : _M_lock(__lock)
 { _M_lock._M_acquire_lock(); }
 ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

#line 501
private:
 void operator=(const _STLP_auto_lock&);
 _STLP_auto_lock(const _STLP_auto_lock&);
};

#line 506
struct _STLP_mutex_lock
{
 _STLP_mutex_indirect& _M_lock;

#line 510
 _STLP_mutex_lock(_STLP_mutex_indirect& __lock) : _M_lock(__lock)
 { _M_lock._M_acquire_lock(); }
 ~_STLP_mutex_lock() { _M_lock._M_release_lock(); }

#line 514
private:
 void operator=(const _STLP_mutex_lock&);
 _STLP_mutex_lock(const _STLP_mutex_lock&);
};

#line 572
 }
#line 1 "../../stlport/stl/_threads.c"

#line 576 "../../stlport/stl/_threads.h"

#line 65 "../../stlport/stl/_alloc.h"

#line 1 "../../stlport/stl/_construct.h"

#line 1 "../../stlport/stl/_iterator_base.h"


#line 41
 namespace _STL {

#line 43
 struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

#line 50
template <class _Category, class _Tp, class _Distance = ptrdiff_t ,
 class _Pointer = _Tp* , class _Reference = _Tp& >
struct iterator {
 typedef _Category iterator_category;
 typedef _Tp value_type;
 typedef _Distance difference_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
};
 template<>
 struct iterator<output_iterator_tag, void, void, void, void> {
 typedef output_iterator_tag iterator_category;

#line 63
 typedef void value_type;
 typedef void difference_type;
 typedef void pointer;
 typedef void reference;

#line 68
};

#line 90
template <class _Iterator>
struct iterator_traits {
 typedef typename _Iterator::iterator_category iterator_category;
 typedef typename _Iterator::value_type value_type;
 typedef typename _Iterator::difference_type difference_type;
 typedef typename _Iterator::pointer pointer;
 typedef typename _Iterator::reference reference;
};

#line 109
template <class _Tp>
struct iterator_traits<const _Tp*> {
 typedef random_access_iterator_tag iterator_category;
 typedef _Tp value_type;
 typedef ptrdiff_t difference_type;
 typedef const _Tp* pointer;
 typedef const _Tp& reference;
};

#line 118
template <class _Tp>
struct iterator_traits<_Tp*> {
 typedef random_access_iterator_tag iterator_category;
 typedef _Tp value_type;
 typedef ptrdiff_t difference_type;
 typedef _Tp* pointer;
 typedef _Tp& reference;
};

#line 158
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
 typedef typename iterator_traits<_Iter>::iterator_category _Category;
 return _Category();
}

#line 164
template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
 typedef typename iterator_traits<_Iter>::difference_type _diff_type;
 return static_cast<_diff_type*>(0) ;
}

#line 170
template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
 typedef typename iterator_traits<_Iter>::value_type _value_type;
 return static_cast<_value_type*>(0) ;
}

#line 230
template <class _Tp, class _Distance> struct input_iterator :
 public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
 public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
 public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
 public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};

#line 275
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
 _Distance& __n, const input_iterator_tag &) {
 _InputIterator __it(__first);
 while (__it != __last) { ++__it; ++__n; }
}

#line 299
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
 const _RandomAccessIterator& __last,
 _Distance& __n, const random_access_iterator_tag &) {
 __n += __last - __first;
}

#line 307
template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
 const _InputIterator& __last, _Distance& __n) {
 __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category() );
}

#line 314
template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
 __distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
 typename iterator_traits<_InputIterator>::difference_type __n = 0;
 _InputIterator __it(__first);
 while (__it != __last) {
 ++__it; ++__n;
 }
 return __n;
}

#line 353
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
 __distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
 const random_access_iterator_tag &) {
 return __last - __first;
}

#line 360
template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
 distance(const _InputIterator& __first, const _InputIterator& __last) {
 return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category() );
}

#line 368
template <class _Tp>
struct _Nonconst_traits;

#line 371
template <class _Tp>
struct _Const_traits {
 typedef _Tp value_type;
 typedef const _Tp& reference;
 typedef const _Tp* pointer;
 typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

#line 379
template <class _Tp>
struct _Nonconst_traits {
 typedef _Tp value_type;
 typedef _Tp& reference;
 typedef _Tp* pointer;
 typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

#line 408
template <class _InputIter, class _Distance>
 inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
 while (__n--) ++__i;
}

#line 414
template <class _InputIter, class _Distance>
 inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
 while (__n--) ++__i;
}

#line 426
template <class _BidirectionalIterator, class _Distance>
 inline void __advance(_BidirectionalIterator& __i, _Distance __n,
 const bidirectional_iterator_tag &) {
 if (__n > 0)
 while (__n--) ++__i;
 else
 while (__n++) --__i;
}

#line 435
template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
 const random_access_iterator_tag &) {
 __i += __n;
}

#line 441
template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
 __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category() );
}

#line 446
 }
#line 44 "../../stlport/stl/_construct.h"


#line 46
 namespace _STL {

#line 55
 template <class _Tp>
inline void _Destroy(_Tp* __pointer) {

#line 67
 __pointer->~_Tp();

#line 73
}

#line 80
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {

#line 85
 new (__p) _T1(__val);
}

#line 88
template <class _T1>
inline void _Construct(_T1* __p) {

#line 93
 new (__p) _T1();
}

#line 103
template <class _ForwardIterator>
 inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
 for ( ; __first != __last; ++__first)
 _Destroy(&*__first);
}

#line 110
template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

#line 113
template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
 typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
 __destroy_aux(__first, __last, _Trivial_destructor());
}

#line 120
template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
 __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0 );
}

#line 125
inline void _Destroy(char*, char*) {}

#line 127
inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}

#line 135
template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _Destroy(__first, __last); }

#line 144
 }
#line 69 "../../stlport/stl/_alloc.h"


#line 85
 namespace _STL {

#line 94
 typedef void (* __oom_handler_type)();

#line 96
template <int __inst>
class __malloc_alloc {
private:
 static void* _S_oom_malloc(size_t);
 static __oom_handler_type __oom_handler;
public:

#line 103
 typedef char value_type;

#line 109
 static void* allocate(size_t __n) {
 void* __result = malloc(__n);
 if (0 == __result) __result = _S_oom_malloc(__n);
 return __result;
 }
 static void deallocate(void* __p, size_t ) { free((char*)__p); }
 static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
 __oom_handler_type __old = __oom_handler;
 __oom_handler = __f;
 return(__old);
 }
};

#line 125
class __new_alloc {
public:

#line 128
 typedef char value_type;

#line 134
 static void* allocate(size_t __n) { return __stl_new(__n); }
 static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};

#line 146
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
 typedef _Alloc __allocator_type;
 typedef typename _Alloc::value_type value_type;
private:
 struct __alloc_header {
 size_t __magic: 16;
 size_t __type_size:16;
 unsigned long _M_size;
 };

#line 158
 enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
 __shred_byte= 0xA3
 };

#line 162
 enum { __extra_before = 16, __extra_after = 8 };

#line 166
 static size_t __extra_before_chunk() {
 return (long)__extra_before/sizeof(value_type)+
 (size_t)((long)__extra_before%sizeof(value_type)>0);
 }
 static size_t __extra_after_chunk() {
 return (long)__extra_after/sizeof(value_type)+
 (size_t)((long)__extra_after%sizeof(value_type)>0);
 }
public:

#line 180
 __debug_alloc() {}
 ~__debug_alloc() {}
 static void * allocate(size_t);
 static void deallocate(void *, size_t);
};

#line 214
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};

#line 218
class _Node_alloc_obj {
public:
 _Node_alloc_obj * _M_free_list_link;
};

#line 223
template <bool __threads, int __inst>
class __node_alloc {
 public :
 static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
 typedef _Node_alloc_obj _Obj;
private:

#line 230
 static void* _S_refill(size_t __n);

#line 233
 static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

#line 235
 static _Node_alloc_obj * _S_free_list[ 16 ];
 static char* _S_start_free;
 static char* _S_end_free;
 static size_t _S_heap_size;
 static void * _M_allocate(size_t __n);

#line 241
 static void _M_deallocate(void *__p, size_t __n);
public:

#line 244
 typedef char value_type;

#line 251
 static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

#line 253
 static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};

#line 260
typedef __node_alloc< true , 0> _Node_alloc;

#line 312
typedef _Node_alloc __sgi_alloc;

#line 315
typedef __node_alloc<false, 0> __single_client_alloc;
typedef __node_alloc<true, 0> __multithreaded_alloc;

#line 329
template <class _Tp>
class allocator {
public:

#line 333
 typedef _Tp value_type;
 typedef value_type * pointer;
 typedef const _Tp* const_pointer;
 typedef _Tp& reference;
 typedef const _Tp& const_reference;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

#line 341
 template <class _Tp1> struct rebind {
 typedef allocator<_Tp1> other;
 };

#line 345
 allocator() {}

#line 347
 template <class _Tp1> allocator(const allocator<_Tp1>&) {}

#line 349
 allocator(const allocator<_Tp>&) {}
 ~allocator() {}
 pointer address(reference __x) { return &__x; }
 const_pointer address(const_reference __x) const { return &__x; }

#line 354
 _Tp* allocate(size_type __n, const void* = 0) const {
 return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
 }

#line 358
 void deallocate(pointer __p, size_type __n) const {

#line 360
 if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
 }

#line 363
 void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
 size_type max_size() const { return size_t(-1) / sizeof(value_type); }
 void construct(pointer __p, const _Tp& __val) const { _STL ::_Construct(__p, __val); }
 void destroy(pointer __p) const { _STL ::_Destroy(__p); }

#line 371
};

#line 373
 template<>
 class allocator<void> {
public:
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef void* pointer;
 typedef const void* const_pointer;

#line 381
 typedef void value_type;

#line 384
 template <class _Tp1> struct rebind {
 typedef allocator<_Tp1> other;
 };

#line 392
};

#line 395
template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }

#line 411
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
 typedef _Allocator _Orig;

#line 416
 typedef typename _Allocator:: template rebind<_Tp> _Rebind_type;
 typedef typename _Rebind_type::other allocator_type;
 static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }

#line 424
};

#line 457
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
 typedef typename _Alloc:: template rebind<_Tp>::other _Rebound_type;
 return _Rebound_type(__a);
}

#line 480
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
 typedef _MaybeReboundAlloc _Base;
 typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
 _Value _M_data;
 inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}

#line 509
};

#line 520
 }
#line 46 "../../stlport/stdexcept"

#line 1 "../../stlport/stl/_string_fwd.h"

#line 1 "../../stlport/iosfwd"

#line 24 "../../stlport/stl/_string_fwd.h"


#line 26
 namespace _STL {

#line 29
 template <class _CharT,
 class _Traits = char_traits<_CharT>,
 class _Alloc = allocator<_CharT> >
class basic_string;

#line 40
typedef basic_string<char, char_traits<char>, allocator<char> > string;

#line 43
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

#line 47
 const char*
__get_c_string(const string& __str);

#line 55
 }
#line 50 "../../stlport/stdexcept"


#line 54
 namespace _STL {

#line 58
 using ::exception;

#line 63
class __Named_exception : public exception {
public:
 __Named_exception(const string& __str)

#line 67
 ;
 const char* what() const throw() ;
 ~__Named_exception() throw() ;

#line 78
private:
 enum { _S_bufsize = 256 };
 char _M_name[_S_bufsize];
};

#line 83
class logic_error : public __Named_exception {
public:
 logic_error(const string& __s) : __Named_exception(__s) {}

#line 87
 ~logic_error() throw() ;

#line 89
};

#line 91
class runtime_error : public __Named_exception {
public:
 runtime_error(const string& __s) : __Named_exception(__s) {}

#line 95
 ~runtime_error() throw() ;

#line 97
};

#line 99
class domain_error : public logic_error {
public:
 domain_error(const string& __arg) : logic_error(__arg) {}

#line 103
 ~domain_error() throw() ;

#line 105
};

#line 107
class invalid_argument : public logic_error {
public:
 invalid_argument(const string& __arg) : logic_error(__arg) {}

#line 111
 ~invalid_argument() throw() ;

#line 113
};

#line 115
class length_error : public logic_error {
public:
 length_error(const string& __arg) : logic_error(__arg) {}

#line 119
 ~length_error() throw() ;

#line 121
};

#line 123
class out_of_range : public logic_error {
public:
 out_of_range(const string& __arg) : logic_error(__arg) {}

#line 127
 ~out_of_range() throw() ;

#line 129
};

#line 131
class range_error : public runtime_error {
public:
 range_error(const string& __arg) : runtime_error(__arg) {}

#line 135
 ~range_error() throw() ;

#line 137
};

#line 139
class overflow_error : public runtime_error {
public:
 overflow_error(const string& __arg) : runtime_error(__arg) {}

#line 143
 ~overflow_error() throw() ;

#line 145
};

#line 147
class underflow_error : public runtime_error {
public:
 underflow_error(const string& __arg) : runtime_error(__arg) {}

#line 151
 ~underflow_error() throw() ;

#line 153
};

#line 155
 }
#line 23 "../../stlport/stl/_ios_base.h"

#line 1 "../../stlport/utility"

#line 1 "../../stlport/stl/_pair.h"


#line 34
 namespace _STL {

#line 36
 template <class _T1, class _T2>
struct pair {
 typedef _T1 first_type;
 typedef _T2 second_type;

#line 41
 _T1 first;
 _T2 second;

#line 46
 pair() : first(_T1()), second(_T2()) {}

#line 48
 pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}

#line 51
 template <class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

#line 54
 pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

#line 57
};

#line 59
template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
 return __x.first == __y.first && __x.second == __y.second;
}

#line 65
template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
 return __x.first < __y.first ||
 (!(__y.first < __x.first) && __x.second < __y.second);
}

#line 74
template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
 return !(__x == __y);
}

#line 79
template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
 return __y < __x;
}

#line 84
template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
 return !(__y < __x);
}

#line 89
template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
 return !(__x < __y);
}

#line 98
template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
 _T2 const (&__y)[_Sz])
{
 return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

#line 105
template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
 _T2 const& __y)
{
 return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

#line 112
template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
 _T2 const (&__y)[_Sz2])
{
 return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
 static_cast<_T2 const*>(__y));
}

#line 121
template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
 return pair<_T1, _T2>(__x, __y);
}

#line 128
 }

#line 131
 namespace _STL { namespace rel_ops {

#line 133
 template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
 return !(__x == __y);
}

#line 138
template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
 return __y < __x;
}

#line 143
template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
 return !(__y < __x);
}

#line 148
template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
 return !(__x < __y);
}

#line 153
 } }
#line 45 "../../stlport/utility"

#line 26 "../../stlport/stl/_ios_base.h"

#line 1 "../../stlport/stl/_locale.h"


#line 42
 namespace _STL {

#line 44
 class _Locale_impl;
class _Locale;
class locale;
class ios_base;

#line 50
template <class _CharT>
bool
__locale_do_operator_call (const locale* __that,
 const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __x,
 const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __y);

#line 58
class locale {
public:

#line 62
 class facet : private _Refcount_Base {
 protected:
 explicit facet(size_t __no_del = 0) : _Refcount_Base(1), _M_delete(__no_del == 0) {}
 virtual ~facet();
 friend class locale;
 friend class _Locale_impl;
 friend class _Locale;

#line 70
 private:
 facet(const facet& __f) : _Refcount_Base(1), _M_delete(__f._M_delete == 0) {};
 void operator=(const facet&);

#line 74
 private:
 const bool _M_delete;
 };

#line 81
 class

#line 83
 id {
 friend class locale;
 friend class _Locale_impl;
 public:
 size_t _M_index;
 static size_t _S_max;
 };

#line 91
 typedef int category;

#line 95
 static const category

#line 97
 none = 0x000,
 collate = 0x010,
 ctype = 0x020,
 monetary = 0x040,
 numeric = 0x100,
 time = 0x200,
 messages = 0x400,
 all = collate | ctype | monetary | numeric | time | messages

#line 108
 ;

#line 111
 locale();
 locale(const locale&) ;
 explicit locale(const char *);
 locale(const locale&, const char*, category);

#line 117
 locale(_Locale_impl*);
 locale(_Locale_impl*, bool);

#line 120
public:

#line 123
 template <class _Facet>
 locale(const locale& __loc, _Facet* __f) : _M_impl(0)
 {

#line 127
 new(this) locale(__loc._M_impl, __f != 0);
 if (__f != 0)
 this->_M_insert(__f, _Facet::id);
 }

#line 133
 locale(const locale&, const locale&, category);
 ~locale() ;
 const locale& operator=(const locale&) ;

#line 138
 template <class _Facet> locale combine(const locale& __loc) {
 locale __result(__loc._M_impl, true);
 if (facet* __f = __loc._M_get_facet(_Facet::id)) {
 __result._M_insert(__f, _Facet::id);
 __f->_M_incr();
 }
 else
 _M_throw_runtime_error();
 return __result;
 }

#line 150
 string name() const;

#line 152
 bool operator==(const locale&) const;
 bool operator!=(const locale&) const;

#line 161
 template <class _CharT, class _Traits, class _Alloc>
 bool operator()(const basic_string<_CharT, _Traits, _Alloc>& __x,
 const basic_string<_CharT, _Traits, _Alloc>& __y) const {
 return __locale_do_operator_call(this, __x, __y);
 }

#line 169
 static locale global(const locale&);
 static const locale& classic();

#line 172
public:
 facet* _M_get_facet(const id&) const;

#line 175
 facet* _M_use_facet(const id&) const;
 static void _M_throw_runtime_error(const char* = 0);
 static void _S_initialize();
 static void _S_uninitialize();

#line 180
private:

#line 182
 void _M_insert(facet* __f, id& __id);

#line 185
 friend class _Locale_impl;
 friend class _Locale;
 friend class ios_base;

#line 189
private:
 _Locale_impl* _M_impl;
};

#line 201
template <class _Facet> inline const _Facet& use_facet(const locale& __loc)

#line 203
{
 return * static_cast<const _Facet*>(__loc._M_use_facet(_Facet::id)) ;
}

#line 215
template <class _Facet> inline bool has_facet(const locale& __loc)

#line 217
{
 return (__loc._M_get_facet(_Facet::id) != 0);
}

#line 226
 }
#line 29 "../../stlport/stl/_ios_base.h"

#line 1 "../../stlport/stl/_string.h"

#line 1 "../../stlport/memory"

#line 1 "../../stlport/stl/_tempbuf.h"

#line 1 "/opt/aCC/include/climits"

#line 35 "../../stlport/stl/_tempbuf.h"

#line 1 "../../stlport/stl/_uninitialized.h"

#line 1 "../../stlport/stl/_algobase.h"


#line 58
 namespace _STL {

#line 60
 template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
 _Tp __tmp = __a;
 __a = __b;
 __b = __tmp;
}

#line 67
template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
 swap(*__i1, *__i2);
}

#line 76
template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }

#line 87
template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
 return __comp(__b, __a) ? __b : __a;
}

#line 92
template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
 return __comp(__a, __b) ? __b : __a;
}

#line 106
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
 _OutputIter __result,
 const input_iterator_tag &, _Distance*) {
 for ( ; __first != __last; ++__result, ++__first)
 *__result = *__first;
 return __result;
}

#line 134
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
 _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
 for (_Distance __n = __last - __first; __n > 0; --__n) {
 *__result = *__first;
 ++__first;
 ++__result;
 }
 return __result;
}

#line 146
inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
 return (__last == __first) ? __result :
 ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
 ((const char*)__last - (const char*)__first);
}

#line 156
template <class _BidirectionalIter1, class _BidirectionalIter2,
 class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
 _BidirectionalIter1 __last,
 _BidirectionalIter2 __result,
 const bidirectional_iterator_tag &,
 _Distance*)
{
 while (__first != __last)
 *--__result = *--__last;
 return __result;
}

#line 169
template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
 _RandomAccessIter __last,
 _BidirectionalIter __result,
 const random_access_iterator_tag &,
 _Distance*)
{
 for (_Distance __n = __last - __first; __n > 0; --__n)
 *--__result = *--__last;
 return __result;
}

#line 181
inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
 const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
 return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

#line 187
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
 return __copy(__first, __last, __result,
 typename iterator_traits< _InputIter >::iterator_category() ,
 (typename iterator_traits< _InputIter >::difference_type*)0 );
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {

#line 197
 return (_OutputIter)__copy_trivial(__first, __last, __result);
}

#line 200
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
 return __copy_ptrs(__first, __last, __result,
 _IsOKToMemCpy( (typename iterator_traits< _InputIter >::value_type*)0 ,
 (typename iterator_traits< _OutputIter >::value_type*)0 )._Ret());
}

#line 207
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
 return __copy(__first, __last, __result,
 typename iterator_traits< _InputIter >::iterator_category() , (typename iterator_traits< _InputIter >::difference_type*)0 );
}

#line 213
template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {

#line 216
 return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

#line 219
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
 return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category() , (typename iterator_traits< _InputIter >::difference_type*)0 );
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
 return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

#line 228
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
 return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category() , (typename iterator_traits< _InputIter >::difference_type*)0 );
}

#line 233
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
 return __copy_backward_ptrs(__first, __last, __result,
 _IsOKToMemCpy( (typename iterator_traits< _InputIter >::value_type*)0 ,
 (typename iterator_traits< _OutputIter >::value_type*)0 )._Ret());
}

#line 240
template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {

#line 243
 return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}

#line 282
template <class _InputIter, class _Size, class _OutputIter>
 inline
 pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
 _OutputIter __result,
 const input_iterator_tag &) {
 for ( ; __count > 0; --__count) {
 *__result = *__first;
 ++__first;
 ++__result;
 }
 return pair<_InputIter, _OutputIter>(__first, __result);
}

#line 295
template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
 _OutputIter __result,
 const random_access_iterator_tag &) {
 _RAIter __last = __first + __count;
 return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

#line 304
template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 __first=__first;
 return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category() );
}

#line 311
template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 __first=__first;
 return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category() );
}

#line 322
template <class _ForwardIter, class _Tp>
 inline
 void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {

#line 326
 for ( ; __first != __last; ++__first)
 *__first = __val;
}

#line 330
template <class _OutputIter, class _Size, class _Tp>
 inline
 _OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 __first=__first;
 for ( ; __n > 0; --__n, ++__first)
 *__first = __val;
 return __first;
}

#line 342
inline void fill(unsigned char* __first, unsigned char* __last,
 const unsigned char& __val) {
 unsigned char __tmp = __val;
 memset(__first, __tmp, __last - __first);
}

#line 348
inline void fill(signed char* __first, signed char* __last,
 const signed char& __val) {
 signed char __tmp = __val;
 memset(__first, static_cast<unsigned char>(__tmp) , __last - __first);
}

#line 354
inline void fill(char* __first, char* __last, const char& __val) {
 char __tmp = __val;
 memset(__first, static_cast<unsigned char>(__tmp) , __last - __first);
}

#line 361
template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
 const unsigned char& __val) {
 fill(__first, __first + __n, __val);
 return __first + __n;
}

#line 368
template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
 const signed char& __val) {
 fill(__first, __first + __n, __val);
 return __first + __n;
}

#line 375
template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
 fill(__first, __first + __n, __val);
 return __first + __n;
}

#line 387
template <class _InputIter1, class _InputIter2>
 inline
 pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
 _InputIter1 __last1,
 _InputIter2 __first2) {
 __first2=__first2;

#line 394
 while (__first1 != __last1 && *__first1 == *__first2) {
 ++__first1;
 ++__first2;
 }
 return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

#line 401
template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
 inline
 pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
 _InputIter1 __last1,
 _InputIter2 __first2,
 _BinaryPredicate __binary_pred) {
 __first2=__first2;

#line 409
 while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
 ++__first1;
 ++__first2;
 }
 return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

#line 416
template <class _InputIter1, class _InputIter2>
 inline
 bool equal(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2) {
 __first1=__first1; __last1=__last1; __first2=__first2;

#line 422
 for ( ; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
 return false;
 return true;
}

#line 428
template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
 inline
 bool equal(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 __first2=__first2;

#line 434
 for ( ; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
 return false;
 return true;
}

#line 444
template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2);

#line 448
template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _Compare __comp);

#line 453
inline bool
lexicographical_compare(const unsigned char* __first1,
 const unsigned char* __last1,
 const unsigned char* __first2,
 const unsigned char* __last2)
{
 const size_t __len1 = __last1 - __first1;
 const size_t __len2 = __last2 - __first2;

#line 464
 const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
 return __result != 0 ? (__result < 0) : (__len1 < __len2);
}

#line 483
template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2);

#line 487
inline int
__lexicographical_compare_3way(const unsigned char* __first1,
 const unsigned char* __last1,
 const unsigned char* __first2,
 const unsigned char* __last2)
{
 const ptrdiff_t __len1 = __last1 - __first1;
 const ptrdiff_t __len2 = __last2 - __first2;
 const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
 return __result != 0 ? __result
 : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}

#line 515
template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2);

#line 522
template <class _InputIter, class _Tp>
 inline typename iterator_traits<_InputIter>::difference_type
 count(_InputIter __first, _InputIter __last, const _Tp& __val) {

#line 526
 typename iterator_traits<_InputIter>::difference_type __n = 0;
 for ( ; __first != __last; ++__first)
 if (*__first == __val)
 ++__n;
 return __n;
}

#line 534
template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);

#line 540
template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);

#line 545
template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
 _ForwardIter __first2, _ForwardIter __last2,
 _BinaryPredicate __comp);

#line 550
template <class _ForwardIter1, class _ForwardIter2,
 class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2,
 _BinaryPredicate __comp);

#line 558
template <class _ForwardIter, class _Tp>
 inline void
replace(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __old_value, const _Tp& __new_value) {

#line 563
 for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
 *__first = __new_value;
}

#line 568
template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val, _Compare __comp, _Distance*);

#line 572
 }
#line 1 "../../stlport/stl/_algobase.c"


#line 32
 namespace _STL {

#line 34
 template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2) {

#line 39
 for ( ; __first1 != __last1 && __first2 != __last2
 ; ++__first1, ++__first2) {
 if (*__first1 < *__first2)
 return true;
 if (*__first2 < *__first1)
 return false;
 }
 return __first1 == __last1 && __first2 != __last2;
}

#line 49
template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _Compare __comp) {

#line 55
 for ( ; __first1 != __last1 && __first2 != __last2
 ; ++__first1, ++__first2) {
 if (__comp(*__first1, *__first2))
 return true;
 if (__comp(*__first2, *__first1))
 return false;
 }
 return __first1 == __last1 && __first2 != __last2;
}

#line 67
template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2)
{
 while (__first1 != __last1 && __first2 != __last2) {
 if (*__first1 < *__first2)
 return -1;
 if (*__first2 < *__first1)
 return 1;
 ++__first1;
 ++__first2;
 }
 if (__first2 == __last2) {
 return !(__first1 == __last1);
 }
 else {
 return -1;
 }
}

#line 88
template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2)
{

#line 94
 return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}

#line 98
template <class _RandomAccessIter, class _Tp>
 inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
 const _Tp& __val,
 const random_access_iterator_tag &)
{
 typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

#line 105
 for ( ; __trip_count > 0 ; --__trip_count) {
 if (*__first == __val) return __first;
 ++__first;

#line 109
 if (*__first == __val) return __first;
 ++__first;

#line 112
 if (*__first == __val) return __first;
 ++__first;

#line 115
 if (*__first == __val) return __first;
 ++__first;
 }

#line 119
 switch(__last - __first) {
 case 3:
 if (*__first == __val) return __first;
 ++__first;
 case 2:
 if (*__first == __val) return __first;
 ++__first;
 case 1:
 if (*__first == __val) return __first;
 ++__first;
 case 0:
 default:
 return __last;
 }
}

#line 135
template <class _RandomAccessIter, class _Predicate>
 inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
 _Predicate __pred,
 const random_access_iterator_tag &)
{
 typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

#line 142
 for ( ; __trip_count > 0 ; --__trip_count) {
 if (__pred(*__first)) return __first;
 ++__first;

#line 146
 if (__pred(*__first)) return __first;
 ++__first;

#line 149
 if (__pred(*__first)) return __first;
 ++__first;

#line 152
 if (__pred(*__first)) return __first;
 ++__first;
 }

#line 156
 switch(__last - __first) {
 case 3:
 if (__pred(*__first)) return __first;
 ++__first;
 case 2:
 if (__pred(*__first)) return __first;
 ++__first;
 case 1:
 if (__pred(*__first)) return __first;

#line 166
 case 0:
 default:
 return __last;
 }
}

#line 172
template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
 const _Tp& __val,
 const input_iterator_tag &)
{
 while (__first != __last && !(*__first == __val))
 ++__first;
 return __first;
}

#line 182
template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
 _Predicate __pred,
 const input_iterator_tag &)
{
 while (__first != __last && !__pred(*__first))
 ++__first;
 return __first;
}

#line 192
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
 _Predicate __pred) {

#line 196
 return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category() );
}

#line 199
template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{

#line 203
 return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category() );
}

#line 206
template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2,
 _BinaryPred __predicate)
{

#line 214
 if (__first1 == __last1 || __first2 == __last2)
 return __first1;

#line 218
 _ForwardIter2 __tmp(__first2);
 ++__tmp;
 if (__tmp == __last2) {
 while (__first1 != __last1 && !__predicate(*__first1, *__first2))
 ++__first1;
 return __first1;
 }

#line 228
 _ForwardIter2 __p1, __p;

#line 230
 __p1 = __first2; ++__p1;

#line 234
 while (__first1 != __last1) {
 while (__first1 != __last1) {
 if (__predicate(*__first1, *__first2))
 break;
 ++__first1;
 }
 while (__first1 != __last1 && !__predicate(*__first1, *__first2))
 ++__first1;
 if (__first1 == __last1)
 return __last1;

#line 245
 __p = __p1;
 _ForwardIter1 __current = __first1;
 if (++__current == __last1) return __last1;

#line 249
 while (__predicate(*__current, *__p)) {
 if (++__p == __last2)
 return __first1;
 if (++__current == __last1)
 return __last1;
 }

#line 256
 ++__first1;
 }
 return __first1;
}

#line 263
template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
 _ForwardIter __first2, _ForwardIter __last2,
 _BinaryPredicate __comp) {
 for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
 if (__comp(*__first1, *__iter))
 return __first1;
 return __last1;
}

#line 282
template <class _ForwardIter1, class _ForwardIter2,
 class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2,
 const forward_iterator_tag &, const forward_iterator_tag &,
 _BinaryPredicate __comp)
{
 if (__first2 == __last2)
 return __last1;
 else {
 _ForwardIter1 __result = __last1;
 while (1) {
 _ForwardIter1 __new_result
 = search(__first1, __last1, __first2, __last2, __comp);
 if (__new_result == __last1)
 return __result;
 else {
 __result = __new_result;
 __first1 = __new_result;
 ++__first1;
 }
 }
 }
}

#line 311
 }
#line 1 "../../stlport/stl/_iterator.h"


#line 37
 namespace _STL {

#line 46
 template <class _Iterator>
class reverse_iterator :
 public iterator<typename iterator_traits<_Iterator>::iterator_category,
 typename iterator_traits<_Iterator>::value_type,
 typename iterator_traits<_Iterator>::difference_type,
 typename iterator_traits<_Iterator>::pointer,
 typename iterator_traits<_Iterator>::reference>
{
protected:
 _Iterator current;
 typedef reverse_iterator<_Iterator> _Self;
public:
 typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
 typedef typename iterator_traits<_Iterator>::value_type value_type;
 typedef typename iterator_traits<_Iterator>::difference_type difference_type;
 typedef typename iterator_traits<_Iterator>::pointer pointer;
 typedef typename iterator_traits<_Iterator>::reference reference;
 typedef _Iterator iterator_type;
public:
 reverse_iterator() {}
 explicit reverse_iterator(iterator_type __x) : current(__x) {}
 reverse_iterator(const _Self& __x) : current(__x.current) {}
 _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

#line 70
 template <class _Iter>
 reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
 template <class _Iter>
 _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }

#line 76
 iterator_type base() const { return current; }
 reference operator*() const {
 _Iterator __tmp = current;
 return *--__tmp;
 }
 pointer operator->() const { return &(operator*()); }
 _Self& operator++() {
 --current;
 return *this;
 }
 _Self operator++(int) {
 _Self __tmp = *this;
 --current;
 return __tmp;
 }
 _Self& operator--() {
 ++current;
 return *this;
 }
 _Self operator--(int) {
 _Self __tmp = *this;
 ++current;
 return __tmp;
 }

#line 101
 _Self operator+(difference_type __n) const {
 return _Self(current - __n);
 }
 _Self& operator+=(difference_type __n) {
 current -= __n;
 return *this;
 }
 _Self operator-(difference_type __n) const {
 return _Self(current + __n);
 }
 _Self& operator-=(difference_type __n) {
 current += __n;
 return *this;
 }
 reference operator[](difference_type __n) const { return *(*this + __n); }
};

#line 118
template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return __x.base() == __y.base();
}

#line 124
template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return __y.base() < __x.base();
}

#line 132
template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return !(__x == __y);
}

#line 138
template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return __y < __x;
}

#line 144
template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return !(__y < __x);
}

#line 150
template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return !(__x < __y);
}

#line 158
template <class _Iterator>

#line 162
inline typename reverse_iterator<_Iterator>::difference_type

#line 164
operator-(const reverse_iterator<_Iterator>& __x,
 const reverse_iterator<_Iterator>& __y) {
 return __y.base() - __x.base();
}

#line 169
template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
 return x.operator+(n);
}

#line 177
template <class _Container>
class back_insert_iterator
 : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
 _Container* container;
public:
 typedef _Container container_type;
 typedef output_iterator_tag iterator_category;

#line 187
 explicit back_insert_iterator(_Container& __x) : container(&__x) {}
 back_insert_iterator<_Container>&
 operator=(const typename _Container::value_type& __val) {
 container->push_back(__val);
 return *this;
 }
 back_insert_iterator<_Container>& operator*() { return *this; }
 back_insert_iterator<_Container>& operator++() { return *this; }
 back_insert_iterator<_Container>& operator++(int) { return *this; }
};

#line 198
template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
 return back_insert_iterator<_Container>(__x);
}

#line 203
template <class _Container>
class front_insert_iterator
 : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
 _Container* container;
public:
 typedef _Container container_type;
 typedef output_iterator_tag iterator_category;
 explicit front_insert_iterator(_Container& __x) : container(&__x) {}
 front_insert_iterator<_Container>&
 operator=(const typename _Container::value_type& __val) {
 container->push_front(__val);
 return *this;
 }
 front_insert_iterator<_Container>& operator*() { return *this; }
 front_insert_iterator<_Container>& operator++() { return *this; }
 front_insert_iterator<_Container>& operator++(int) { return *this; }
};

#line 223
template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
 return front_insert_iterator<_Container>(__x);
}

#line 228
template <class _Container>
class insert_iterator
 : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
 _Container* container;
 typename _Container::iterator iter;
public:
 typedef _Container container_type;
 typedef output_iterator_tag iterator_category;
 insert_iterator(_Container& __x, typename _Container::iterator __i)
 : container(&__x), iter(__i) {}
 insert_iterator<_Container>&
 operator=(const typename _Container::value_type& __val) {
 iter = container->insert(iter, __val);
 ++iter;
 return *this;
 }
 insert_iterator<_Container>& operator*() { return *this; }
 insert_iterator<_Container>& operator++() { return *this; }
 insert_iterator<_Container>& operator++(int) { return *this; }
};

#line 251
template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
 typedef typename _Container::iterator __iter;
 return insert_iterator<_Container>(__x, __iter(__i));
}

#line 259
 }
#line 313 "../../stlport/stl/_algobase.c"

 namespace _STL {

#line 316
 template <class _BidirectionalIter1, class _BidirectionalIter2,
 class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
 _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
 const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
 _BinaryPredicate __comp)
{
 typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
 typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

#line 327
 _RevIter1 __rlast1(__first1);
 _RevIter2 __rlast2(__first2);
 _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
 _RevIter2(__last2), __rlast2,
 __comp);

#line 333
 if (__rresult == __rlast1)
 return __last1;
 else {
 _BidirectionalIter1 __result = __rresult.base();
 advance(__result, -distance(__first2, __last2));
 return __result;
 }
}

#line 343
template <class _ForwardIter1, class _ForwardIter2,
 class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2,
 _BinaryPredicate __comp)
{

#line 352
 return __find_end(__first1, __last1, __first2, __last2,

#line 354
 typename iterator_traits< _ForwardIter1 >::iterator_category() ,
 typename iterator_traits< _ForwardIter2 >::iterator_category() ,

#line 360
 __comp);
}

#line 363
template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val, _Compare __comp, _Distance*)
{
 _Distance __len = distance(__first, __last);
 _Distance __half;
 _ForwardIter __middle;

#line 371
 while (__len > 0) {
 __half = __len >> 1;
 __middle = __first;
 advance(__middle, __half);
 if (__comp(*__middle, __val)) {
 __first = __middle;
 ++__first;
 __len = __len - __half - 1;
 }
 else
 __len = __half;
 }
 return __first;
}

#line 386
 }
#line 576 "../../stlport/stl/_algobase.h"

#line 39 "../../stlport/stl/_uninitialized.h"


#line 45
 namespace _STL {

#line 51
 template <class _InputIter, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
 const __true_type&) {
 return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());
}

#line 58
template <class _InputIter, class _ForwardIter>
 inline
 _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
 const __false_type&)
{
 _ForwardIter __cur = __result;
 try {
 for ( ; __first != __last; ++__first, ++__cur)
 _Construct(&*__cur, *__first);
 return __cur;
 }
 catch(...) { _Destroy(__result, __cur); throw; } ;

#line 74
}

#line 76
template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result) {
 return __uninitialized_copy(__first, __last, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type() );
}

#line 82
inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result) {
 return (char*)__copy_trivial (__first, __last, __result);
}

#line 88
inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result) {
 return (wchar_t*)__copy_trivial (__first, __last, __result);
}

#line 97
template <class _InputIter, class _Size, class _ForwardIter>
 inline
 pair<_InputIter, _ForwardIter>
__uninitialized_copy_n(_InputIter __first, _Size __count,
 _ForwardIter __result,
 const input_iterator_tag &)
{
 _ForwardIter __cur = __result;
 try {
 for ( ; __count > 0 ; --__count, ++__first, ++__cur)
 _Construct(&*__cur, *__first);
 return pair<_InputIter, _ForwardIter>(__first, __cur);
 }
 catch(...) { _Destroy(__result, __cur); throw; } ;

#line 114
}

#line 135
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, const random_access_iterator_tag &) {
 _RandomAccessIter __last = __first + __count;
 return pair<_RandomAccessIter, _ForwardIter>( __last, __uninitialized_copy(__first, __last, __result,
 typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type() ));
}

#line 144
template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count,
 _ForwardIter __result) {
 return __uninitialized_copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category() );
}

#line 154
template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __x, const __true_type&) {
 _STL ::fill(__first, __last, __x);
}

#line 161
template <class _ForwardIter, class _Tp>
 inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __x, const __false_type&)
{
 _ForwardIter __cur = __first;
 try {
 for ( ; __cur != __last; ++__cur)
 _Construct(&*__cur, __x);
 }
 catch(...) { _Destroy(__first, __cur); throw; } ;
}

#line 174
template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
 __uninitialized_fill(__first, __last, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type() );
}

#line 181
template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
 const _Tp& __x, const __true_type&) {
 return _STL ::fill_n(__first, __n, __x);
}

#line 188
template <class _ForwardIter, class _Size, class _Tp>
 inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
 const _Tp& __x, const __false_type&)
{
 _ForwardIter __cur = __first;
 try {
 for ( ; __n > 0; --__n, ++__cur)
 _Construct(&*__cur, __x);
 return __cur;
 }
 catch(...) { _Destroy(__first, __cur); throw; } ;

#line 203
}

#line 205
template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
 return __uninitialized_fill_n(__first, __n, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type() );
}

#line 219
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _ForwardIter __result, __true_type)
{
 return __uninitialized_copy(__first2, __last2,
 __uninitialized_copy(__first1, __last1, __result, __true_type()), __true_type());
}

#line 229
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _ForwardIter __result, __false_type)
{
 _ForwardIter __mid = __uninitialized_copy(__first1, __last1, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type() );
 try {
 return __uninitialized_copy(__first2, __last2, __mid , typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type() );
 }
 catch(...) { _Destroy(__result, __mid); throw; } ;

#line 243
}

#line 248
template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
 _InputIter __first, _InputIter __last)
{
 typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
 __uninitialized_fill(__result, __mid, __x, _I_POD());
 try {
 return __uninitialized_copy(__first, __last, __mid, _I_POD());
 }
 catch(...) { _Destroy(__result, __mid); throw; } ;

#line 262
}

#line 267
template <class _InputIter, class _ForwardIter, class _Tp>
inline void
__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
 _ForwardIter __first2, _ForwardIter __last2,
 const _Tp& __x)
{
 typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
 _ForwardIter __mid2 = __uninitialized_copy(__first1, __last1, __first2, _I_POD());
 try {
 __uninitialized_fill(__mid2, __last2, __x, _I_POD());
 }
 catch(...) { _Destroy(__first2, __mid2); throw; } ;
}

#line 281
 }
#line 41 "../../stlport/stl/_tempbuf.h"


#line 43
 namespace _STL {

#line 45
 template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*);

#line 51
template <class _Tp>
inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
 return __get_temporary_buffer(__len, (_Tp*) 0);
}

#line 62
template <class _Tp>
inline pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
 return __get_temporary_buffer(__len, (_Tp*) 0);
}

#line 70
template <class _Tp>
inline void return_temporary_buffer(_Tp* __p) {

#line 73
 free((char*)__p);
}

#line 76
template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
 ptrdiff_t _M_original_len;
 ptrdiff_t _M_len;
 _Tp* _M_buffer;

#line 83
 void _M_allocate_buffer() {
 _M_original_len = _M_len;
 _M_buffer = 0;

#line 87
 if (_M_len > (ptrdiff_t)( 2147483647 / sizeof(_Tp)))
 _M_len = 2147483647 / sizeof(_Tp);

#line 90
 while (_M_len > 0) {
 _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
 if (_M_buffer)
 break;
 _M_len /= 2;
 }
 }

#line 98
 void _M_initialize_buffer(const _Tp&, const __true_type&) {}
 void _M_initialize_buffer(const _Tp& val, const __false_type&) {
 uninitialized_fill_n(_M_buffer, _M_len, val);
 }

#line 103
public:
 ptrdiff_t size() const { return _M_len; }
 ptrdiff_t requested_size() const { return _M_original_len; }
 _Tp* begin() { return _M_buffer; }
 _Tp* end() { return _M_buffer + _M_len; }

#line 109
 _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {

#line 114
 typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Trivial;

#line 116
 try {
 _M_len = distance(__first, __last);
 _M_allocate_buffer();
 if (_M_len > 0)
 _M_initialize_buffer(*__first, _Trivial());
 }
 catch(...) { free(_M_buffer); _M_buffer = 0; _M_len = 0; throw; } ;
 }

#line 125
 ~_Temporary_buffer() {
 _Destroy(_M_buffer, _M_buffer + _M_len);
 free(_M_buffer);
 }

#line 130
private:

#line 132
 _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
 void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};

#line 140
template <class _ForwardIterator,
 class _Tp

#line 143
 = typename iterator_traits<_ForwardIterator>::value_type

#line 145
 >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
 temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
 : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
 ~temporary_buffer() {}
};

#line 155
 }
#line 1 "../../stlport/stl/_tempbuf.c"


#line 33
 namespace _STL {

#line 35
 template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
 if (__len > ptrdiff_t( 2147483647 / sizeof(_Tp)))
 __len = 2147483647 / sizeof(_Tp);

#line 42
 while (__len > 0) {
 _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
 if (__tmp != 0)
 return pair<_Tp*, ptrdiff_t>(__tmp, __len);
 __len /= 2;
 }

#line 49
 return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
 }
#line 159 "../../stlport/stl/_tempbuf.h"

#line 37 "../../stlport/memory"

#line 1 "../../stlport/stl/_raw_storage_iter.h"


#line 37
 namespace _STL {

#line 39
 template <class _ForwardIterator, class _Tp>
class raw_storage_iterator

#line 44
{
protected:
 _ForwardIterator _M_iter;
public:
 typedef output_iterator_tag iterator_category;

#line 50
 typedef void value_type;
 typedef void difference_type;
 typedef void pointer;
 typedef void reference;

#line 55
 explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
 raw_storage_iterator<_ForwardIterator, _Tp>& operator*() { return *this; }
 raw_storage_iterator<_ForwardIterator, _Tp>& operator=(const _Tp& __element) {
 _Construct(&*_M_iter, __element);
 return *this;
 }
 raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {
 ++_M_iter;
 return *this;
 }
 raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
 }
};

#line 76
 }
#line 41 "../../stlport/memory"

#line 1 "../../stlport/stl/_auto_ptr.h"


#line 22
 namespace _STL {

#line 24
 class __ptr_base {
public:
 void* _M_p;
 void __set(const void* p) { _M_p = const_cast<void*>(p) ; }
 void __set(void* p) { _M_p = p; }
};

#line 31
template <class _Tp> class auto_ptr_ref {
public:
 __ptr_base& _M_r;
 _Tp* const _M_p;

#line 36
 auto_ptr_ref(__ptr_base& __r, _Tp* __p) : _M_r(__r), _M_p(__p) { }

#line 38
 _Tp* release() const { _M_r.__set((void*)0); return _M_p; }

#line 40
};

#line 42
template<class _Tp> class auto_ptr : public __ptr_base {
public:
 typedef _Tp element_type;
 typedef auto_ptr<_Tp> _Self;

#line 47
 _Tp* release() {
 _Tp* __px = this->get();
 this->_M_p = 0;
 return __px;
 }

#line 53
 void reset(_Tp* __px=0) {
 _Tp* __pt = this->get();
 if (__px != __pt)
 delete __pt;
 this->__set(__px);
 }

#line 60
 _Tp* get() const { return reinterpret_cast<_Tp*>(const_cast<void*>(_M_p)) ; }

#line 63
 _Tp* operator->() const {

#line 65
 return get();
 }

#line 68
 _Tp& operator*() const {

#line 70
 return *get();
 }

#line 73
 auto_ptr() { this->_M_p = 0; }

#line 75
 explicit auto_ptr(_Tp* __px) { this->__set(__px); }

#line 79
 template<class _Tp1> auto_ptr(auto_ptr<_Tp1>& __r) {
 _Tp* __conversionCheck = __r.release();
 this->__set(__conversionCheck);
 }

#line 84
 template<class _Tp1> auto_ptr<_Tp>& operator=(auto_ptr<_Tp1>& __r) {
 _Tp* __conversionCheck = __r.release();
 reset(__conversionCheck);
 return *this;
 }

#line 91
 auto_ptr(_Self& __r) { this->__set(__r.release()); }

#line 93
 _Self& operator=(_Self& __r) {
 reset(__r.release());
 return *this;
 }

#line 98
 ~auto_ptr() { delete this->get(); }

#line 100
 auto_ptr(auto_ptr_ref<_Tp> __r) {
 this->__set(__r.release());
 }

#line 104
 _Self& operator=(auto_ptr_ref<_Tp> __r) {
 reset(__r.release());
 return *this;
 }

#line 110
 template<class _Tp1> operator auto_ptr_ref<_Tp1>() {
 return auto_ptr_ref<_Tp1>(*this, this->get());
 }
 template<class _Tp1> operator auto_ptr<_Tp1>() {
 return auto_ptr<_Tp1>(release());
 }

#line 121
};
 }
#line 44 "../../stlport/memory"

#line 24 "../../stlport/stl/_string.h"

#line 1 "/opt/aCC/include/cctype"

#line 28 "../../stlport/stl/_string.h"

#line 1 "../../stlport/stl/_function.h"

#line 1 "../../stlport/stl/_function_base.h"


#line 37
 namespace _STL {

#line 39
 template <class _Arg, class _Result>
struct unary_function {
 typedef _Arg argument_type;
 typedef _Result result_type;
};

#line 45
template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
};

#line 52
template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

#line 58
template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

#line 64
template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

#line 70
template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};

#line 76
template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

#line 82
template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

#line 88
template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

#line 91
template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

#line 94
template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
 _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

#line 99
template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
 _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

#line 104
template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

#line 107
template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

#line 110
template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
 _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

#line 115
template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
 _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

#line 120
template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
 _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

#line 126
template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
 _Tp operator()(const _Tp& __x) const { return -__x; }
};

#line 132
template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

#line 138
template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
 bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

#line 144
template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
 bool operator()(const _Tp& __x) const { return !__x; }
};

#line 150
template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
 const typename _Pair::first_type& operator()(const _Pair& __x) const {
 return __x.first;
 }
};

#line 157
template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
 const typename _Pair::second_type& operator()(const _Pair& __x) const {
 return __x.second;
 }
};

#line 166
template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
 _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

#line 171
template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
 _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};

#line 188
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
 const _Tp& operator()(const _Tp& __x) const { return __x; }
};

#line 193
template <class _Result, class _Argument>
struct _Constant_unary_fun {
 typedef _Argument argument_type;
 typedef _Result result_type;
 result_type _M_val;

#line 199
 _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
 const result_type& operator()(const _Argument&) const { return _M_val; }
};

#line 203
template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
 _Result _M_val;

#line 210
 _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
 const result_type& operator()(const _Arg1&, const _Arg2&) const {
 return _M_val;
 }
};

#line 217
template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

#line 220
 }
#line 35 "../../stlport/stl/_function.h"


#line 37
 namespace _STL {

#line 41
 template <class _Tp> inline _Tp identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) { return _Tp(1); }

#line 84
template <class _Predicate>
class unary_negate :
 public unary_function<typename _Predicate::argument_type , bool> {
protected:
 _Predicate _M_pred;
public:
 explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
 bool operator()(const typename _Predicate::argument_type& __x) const {
 return !_M_pred(__x);
 }
};

#line 96
template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
 return unary_negate<_Predicate>(__pred);
}

#line 103
template <class _Predicate>
class binary_negate
 : public binary_function<typename _Predicate::first_argument_type ,
 typename _Predicate::second_argument_type ,
 bool> {
protected:
 _Predicate _M_pred;
public:
 explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
 bool operator()(const typename _Predicate::first_argument_type& __x,
 const typename _Predicate::second_argument_type& __y) const
 {
 return !_M_pred(__x, __y);
 }
};

#line 119
template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
 return binary_negate<_Predicate>(__pred);
}

#line 126
template <class _Operation>
class binder1st :
 public unary_function<typename _Operation::second_argument_type ,
 typename _Operation::result_type > {
protected:
 _Operation _M_op;
 typename _Operation::first_argument_type _M_value;
public:
 binder1st(const _Operation& __x,
 const typename _Operation::first_argument_type& __y)
 : _M_op(__x), _M_value(__y) {}
 typename _Operation::result_type
 operator()(const typename _Operation::second_argument_type& __x) const {
 return _M_op(_M_value, __x);
 }
};

#line 143
template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
 typedef typename _Operation::first_argument_type _Arg1_type;
 return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

#line 151
template <class _Operation>
class binder2nd
 : public unary_function<typename _Operation::first_argument_type ,
 typename _Operation::result_type > {
protected:
 _Operation _M_op;
 typename _Operation::second_argument_type value;
public:
 binder2nd(const _Operation& __x,
 const typename _Operation::second_argument_type& __y)
 : _M_op(__x), value(__y) {}
 typename _Operation::result_type
 operator()(const typename _Operation::first_argument_type& __x) const {
 return _M_op(__x, value);
 }
};

#line 168
template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
 typedef typename _Operation::second_argument_type _Arg2_type;
 return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}

#line 179
template <class _Operation1, class _Operation2>
class unary_compose :
 public unary_function<typename _Operation2::argument_type ,
 typename _Operation1::result_type > {
protected:
 _Operation1 _M_fn1;
 _Operation2 _M_fn2;
public:
 unary_compose(const _Operation1& __x, const _Operation2& __y)
 : _M_fn1(__x), _M_fn2(__y) {}
 typename _Operation1::result_type
 operator()(const typename _Operation2::argument_type& __x) const {
 return _M_fn1(_M_fn2(__x));
 }
};

#line 195
template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2)
{
 return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}

#line 202
template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose :
 public unary_function<typename _Operation2::argument_type ,
 typename _Operation1::result_type > {
protected:
 _Operation1 _M_fn1;
 _Operation2 _M_fn2;
 _Operation3 _M_fn3;
public:
 binary_compose(const _Operation1& __x, const _Operation2& __y,
 const _Operation3& __z)
 : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }
 typename _Operation1::result_type
 operator()(const typename _Operation2::argument_type& __x) const {
 return _M_fn1(_M_fn2(__x), _M_fn3(__x));
 }
};

#line 220
template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
 const _Operation3& __fn3)
{
 return binary_compose<_Operation1,_Operation2,_Operation3>
 (__fn1, __fn2, __fn3);
}

#line 231
template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
 _Result (*_M_ptr)(_Arg);
public:
 pointer_to_unary_function() {}
 explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
 _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};

#line 241
template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
{
 return pointer_to_unary_function<_Arg, _Result>(__x);
}

#line 247
template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
 public binary_function<_Arg1,_Arg2,_Result> {
protected:
 _Result (*_M_ptr)(_Arg1, _Arg2);
public:
 pointer_to_binary_function() {}
 explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
 : _M_ptr(__x) {}
 _Result operator()(_Arg1 __x, _Arg2 __y) const {
 return _M_ptr(__x, __y);
 }
};

#line 261
template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {
 return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);
}

#line 270
template <class _Tp> struct identity : public _Identity<_Tp> {};

#line 272
template <class _Pair> struct select1st : public _Select1st<_Pair> {};
template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};

#line 275
template <class _Arg1, class _Arg2>
struct project1st : public _Project1st<_Arg1, _Arg2> {};

#line 278
template <class _Arg1, class _Arg2>
struct project2nd : public _Project2nd<_Arg1, _Arg2> {};

#line 286
template <class _Result>
struct _Constant_void_fun {
 typedef _Result result_type;
 result_type _M_val;

#line 291
 _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
 const result_type& operator()() const { return _M_val; }
};

#line 296
template <class _Result>
struct constant_void_fun : public _Constant_void_fun<_Result> {
 constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}
};

#line 301
template <class _Result, class _Argument = _Result >
struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>
{
 constant_unary_fun(const _Result& __v)
 : _Constant_unary_fun<_Result, _Argument>(__v) {}
};

#line 308
template <class _Result, class _Arg1 = _Result , class _Arg2 = _Arg1 >
struct constant_binary_fun
 : public _Constant_binary_fun<_Result, _Arg1, _Arg2>
{
 constant_binary_fun(const _Result& __v)
 : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};

#line 316
template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val)
{
 return constant_void_fun<_Result>(__val);
}

#line 322
template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)
{
 return constant_unary_fun<_Result,_Result>(__val);
}

#line 328
template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val)
{
 return constant_binary_fun<_Result,_Result,_Result>(__val);
}

#line 337
class subtractive_rng : public unary_function< unsigned long , unsigned long > {
private:
 unsigned long _M_table[55];
 unsigned long _M_index1;
 unsigned long _M_index2;
public:
 unsigned long operator()( unsigned long __limit) {
 _M_index1 = (_M_index1 + 1) % 55;
 _M_index2 = (_M_index2 + 1) % 55;
 _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
 return _M_table[_M_index1] % __limit;
 }

#line 350
 void _M_initialize( unsigned long __seed)
 {
 unsigned long __k = 1;
 _M_table[54] = __seed;
 unsigned long __i;
 for (__i = 0; __i < 54; __i++) {
 unsigned long __ii = (21 * (__i + 1) % 55) - 1;
 _M_table[__ii] = __k;
 __k = __seed - __k;
 __seed = _M_table[__ii];
 }
 for (int __loop = 0; __loop < 4; __loop++) {
 for (__i = 0; __i < 55; __i++)
 _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
 }
 _M_index1 = 0;
 _M_index2 = 31;
 }

#line 369
 subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
 subtractive_rng() { _M_initialize(161803398ul); }
};

#line 396
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(void);
public:
 explicit mem_fun_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 406
template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(void) const;
public:
 explicit const_mem_fun_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 417
template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(void);
public:
 explicit mem_fun_ref_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 427
template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(void) const;
public:
 explicit const_mem_fun_ref_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 437
template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(_Arg);
public:
 explicit mem_fun1_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 447
template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(_Arg) const;
public:
 explicit const_mem_fun1_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(const _Tp* __p, _Arg __x) const
 { return (__p->*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 458
template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(_Arg);
public:
 explicit mem_fun1_ref_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 468
template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
 typedef _Ret (_Tp::*_fun_type)(_Arg) const;
public:
 explicit const_mem_fun1_ref_t(_fun_type __pf) : _M_f(__pf) {}
 _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 481
template <class _Tp>
class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {
 typedef void (_Tp::*_fun_type)(void);
public:
 explicit mem_fun_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(_Tp* __p) const { (__p->*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 491
template <class _Tp>
class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {
 typedef void (_Tp::*_fun_type)(void) const;
public:
 explicit const_mem_fun_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(const _Tp* __p) const { (__p->*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 501
template <class _Tp>
class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
 typedef void (_Tp::*_fun_type)(void);
public:
 explicit mem_fun_ref_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(_Tp& __r) const { (__r.*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 511
template <class _Tp>
class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
 typedef void (_Tp::*_fun_type)(void) const;
public:
 explicit const_mem_fun_ref_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(const _Tp& __r) const { (__r.*_M_f)(); }
private:
 _fun_type _M_f;
};

#line 521
template <class _Tp, class _Arg>
class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {
 typedef void (_Tp::*_fun_type)(_Arg);
public:
 explicit mem_fun1_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 531
template <class _Tp, class _Arg>
class const_mem_fun1_t<void, _Tp, _Arg>
 : public binary_function<const _Tp*,_Arg,void> {
 typedef void (_Tp::*_fun_type)(_Arg) const;
public:
 explicit const_mem_fun1_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 542
template <class _Tp, class _Arg>
class mem_fun1_ref_t<void, _Tp, _Arg>
 : public binary_function<_Tp,_Arg,void> {
 typedef void (_Tp::*_fun_type)(_Arg);
public:
 explicit mem_fun1_ref_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 553
template <class _Tp, class _Arg>
class const_mem_fun1_ref_t<void, _Tp, _Arg>
 : public binary_function<_Tp,_Arg,void> {
 typedef void (_Tp::*_fun_type)(_Arg) const;
public:
 explicit const_mem_fun1_ref_t (_fun_type __pf) : _M_f(__pf) {}
 void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
 _fun_type _M_f;
};

#line 573
template <class _Ret, class _Tp>
inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)()) { return mem_fun_t<_Ret,_Tp>(__f); }

#line 576
template <class _Ret, class _Tp>
inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const) { return const_mem_fun_t<_Ret,_Tp>(__f); }

#line 579
template <class _Ret, class _Tp>
inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)()) { return mem_fun_ref_t<_Ret,_Tp>(__f); }

#line 582
template <class _Ret, class _Tp>
inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const) { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }

#line 586
template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_t<_Ret,_Tp,_Arg>
mem_fun(_Ret (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

#line 590
template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_t<_Ret,_Tp,_Arg>
mem_fun(_Ret (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

#line 594
template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

#line 598
template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

#line 605
template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_t<_Ret,_Tp,_Arg>
mem_fun1(_Ret (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

#line 609
template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_t<_Ret,_Tp,_Arg>
mem_fun1(_Ret (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

#line 613
template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun1_ref(_Ret (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

#line 617
template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

#line 625
 }
#line 36 "../../stlport/stl/_string.h"

#line 1 "../../stlport/stl/_ctraits_fns.h"


#line 28
 namespace _STL {

#line 30
 template <class _Traits>
struct _Eq_traits
 : public binary_function<typename _Traits::char_type,
 typename _Traits::char_type,
 bool>
{
 bool operator()(const typename _Traits::char_type& __x,
 const typename _Traits::char_type& __y) const
 { return _Traits::eq(__x, __y); }
};

#line 41
template <class _Traits>
struct _Eq_char_bound
 : public unary_function<typename _Traits::char_type, bool>
{
 typename _Traits::char_type __val;
 _Eq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
 bool operator()(const typename _Traits::char_type& __x) const
 { return _Traits::eq(__x, __val); }
};

#line 51
template <class _Traits>
struct _Neq_char_bound
 : public unary_function<typename _Traits::char_type, bool>
{
 typename _Traits::char_type __val;
 _Neq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
 bool operator()(const typename _Traits::char_type& __x) const
 { return !_Traits::eq(__x, __val); }
};

#line 61
template <class _Traits>
struct _Eq_int_bound
 : public unary_function<typename _Traits::char_type, bool>
{
 typename _Traits::int_type __val;

#line 67
 _Eq_int_bound(typename _Traits::int_type __c) : __val(__c) {}
 bool operator()(const typename _Traits::char_type& __x) const
 { return _Traits::eq_int_type(_Traits::to_int_type(__x), __val); }
};

#line 85
 }
#line 39 "../../stlport/stl/_string.h"


#line 79
 namespace _STL {

#line 87
 template <class _Traits> struct _Not_within_traits
 : public unary_function<typename _Traits::char_type, bool> {
 typedef typename _Traits::char_type _CharT;
 const _CharT* _M_first;
 const _CharT* _M_last;

#line 93
 _Not_within_traits(const typename _Traits::char_type* __f,
 const typename _Traits::char_type* __l)
 : _M_first(__f), _M_last(__l) {}

#line 97
 bool operator()(const typename _Traits::char_type& __x) const {
 return find_if((_CharT*)_M_first, (_CharT*)_M_last,
 _Eq_char_bound<_Traits>(__x)) == (_CharT*)_M_last;
 }
};

#line 114
template <class _Tp, class _Alloc> class _String_base {
public:
 typedef typename _Alloc_traits<_Tp,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_Tp>::other _STLP_dummy_type2;
 typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
 _Tp* _M_start;
 _Tp* _M_finish;
 _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _M_end_of_storage;

#line 122
 void _M_allocate_block(size_t);
 void _M_deallocate_block()
 { _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start); }

#line 126
 size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }

#line 128
 _String_base(const allocator_type& __a)
 : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0) {}

#line 131
 _String_base(const allocator_type& __a, size_t __n)
 : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0)
 { _M_allocate_block(__n); }

#line 135
 ~_String_base() { _M_deallocate_block(); }

#line 137
 void _M_throw_length_error() const;
 void _M_throw_out_of_range() const;
};

#line 164
struct _String_reserve_t {};

#line 166
template <class _CharT, class _Traits, class _Alloc> class basic_string : protected _String_base<_CharT,_Alloc> {
private:
 typedef _String_base<_CharT,_Alloc> _Base;
 typedef basic_string<_CharT, _Traits, _Alloc> _Self;

#line 172
 typedef typename _Is_integer<_CharT>::_Integral _Char_Is_Integral;
public:
 typedef _CharT value_type;
 typedef _Traits traits_type;

#line 177
 typedef value_type* pointer;
 typedef const value_type* const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef random_access_iterator_tag _Iterator_category;

#line 185
 typedef const value_type* const_iterator;
 typedef value_type* iterator;

#line 188
 typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator ;

#line 193
 static const size_t npos = ~(size_t)0;

#line 196
 typedef _String_reserve_t _Reserve_t;

#line 209
public:
 typedef typename _String_base<_CharT,_Alloc>::allocator_type allocator_type;

#line 212
 allocator_type get_allocator() const {
 return (const allocator_type&)this->_M_end_of_storage ;
 }

#line 216
 basic_string();

#line 218
 explicit basic_string(const allocator_type& __a)
 : _String_base<_CharT,_Alloc>(__a, 8) {
 _M_terminate_string();
 }

#line 223
 basic_string(_Reserve_t, size_t __n,
 const allocator_type& __a = allocator_type())
 : _String_base<_CharT,_Alloc>(__a, __n + 1) {
 _M_terminate_string();
 }

#line 229
 basic_string(const basic_string<_CharT, _Traits, _Alloc>&);

#line 231
 basic_string(const _Self& __s, size_type __pos, size_type __n = npos,
 const allocator_type& __a = allocator_type())
 : _String_base<_CharT,_Alloc>(__a) {
 if (__pos > __s.size())
 this->_M_throw_out_of_range();
 else
 _M_range_initialize(__s._M_start + __pos,
 __s._M_start + __pos + (min) (__n, __s.size() - __pos));
 }

#line 241
 basic_string(const _CharT* __s, size_type __n,
 const allocator_type& __a = allocator_type())
 : _String_base<_CharT,_Alloc>(__a)
 {
 __s=__s;
 _M_range_initialize(__s, __s + __n);
 }

#line 249
 basic_string(const _CharT* __s,
 const allocator_type& __a = allocator_type());

#line 252
 basic_string(size_type __n, _CharT __c,
 const allocator_type& __a = allocator_type())
 : _String_base<_CharT,_Alloc>(__a, __n + 1)
 {
 this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __c);
 _M_terminate_string();
 }

#line 271
 template <class _InputIterator> basic_string(_InputIterator __f, _InputIterator __l,
 const allocator_type & __a = allocator_type() )
 : _String_base<_CharT,_Alloc>(__a)
 {
 typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
 _M_initialize_dispatch(__f, __l, _Integral());
 }

#line 302
 ~basic_string() { _Destroy(this->_M_start, this->_M_finish + 1); }

#line 304
 _Self& operator=(const _Self& __s) {
 if (&__s != this)
 assign(__s._M_start, __s._M_finish);
 return *this;
 }

#line 310
 _Self& operator=(const _CharT* __s) {
 __s=__s;
 return assign(__s, __s + traits_type::length(__s));
 }

#line 315
 _Self& operator=(_CharT __c)
 { return assign( static_cast<size_type>(1) , __c); }

#line 318
 static _CharT _M_null() {
 return _CharT() ;
 }

#line 322
private:

#line 325
 void _M_construct_null_aux(_CharT* __p, const __false_type&) {
 _Construct(__p);
 }
 void _M_construct_null_aux(_CharT* __p, const __true_type&) {
 *__p = 0;
 }

#line 332
 void _M_construct_null(_CharT* __p) {
 _M_construct_null_aux(__p, _Char_Is_Integral());
 }

#line 336
private:

#line 340
 void _M_terminate_string_aux(const __false_type&) {
 try {
 _M_construct_null(this->_M_finish);
 }
 catch(...) { _Destroy(this->_M_start, this->_M_finish); throw; } ;
 }

#line 347
 void _M_terminate_string_aux(const __true_type&) {
 *(this->_M_finish)=0;
 }

#line 351
 void _M_terminate_string() {
 _M_terminate_string_aux(_Char_Is_Integral());
 }

#line 357
 template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l,
 const input_iterator_tag &) {
 this->_M_allocate_block(8);
 _M_construct_null(this->_M_finish);
 try {
 append(__f, __l);
 }
 catch(...) { _Destroy(this->_M_start, this->_M_finish + 1); throw; } ;
 }

#line 367
 template <class _ForwardIter> void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,
 const forward_iterator_tag &) {
 difference_type __n = distance(__f, __l);
 this->_M_allocate_block(__n + 1);
 this->_M_finish = uninitialized_copy(__f, __l, this->_M_start);
 _M_terminate_string();
 }

#line 375
 template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l) {
 _M_range_initialize(__f, __l, typename iterator_traits< _InputIter >::iterator_category() );
 }

#line 379
 template <class _Integer> void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
 this->_M_allocate_block(__n + 1);
 this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __x);
 _M_terminate_string();
 }

#line 385
 template <class _InputIter> void _M_initialize_dispatch(_InputIter __f, _InputIter __l, const __false_type&) {
 _M_range_initialize(__f, __l);
 }

#line 400
public:
 iterator begin() { return this->_M_start; }
 iterator end() { return this->_M_finish; }
 const_iterator begin() const { return this->_M_start; }
 const_iterator end() const { return this->_M_finish; }

#line 406
 reverse_iterator rbegin()
 { return reverse_iterator(this->_M_finish); }
 reverse_iterator rend()
 { return reverse_iterator(this->_M_start); }
 const_reverse_iterator rbegin() const
 { return const_reverse_iterator(this->_M_finish); }
 const_reverse_iterator rend() const
 { return const_reverse_iterator(this->_M_start); }

#line 415
public:
 size_type size() const { return this->_M_finish - this->_M_start; }
 size_type length() const { return size(); }

#line 419
 size_t max_size() const { return _Base::max_size(); }

#line 422
 void resize(size_type __n, _CharT __c) {
 if (__n <= size())
 erase(begin() + __n, end());
 else
 append(__n - size(), __c);
 }
 void resize(size_type __n) { resize(__n, _M_null()); }

#line 430
 void reserve(size_type = 0);

#line 432
 size_type capacity() const { return (this->_M_end_of_storage._M_data - this->_M_start) - 1; }

#line 434
 void clear() {
 if (!empty()) {
 _Traits::assign(*(this->_M_start), _M_null());
 _Destroy(this->_M_start+1, this->_M_finish+1);
 this->_M_finish = this->_M_start;
 }
 }

#line 442
 bool empty() const { return this->_M_start == this->_M_finish; }

#line 444
public:

#line 446
 const_reference operator[](size_type __n) const
 { return *(this->_M_start + __n); }
 reference operator[](size_type __n)
 { return *(this->_M_start + __n); }

#line 451
 const_reference at(size_type __n) const {
 if (__n >= size())
 this->_M_throw_out_of_range();
 return *(this->_M_start + __n);
 }

#line 457
 reference at(size_type __n) {
 if (__n >= size())
 this->_M_throw_out_of_range();
 return *(this->_M_start + __n);
 }

#line 463
public:

#line 465
 _Self& operator+=(const _Self& __s) { return append(__s); }
 _Self& operator+=(const _CharT* __s) { __s=__s; return append(__s); }
 _Self& operator+=(_CharT __c) { push_back(__c); return *this; }

#line 469
 _Self& append(const _Self& __s)
 { return append(__s._M_start, __s._M_finish); }

#line 472
 _Self& append(const _Self& __s,
 size_type __pos, size_type __n)
 {
 if (__pos > __s.size())
 this->_M_throw_out_of_range();
 return append(__s._M_start + __pos,
 __s._M_start + __pos + (min) (__n, __s.size() - __pos));
 }

#line 481
 _Self& append(const _CharT* __s, size_type __n)
 { __s=__s; return append(__s, __s+__n); }
 _Self& append(const _CharT* __s)
 { __s=__s; return append(__s, __s + traits_type::length(__s)); }
 _Self& append(size_type __n, _CharT __c);

#line 491
 template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last) {
 typedef typename _Is_integer<_InputIter>::_Integral _Integral;
 return _M_append_dispatch(__first, __last, _Integral());
 }

#line 502
 void push_back(_CharT __c) {
 if (this->_M_finish + 1 == this->_M_end_of_storage._M_data)
 reserve(size() + (max)(size(), static_cast<size_type>(1) ));
 _M_construct_null(this->_M_finish + 1);
 _Traits::assign(*(this->_M_finish), __c);
 ++this->_M_finish;
 }

#line 510
 void pop_back() {
 _Traits::assign(*(this->_M_finish - 1), _M_null());
 _Destroy(this->_M_finish);
 --this->_M_finish;
 }

#line 516
private:

#line 520
 template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last, const input_iterator_tag &)
 {
 for ( ; __first != __last ; ++__first)
 push_back(*__first);
 return *this;
 }

#line 527
 template <class _ForwardIter> _Self& append(_ForwardIter __first, _ForwardIter __last,
 const forward_iterator_tag &) {
 if (__first != __last) {
 const size_type __old_size = size();
 difference_type __n = distance(__first, __last);
 if ( static_cast<size_type>(__n) > max_size() || __old_size > max_size() - static_cast<size_type>(__n) )
 this->_M_throw_length_error();
 if (__old_size + __n > capacity()) {
 const size_type __len = __old_size +
 (max)(__old_size, static_cast<size_type>(__n) ) + 1;
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = __new_start;
 try {
 __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
 __new_finish = uninitialized_copy(__first, __last, __new_finish);
 _M_construct_null(__new_finish);
 }
 catch(...) { (_Destroy(__new_start,__new_finish), this->_M_end_of_storage.deallocate(__new_start,__len)); throw; } ;

 _Destroy(this->_M_start, this->_M_finish + 1);
 this->_M_deallocate_block();
 this->_M_start = __new_start;
 this->_M_finish = __new_finish;
 this->_M_end_of_storage._M_data = __new_start + __len;
 }
 else {
 _ForwardIter __f1 = __first;
 ++__f1;
 uninitialized_copy(__f1, __last, this->_M_finish + 1);
 try {
 _M_construct_null(this->_M_finish + __n);
 }
 catch(...) { _Destroy(this->_M_finish + 1, this->_M_finish + __n); throw; } ;
 _Traits::assign(*end(), *__first);
 this->_M_finish += __n;
 }
 }
 return *this;
 }

#line 567
 template <class _Integer> _Self& _M_append_dispatch(_Integer __n, _Integer __x, const __true_type&) {
 return append((size_type) __n, (_CharT) __x);
 }

#line 571
 template <class _InputIter> _Self& _M_append_dispatch(_InputIter __f, _InputIter __l,
 const __false_type&) {
 return append(__f, __l, typename iterator_traits< _InputIter >::iterator_category() );
 }

#line 578
public:

#line 580
 _Self& assign(const _Self& __s)
 { return assign(__s._M_start, __s._M_finish); }

#line 583
 _Self& assign(const _Self& __s,
 size_type __pos, size_type __n) {
 if (__pos > __s.size())
 this->_M_throw_out_of_range();
 return assign(__s._M_start + __pos,
 __s._M_start + __pos + (min) (__n, __s.size() - __pos));
 }

#line 591
 _Self& assign(const _CharT* __s, size_type __n)
 { __s=__s; return assign(__s, __s + __n); }

#line 594
 _Self& assign(const _CharT* __s)
 { __s=__s; return assign(__s, __s + _Traits::length(__s)); }

#line 597
 _Self& assign(size_type __n, _CharT __c);

#line 601
private:

#line 603
 template <class _Integer>
 _Self& _M_assign_dispatch(_Integer __n, _Integer __x, const __true_type&) {
 return assign((size_type) __n, (_CharT) __x);
 }

#line 608
 template <class _InputIter>
 _Self& _M_assign_dispatch(_InputIter __f, _InputIter __l,
 const __false_type&) {
 pointer __cur = this->_M_start;
 while (__f != __l && __cur != this->_M_finish) {
 _Traits::assign(*__cur, *__f);
 ++__f;
 ++__cur;
 }
 if (__f == __l)
 erase(__cur, end());
 else
 append(__f, __l);
 return *this;
 }

#line 624
public:

#line 627
 template <class _InputIter> _Self& assign(_InputIter __first, _InputIter __last) {
 typedef typename _Is_integer<_InputIter>::_Integral _Integral;
 return _M_assign_dispatch(__first, __last, _Integral());
 }

#line 634
 _Self& assign(const _CharT* __f, const _CharT* __l)
 {
 ptrdiff_t __n = __l - __f;
 if ( static_cast<size_type>(__n) <= size()) {
 _Traits::copy(this->_M_start, __f, __n);
 erase(begin() + __n, end());
 }
 else {
 _Traits::copy(this->_M_start, __f, size());
 append(__f + size(), __l);
 }
 return *this;
 }

#line 648
public:

#line 650
 _Self& insert(size_type __pos, const _Self& __s) {
 if (__pos > size())
 this->_M_throw_out_of_range();
 if (size() > max_size() - __s.size())
 this->_M_throw_length_error();
 insert(begin() + __pos, __s._M_start, __s._M_finish);
 return *this;
 }

#line 659
 _Self& insert(size_type __pos, const _Self& __s,
 size_type __beg, size_type __n) {
 if (__pos > size() || __beg > __s.size())
 this->_M_throw_out_of_range();
 size_type __len = (min) (__n, __s.size() - __beg);
 if (size() > max_size() - __len)
 this->_M_throw_length_error();
 insert(begin() + __pos,
 __s._M_start + __beg, __s._M_start + __beg + __len);
 return *this;
 }

#line 671
 _Self& insert(size_type __pos, const _CharT* __s, size_type __n) {
 __s=__s;
 if (__pos > size())
 this->_M_throw_out_of_range();
 if (size() > max_size() - __n)
 this->_M_throw_length_error();
 insert(begin() + __pos, __s, __s + __n);
 return *this;
 }

#line 681
 _Self& insert(size_type __pos, const _CharT* __s) {
 __s=__s;
 if (__pos > size())
 this->_M_throw_out_of_range();
 size_type __len = _Traits::length(__s);
 if (size() > max_size() - __len)
 this->_M_throw_length_error();
 insert(this->_M_start + __pos, __s, __s + __len);
 return *this;
 }

#line 692
 _Self& insert(size_type __pos, size_type __n, _CharT __c) {
 if (__pos > size())
 this->_M_throw_out_of_range();
 if (size() > max_size() - __n)
 this->_M_throw_length_error();
 insert(begin() + __pos, __n, __c);
 return *this;
 }

#line 701
 iterator insert(iterator __p, _CharT __c) {
 __p=__p;
 if (__p == end()) {
 push_back(__c);
 return this->_M_finish - 1;
 }
 else
 return _M_insert_aux(__p, __c);
 }

#line 711
 void insert(iterator __p, size_t __n, _CharT __c);

#line 717
 template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last) {
 typedef typename _Is_integer<_InputIter>::_Integral _Integral;
 _M_insert_dispatch(__p, __first, __last, _Integral());
 }

#line 728
private:

#line 732
 template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last,
 const input_iterator_tag &)
 {
 for ( ; __first != __last; ++__first) {
 __p = insert(__p, *__first);
 ++__p;
 }
 }

#line 741
 template <class _ForwardIter> void insert(iterator __position, _ForwardIter __first, _ForwardIter __last,
 const forward_iterator_tag &) {
 if (__first != __last) {
 difference_type __n = distance(__first, __last);
 if (this->_M_end_of_storage._M_data - this->_M_finish >= __n + 1) {
 const difference_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after >= __n) {
 uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
 this->_M_finish + 1);
 this->_M_finish += __n;
 _Traits::move(__position + __n,
 __position, (__elems_after - __n) + 1);
 _M_copy(__first, __last, __position);
 }
 else {
 _ForwardIter __mid = __first;
 advance(__mid, __elems_after + 1);
 uninitialized_copy(__mid, __last, this->_M_finish + 1);
 this->_M_finish += __n - __elems_after;
 try {
 uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
 this->_M_finish += __elems_after;
 }
 catch(...) { (_Destroy(__old_finish + 1, this->_M_finish), this->_M_finish = __old_finish); throw; } ;

 _M_copy(__first, __mid, __position);
 }
 }
 else {
 const size_type __old_size = size();
 const size_type __len
 = __old_size + (max)(__old_size, static_cast<size_type>(__n) ) + 1;
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = __new_start;
 try {
 __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
 __new_finish = uninitialized_copy(__first, __last, __new_finish);
 __new_finish
 = uninitialized_copy(__position, this->_M_finish, __new_finish);
 _M_construct_null(__new_finish);
 }
 catch(...) { (_Destroy(__new_start,__new_finish), this->_M_end_of_storage.deallocate(__new_start,__len)); throw; } ;

 _Destroy(this->_M_start, this->_M_finish + 1);
 this->_M_deallocate_block();
 this->_M_start = __new_start;
 this->_M_finish = __new_finish;
 this->_M_end_of_storage._M_data = __new_start + __len;
 }
 }
 }

#line 794
 template <class _Integer> void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
 const __true_type&) {
 insert(__p, (size_type) __n, (_CharT) __x);
 }

#line 799
 template <class _InputIter> void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
 const __false_type&) {
 insert(__p, __first, __last, typename iterator_traits< _InputIter >::iterator_category() );
 }

#line 804
 template <class _InputIterator> void
 _M_copy(_InputIterator __first, _InputIterator __last, pointer __result) {
 for ( ; __first != __last; ++__first, ++__result)
 _Traits::assign(*__result, *__first);
 }

#line 812
 pointer _M_insert_aux(pointer, _CharT);

#line 814
 void
 _M_copy(const _CharT* __first, const _CharT* __last, _CharT* __result) {
 _Traits::copy(__result, __first, __last - __first);
 }

#line 819
public:

#line 821
 _Self& erase(size_type __pos = 0, size_type __n = npos) {
 if (__pos > size())
 this->_M_throw_out_of_range();
 erase(begin() + __pos, begin() + __pos + (min) (__n, size() - __pos));
 return *this;
 }

#line 828
 iterator erase(iterator __position) {

#line 830
 _Traits::move(__position, __position + 1, this->_M_finish - __position);
 _Destroy(this->_M_finish);
 --this->_M_finish;
 return __position;
 }

#line 836
 iterator erase(iterator __first, iterator __last) {
 if (__first != __last) {

#line 839
 traits_type::move(__first, __last, (this->_M_finish - __last) + 1);
 pointer __new_finish = this->_M_finish - (__last - __first);
 _Destroy(__new_finish + 1, this->_M_finish + 1);
 this->_M_finish = __new_finish;
 }
 return __first;
 }

#line 847
public:

#line 849
 _Self& replace(size_type __pos, size_type __n,
 const _Self& __s) {
 if (__pos > size())
 this->_M_throw_out_of_range();
 const size_type __len = (min) (__n, size() - __pos);
 if (size() - __len >= max_size() - __s.size())
 this->_M_throw_length_error();
 return replace(begin() + __pos, begin() + __pos + __len,
 __s._M_start, __s._M_finish);
 }

#line 860
 _Self& replace(size_type __pos1, size_type __n1,
 const _Self& __s,
 size_type __pos2, size_type __n2) {
 if (__pos1 > size() || __pos2 > __s.size())
 this->_M_throw_out_of_range();
 const size_type __len1 = (min) (__n1, size() - __pos1);
 const size_type __len2 = (min) (__n2, __s.size() - __pos2);
 if (size() - __len1 >= max_size() - __len2)
 this->_M_throw_length_error();
 return replace(begin() + __pos1, begin() + __pos1 + __len1,
 __s._M_start + __pos2, __s._M_start + __pos2 + __len2);
 }

#line 873
 _Self& replace(size_type __pos, size_type __n1,
 const _CharT* __s, size_type __n2) {
 __s=__s;
 if (__pos > size())
 this->_M_throw_out_of_range();
 const size_type __len = (min) (__n1, size() - __pos);
 if (__n2 > max_size() || size() - __len >= max_size() - __n2)
 this->_M_throw_length_error();
 return replace(begin() + __pos, begin() + __pos + __len,
 __s, __s + __n2);
 }

#line 885
 _Self& replace(size_type __pos, size_type __n1,
 const _CharT* __s) {
 __s=__s;
 if (__pos > size())
 this->_M_throw_out_of_range();
 const size_type __len = (min) (__n1, size() - __pos);
 const size_type __n2 = _Traits::length(__s);
 if (__n2 > max_size() || size() - __len >= max_size() - __n2)
 this->_M_throw_length_error();
 return replace(begin() + __pos, begin() + __pos + __len,
 __s, __s + _Traits::length(__s));
 }

#line 898
 _Self& replace(size_type __pos, size_type __n1,
 size_type __n2, _CharT __c) {
 if (__pos > size())
 this->_M_throw_out_of_range();
 const size_type __len = (min) (__n1, size() - __pos);
 if (__n2 > max_size() || size() - __len >= max_size() - __n2)
 this->_M_throw_length_error();
 return replace(begin() + __pos, begin() + __pos + __len, __n2, __c);
 }

#line 908
 _Self& replace(iterator __first, iterator __last,
 const _Self& __s)
 { return replace(__first, __last, __s._M_start, __s._M_finish); }

#line 912
 _Self& replace(iterator __first, iterator __last,
 const _CharT* __s, size_type __n)
 { __s=__s; return replace(__first, __last, __s, __s + __n); }

#line 916
 _Self& replace(iterator __first, iterator __last,
 const _CharT* __s) {
 __s=__s;
 return replace(__first, __last, __s, __s + _Traits::length(__s));
 }

#line 922
 _Self& replace(iterator __first, iterator __last,
 size_type __n, _CharT __c);

#line 928
 template <class _InputIter> _Self& replace(iterator __first, iterator __last,
 _InputIter __f, _InputIter __l) {
 typedef typename _Is_integer<_InputIter>::_Integral _Integral;
 return _M_replace_dispatch(__first, __last, __f, __l, _Integral());
 }

#line 938
private:

#line 942
 template <class _Integer> _Self& _M_replace_dispatch(iterator __first, iterator __last,
 _Integer __n, _Integer __x,
 const __true_type&) {
 return replace(__first, __last, (size_type) __n, (_CharT) __x);
 }

#line 948
 template <class _InputIter> _Self& _M_replace_dispatch(iterator __first, iterator __last,
 _InputIter __f, _InputIter __l,
 const __false_type&) {
 return replace(__first, __last, __f, __l, typename iterator_traits< _InputIter >::iterator_category() );
 }

#line 954
 template <class _InputIter> _Self& replace(iterator __first, iterator __last,
 _InputIter __f, _InputIter __l, const input_iterator_tag &) {
 for ( ; __first != __last && __f != __l; ++__first, ++__f)
 _Traits::assign(*__first, *__f);

#line 959
 if (__f == __l)
 erase(__first, __last);
 else
 insert(__last, __f, __l);
 return *this;
 }

#line 966
 template <class _ForwardIter> _Self& replace(iterator __first, iterator __last,
 _ForwardIter __f, _ForwardIter __l,
 const forward_iterator_tag &) {
 difference_type __n = distance(__f, __l);
 const difference_type __len = __last - __first;
 if (__len >= __n) {
 _M_copy(__f, __l, __first);
 erase(__first + __n, __last);
 }
 else {
 _ForwardIter __m = __f;
 advance(__m, __len);
 _M_copy(__f, __m, __first);
 insert(__last, __m, __l);
 }
 return *this;
 }

#line 986
public:

#line 988
 size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
 __s=__s;
 if (__pos > size())
 this->_M_throw_out_of_range();
 const size_type __len = (min) (__n, size() - __pos);
 _Traits::copy(__s, this->_M_start + __pos, __len);
 return __len;
 }

#line 997
 void swap(_Self& __s) {
 _STL ::swap(this->_M_start, __s._M_start);
 _STL ::swap(this->_M_finish, __s._M_finish);
 _STL ::swap(this->_M_end_of_storage, __s._M_end_of_storage);
 }

#line 1003
public:

#line 1005
 const _CharT* c_str() const { return this->_M_start; }
 const _CharT* data() const { return this->_M_start; }

#line 1008
public:

#line 1010
 size_type find(const _Self& __s, size_type __pos = 0) const
 { return find(__s._M_start, __pos, __s.size()); }

#line 1013
 size_type find(const _CharT* __s, size_type __pos = 0) const
 { __s=__s; return find(__s, __pos, _Traits::length(__s)); }

#line 1016
 size_type find(const _CharT* __s, size_type __pos, size_type __n) const;
 size_type find(_CharT __c, size_type __pos = 0) const;

#line 1019
public:

#line 1021
 size_type rfind(const _Self& __s, size_type __pos = npos) const
 { return rfind(__s._M_start, __pos, __s.size()); }

#line 1024
 size_type rfind(const _CharT* __s, size_type __pos = npos) const
 { __s=__s; return rfind(__s, __pos, _Traits::length(__s)); }

#line 1027
 size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
 size_type rfind(_CharT __c, size_type __pos = npos) const;

#line 1030
public:

#line 1032
 size_type find_first_of(const _Self& __s, size_type __pos = 0) const
 { return find_first_of(__s._M_start, __pos, __s.size()); }

#line 1035
 size_type find_first_of(const _CharT* __s, size_type __pos = 0) const
 { __s=__s; return find_first_of(__s, __pos, _Traits::length(__s)); }

#line 1038
 size_type find_first_of(const _CharT* __s, size_type __pos,
 size_type __n) const;

#line 1041
 size_type find_first_of(_CharT __c, size_type __pos = 0) const
 { return find(__c, __pos); }

#line 1044
public:

#line 1046
 size_type find_last_of(const _Self& __s,
 size_type __pos = npos) const
 { return find_last_of(__s._M_start, __pos, __s.size()); }

#line 1050
 size_type find_last_of(const _CharT* __s, size_type __pos = npos) const
 { __s=__s; return find_last_of(__s, __pos, _Traits::length(__s)); }

#line 1053
 size_type find_last_of(const _CharT* __s, size_type __pos,
 size_type __n) const;

#line 1056
 size_type find_last_of(_CharT __c, size_type __pos = npos) const {
 return rfind(__c, __pos);
 }

#line 1060
public:

#line 1062
 size_type find_first_not_of(const _Self& __s,
 size_type __pos = 0) const
 { return find_first_not_of(__s._M_start, __pos, __s.size()); }

#line 1066
 size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const
 { __s=__s; return find_first_not_of(__s, __pos, _Traits::length(__s)); }

#line 1069
 size_type find_first_not_of(const _CharT* __s, size_type __pos,
 size_type __n) const;

#line 1072
 size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;

#line 1074
public:

#line 1076
 size_type find_last_not_of(const _Self& __s,
 size_type __pos = npos) const
 { return find_last_not_of(__s._M_start, __pos, __s.size()); }

#line 1080
 size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
 { __s=__s; return find_last_not_of(__s, __pos, _Traits::length(__s)); }

#line 1083
 size_type find_last_not_of(const _CharT* __s, size_type __pos,
 size_type __n) const;

#line 1086
 size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;

#line 1088
public:

#line 1090
 _Self substr(size_type __pos = 0, size_type __n = npos) const {
 if (__pos > size())
 this->_M_throw_out_of_range();
 return _Self(this->_M_start + __pos,
 this->_M_start + __pos + (min) (__n, size() - __pos));
 }

#line 1097
public:

#line 1099
 int compare(const _Self& __s) const
 { return _M_compare(this->_M_start, this->_M_finish, __s._M_start, __s._M_finish); }

#line 1102
 int compare(size_type __pos1, size_type __n1,
 const _Self& __s) const {
 if (__pos1 > size())
 this->_M_throw_out_of_range();
 return _M_compare(this->_M_start + __pos1,
 this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
 __s._M_start, __s._M_finish);
 }

#line 1111
 int compare(size_type __pos1, size_type __n1,
 const _Self& __s,
 size_type __pos2, size_type __n2) const {
 if (__pos1 > size() || __pos2 > __s.size())
 this->_M_throw_out_of_range();
 return _M_compare(this->_M_start + __pos1,
 this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
 __s._M_start + __pos2,
 __s._M_start + __pos2 + (min) (__n2, __s.size() - __pos2));
 }

#line 1122
 int compare(const _CharT* __s) const {
 __s=__s;
 return _M_compare(this->_M_start, this->_M_finish, __s, __s + _Traits::length(__s));
 }

#line 1127
 int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
 __s=__s;
 if (__pos1 > size())
 this->_M_throw_out_of_range();
 return _M_compare(this->_M_start + __pos1,
 this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
 __s, __s + _Traits::length(__s));
 }

#line 1136
 int compare(size_type __pos1, size_type __n1, const _CharT* __s,
 size_type __n2) const {
 __s=__s;
 if (__pos1 > size())
 this->_M_throw_out_of_range();
 return _M_compare(this->_M_start + __pos1,
 this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
 __s, __s + __n2);
 }

#line 1146
public:

#line 1148
 static int _M_compare(const _CharT* __f1, const _CharT* __l1,
 const _CharT* __f2, const _CharT* __l2) {
 const ptrdiff_t __n1 = __l1 - __f1;
 const ptrdiff_t __n2 = __l2 - __f2;
 const int cmp = _Traits::compare(__f1, __f2, (min) (__n1, __n2));
 return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
 }
};

#line 1168
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y)
{
 typedef basic_string<_CharT,_Traits,_Alloc> _Str;
 typedef typename _Str::_Reserve_t _Reserve_t;

#line 1178
 _Str __result(_Reserve_t(), __s.size() + __y.size());

#line 1180
 __result.append(__s);
 __result.append(__y);
 return __result;
}

#line 1189
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 typedef basic_string<_CharT,_Traits,_Alloc> _Str;
 typedef typename _Str::_Reserve_t _Reserve_t;
 const size_t __n = _Traits::length(__s);

#line 1199
 _Str __result(_Reserve_t(), __n + __y.size());

#line 1201
 __result.append(__s, __s + __n);
 __result.append(__y);
 return __result;
}

#line 1206
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(_CharT __c,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 typedef basic_string<_CharT,_Traits,_Alloc> _Str;
 typedef typename _Str::_Reserve_t _Reserve_t;

#line 1214
 _Str __result(_Reserve_t(), 1 + __y.size());

#line 1216
 __result.push_back(__c);
 __result.append(__y);
 return __result;
}

#line 1221
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 typedef basic_string<_CharT,_Traits,_Alloc> _Str;
 typedef typename _Str::_Reserve_t _Reserve_t;
 const size_t __n = _Traits::length(__s);

#line 1231
 _Str __result(_Reserve_t(), __x.size() + __n, __x.get_allocator());

#line 1233
 __result.append(__x);
 __result.append(__s, __s + __n);
 return __result;
}

#line 1238
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT __c) {
 typedef basic_string<_CharT,_Traits,_Alloc> _Str;
 typedef typename _Str::_Reserve_t _Reserve_t;

#line 1246
 _Str __result(_Reserve_t(), __x.size() + 1, __x.get_allocator());

#line 1248
 __result.append(__x);
 __result.push_back(__c);
 return __result;
}

#line 1257
template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 return __x.size() == __y.size() && _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
}

#line 1263
template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 size_t __n = _Traits::length(__s);
 return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
}

#line 1271
template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 size_t __n = _Traits::length(__s);
 return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
}

#line 1281
template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
 __y.begin(), __y.end()) < 0;
}

#line 1288
template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 size_t __n = _Traits::length(__s);
 return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__s, __s + __n, __y.begin(), __y.end()) < 0;
}

#line 1296
template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 size_t __n = _Traits::length(__s);
 return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(), __s, __s + __n) < 0;
}

#line 1306
template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 return !(__x == __y);
}

#line 1312
template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 return __y < __x;
}

#line 1318
template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 return !(__y < __x);
}

#line 1324
template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 return !(__x < __y);
}

#line 1332
template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 return !(__s == __y);
}

#line 1339
template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 return !(__x == __s);
}

#line 1346
template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 return __y < __s;
}

#line 1353
template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 return __s < __x;
}

#line 1360
template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 return !(__y < __s);
}

#line 1367
template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 return !(__s < __x);
}

#line 1374
template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const _CharT* __s,
 const basic_string<_CharT,_Traits,_Alloc>& __y) {
 __s=__s;
 return !(__s < __y);
}

#line 1381
template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
 const _CharT* __s) {
 __s=__s;
 return !(__x < __s);
}

#line 1393
template <class _CharT, class _Traits, class _Alloc> inline void
swap(basic_string<_CharT,_Traits,_Alloc>& __x,
 basic_string<_CharT,_Traits,_Alloc>& __y) {
 __x.swap(__y);
}

#line 1401
template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
 _CharT* __buf,
 size_t __n);

#line 1414
 }
#line 1 "../../stlport/stl/_string.c"


#line 47
 namespace _STL {

#line 57
 template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {
 if (__res_arg > max_size())
 this->_M_throw_length_error();

#line 61
 size_type __n = (max)(__res_arg, size()) + 1;
 pointer __new_start = this->_M_end_of_storage.allocate(__n);
 pointer __new_finish = __new_start;

#line 65
 try {
 __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
 _M_construct_null(__new_finish);
 }
 catch(...) { (_Destroy(__new_start, __new_finish), this->_M_end_of_storage.deallocate(__new_start, __n)); throw; } ;


#line 72
 _Destroy(this->_M_start, this->_M_finish + 1);
 this->_M_deallocate_block();
 this->_M_start = __new_start;
 this->_M_finish = __new_finish;
 this->_M_end_of_storage._M_data = __new_start + __n;
}

#line 79
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
 if (__n > max_size() || size() > max_size() - __n)
 this->_M_throw_length_error();
 if (size() + __n > capacity())
 reserve(size() + (max)(size(), __n));
 if (__n > 0) {
 uninitialized_fill_n(this->_M_finish + 1, __n - 1, __c);
 try {
 _M_construct_null(this->_M_finish + __n);
 }
 catch(...) { _Destroy(this->_M_finish + 1, this->_M_finish + __n); throw; } ;
 _Traits::assign(*end(), __c);
 this->_M_finish += __n;
 }
 return *this;
}

#line 140
template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
 if (__n <= size()) {
 _Traits::assign(this->_M_start, __n, __c);
 erase(begin() + __n, end());
 }
 else {
 _Traits::assign(this->_M_start, size(), __c);
 append(__n - size(), __c);
 }
 return *this;
}

#line 154
template <class _CharT, class _Traits, class _Alloc> _CharT*
basic_string<_CharT,_Traits,_Alloc> ::_M_insert_aux(_CharT* __p,
 _CharT __c)
{
 pointer __new_pos = __p;
 if (this->_M_finish + 1 < this->_M_end_of_storage._M_data) {
 _M_construct_null(this->_M_finish + 1);
 _Traits::move(__p + 1, __p, this->_M_finish - __p);
 _Traits::assign(*__p, __c);
 ++this->_M_finish;
 }
 else {
 const size_type __old_len = size();
 const size_type __len = __old_len +
 (max)(__old_len, static_cast<size_type>(1) ) + 1;
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = __new_start;
 try {
 __new_pos = uninitialized_copy(this->_M_start, __p, __new_start);
 _Construct(__new_pos, __c);
 __new_finish = __new_pos + 1;
 __new_finish = uninitialized_copy(__p, this->_M_finish, __new_finish);
 _M_construct_null(__new_finish);
 }
 catch(...) { (_Destroy(__new_start,__new_finish), this->_M_end_of_storage.deallocate(__new_start,__len)); throw; } ;

 _Destroy(this->_M_start, this->_M_finish + 1);
 this->_M_deallocate_block();
 this->_M_start = __new_start;
 this->_M_finish = __new_finish;
 this->_M_end_of_storage._M_data = __new_start + __len;
 }
 return __new_pos;
}

#line 189
template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,
 size_t __n, _CharT __c)
{
 if (__n != 0) {
 if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n + 1) {
 const size_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after >= __n) {
 uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
 this->_M_finish + 1);
 this->_M_finish += __n;
 _Traits::move(__position + __n,
 __position, (__elems_after - __n) + 1);
 _Traits::assign(__position, __n, __c);
 }
 else {
 uninitialized_fill_n(this->_M_finish + 1, __n - __elems_after - 1, __c);
 this->_M_finish += __n - __elems_after;
 try {
 uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
 this->_M_finish += __elems_after;
 }
 catch(...) { (_Destroy(__old_finish + 1, this->_M_finish), this->_M_finish = __old_finish); throw; } ;

 _Traits::assign(__position, __elems_after + 1, __c);
 }
 }
 else {
 const size_type __old_size = size();
 const size_type __len = __old_size + (max)(__old_size, __n) + 1;
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = __new_start;
 try {
 __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
 __new_finish = uninitialized_fill_n(__new_finish, __n, __c);
 __new_finish = uninitialized_copy(__position, this->_M_finish,
 __new_finish);
 _M_construct_null(__new_finish);
 }
 catch(...) { (_Destroy(__new_start,__new_finish), this->_M_end_of_storage.deallocate(__new_start,__len)); throw; } ;

 _Destroy(this->_M_start, this->_M_finish + 1);
 this->_M_deallocate_block();
 this->_M_start = __new_start;
 this->_M_finish = __new_finish;
 this->_M_end_of_storage._M_data = __new_start + __len;
 }
 }
}

#line 299
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc> ::replace(iterator __first, iterator __last, size_type __n, _CharT __c)
{
 size_type __len = (size_type)(__last - __first);

#line 303
 if (__len >= __n) {
 _Traits::assign(__first, __n, __c);
 erase(__first + __n, __last);
 }
 else {
 _Traits::assign(__first, __len, __c);
 insert(__last, __n - __len, __c);
 }
 return *this;
}

#line 336
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find(const _CharT* __s, size_type __pos, size_type __n) const
{
 if (__pos + __n > size())
 return npos;
 else {
 const const_pointer __result =
 _STL ::search((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
 __s, __s + __n, _Eq_traits<_Traits>());
 return __result != this->_M_finish ? __result - this->_M_start : npos;
 }
}

#line 349
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find(_CharT __c, size_type __pos) const
{
 if (__pos >= size())
 return npos;
 else {
 const const_pointer __result =
 _STL ::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
 _Eq_char_bound<_Traits>(__c));
 return __result != this->_M_finish ? __result - this->_M_start : npos;
 }
}

#line 362
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::rfind(const _CharT* __s, size_type __pos, size_type __n) const
{
 const size_t __len = size();

#line 367
 if (__n > __len)
 return npos;
 else if (__n == 0)
 return (min) (__len, __pos);
 else {
 const_pointer __last = this->_M_start + (min) (__len - __n, __pos) + __n;
 const_pointer __result = _STL ::find_end((const_pointer)this->_M_start, __last,
 __s, __s + __n,
 _Eq_traits<_Traits>());
 return __result != __last ? __result - this->_M_start : npos;
 }
}

#line 380
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::rfind(_CharT __c, size_type __pos) const
{
 const size_type __len = size();

#line 385
 if (__len < 1)
 return npos;
 else {
 const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
 const_reverse_iterator __rresult =
 _STL ::find_if(const_reverse_iterator(__last), rend(),
 _Eq_char_bound<_Traits>(__c));
 return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
 }
}

#line 396
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
{
 if (__pos >= size())
 return npos;
 else {
 const_iterator __result = __find_first_of(begin() + __pos, end(),
 __s, __s + __n,
 _Eq_traits<_Traits>());
 return __result != end() ? __result - begin() : npos;
 }
}

#line 410
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
{
 const size_type __len = size();

#line 415
 if (__len < 1)
 return npos;
 else {
 const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
 const const_reverse_iterator __rresult =
 __find_first_of(const_reverse_iterator(__last), rend(),
 __s, __s + __n,
 _Eq_traits<_Traits>());
 return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
 }
}

#line 428
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
 typedef typename _Traits::char_type _CharType;
 if (__pos > size())
 return npos;
 else {
 const_pointer __result = _STL ::find_if((const _CharT*)this->_M_start + __pos,
 (const _CharT*)this->_M_finish,
 _Not_within_traits<_Traits>((const _CharType*)__s,
 (const _CharType*)__s + __n));
 return __result != this->_M_finish ? __result - this->_M_start : npos;
 }
}

#line 443
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const
{
 if (__pos > size())
 return npos;
 else {
 const_pointer __result = _STL ::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
 _Neq_char_bound<_Traits>(__c));
 return __result != this->_M_finish ? __result - this->_M_start : npos;
 }
}

#line 455
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT,_Traits,_Alloc> ::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
 typedef typename _Traits::char_type _CharType;
 const size_type __len = size();

#line 461
 if (__len < 1)
 return npos;
 else {
 const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
 const_reverse_iterator __rlast = const_reverse_iterator(__last);
 const_reverse_iterator __rresult =
 _STL ::find_if(__rlast, rend(),
 _Not_within_traits<_Traits>((const _CharType*)__s,
 (const _CharType*)__s + __n));
 return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
 }
}

#line 474
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
 basic_string<_CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const
{
 const size_type __len = size();

#line 479
 if (__len < 1)
 return npos;
 else {
 const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
 const_reverse_iterator __rlast = const_reverse_iterator(__last);
 const_reverse_iterator __rresult =
 _STL ::find_if(__rlast, rend(),
 _Neq_char_bound<_Traits>(__c));
 return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
 }
}

#line 491
template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
 _CharT* __buf,
 size_t __n)
{
 if (__n > 0) {
 __n = (min) (__n - 1, __s.size());
 _STL ::copy(__s.begin(), __s.begin() + __n, __buf);
 __buf[__n] = _CharT();
 }
}
 }
#line 1 "../../stlport/stl/_string_fwd.c"

#line 508 "../../stlport/stl/_string.c"

#line 1 "../../stlport/stl/_range_errors.h"


#line 36
 namespace _STL {

#line 37
 void __stl_throw_range_error(const char* __msg);
void __stl_throw_out_of_range(const char* __msg);
void __stl_throw_length_error(const char* __msg);
void __stl_throw_invalid_argument(const char* __msg);
void __stl_throw_overflow_error(const char* __msg);
 }
#line 515 "../../stlport/stl/_string.c"

 namespace _STL {

#line 518
 template <class _Tp, class _Alloc> void _String_base<_Tp,_Alloc>::_M_throw_length_error() const {
 __stl_throw_length_error("basic_string");
}

#line 522
template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const {
 __stl_throw_out_of_range("basic_string");
}

#line 526
template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {
 if ((__n <= (max_size()+1)) && (__n>0)){
 _M_start = _M_end_of_storage.allocate(__n);
 _M_finish = _M_start;
 _M_end_of_storage._M_data = _M_start + __n;
 }
 else
 _M_throw_length_error();
}

#line 536
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string()
 : _String_base<_CharT,_Alloc>(allocator_type()) {
 this->_M_start = this->_M_end_of_storage.allocate(8);
 this->_M_finish = this->_M_start;
 this->_M_end_of_storage._M_data = this->_M_start + 8;
 _M_terminate_string();
}

#line 545
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT* __s,
 const allocator_type& __a)
 : _String_base<_CharT,_Alloc>(__a)
{
 __s=__s;
 _M_range_initialize(__s, __s + traits_type::length(__s));
}

#line 554
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const basic_string<_CharT, _Traits, _Alloc> & __s)
 : _String_base<_CharT,_Alloc>(__s.get_allocator())
{
 _M_range_initialize(__s._M_start, __s._M_finish);
}

#line 564
 }
#line 1422 "../../stlport/stl/_string.h"

#line 1 "../../stlport/stl/_string_io.h"

#line 1 "../../stlport/string"

#line 1 "../../stlport/stl/_string.h"

#line 46 "../../stlport/string"

#line 25 "../../stlport/stl/_string_io.h"


#line 36
 namespace _STL {

#line 40
 template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
 const basic_string<_CharT,_Traits,_Alloc>& __s);

#line 45
template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
 basic_string<_CharT,_Traits,_Alloc>& __s);

#line 50
template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
 basic_string<_CharT,_Traits,_Alloc>& __s,
 _CharT __delim);

#line 58
template <class _CharT, class _Traits, class _Alloc>
inline basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
 basic_string<_CharT,_Traits,_Alloc>& __s)
{
 return getline(__is, __s, __is.widen('\n'));
}

#line 67
template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
 basic_streambuf<_CharT, _Traits>* __buf,
 size_t __n);

#line 114
 }
#line 1 "../../stlport/stl/_string_io.c"


#line 12
 namespace _STL {

#line 22
 template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
 basic_streambuf<_CharT, _Traits>* __buf,
 size_t __n)
{
 _CharT __f = __os.fill();
 size_t __i;
 bool __ok = true;

#line 32
 for (__i = 0; __i < __n; ++__i)
 __ok = __ok && !_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof());
 return __ok;
}

#line 37
template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
 const basic_string<_CharT,_Traits,_Alloc>& __s)
{

#line 44
 typedef basic_ostream<_CharT, _Traits> __ostream;
 typename __ostream::sentry __sentry(__os);
 bool __ok = false;

#line 48
 if (__sentry) {
 __ok = true;
 size_t __n = __s.size();
 size_t __pad_len = 0;
 const bool __left = (__os.flags() & __ostream::left) != 0;
 const size_t __w = __os.width(0);
 basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();

#line 56
 if (__n < __w) {
 __pad_len = __w - __n;
 }

#line 60
 if (!__left)
 __ok = __stlp_string_fill(__os, __buf, __pad_len);

#line 63
 __ok = __ok && (__buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n));

#line 65
 if (__left)
 __ok = __ok && __stlp_string_fill(__os, __buf, __pad_len);
 }

#line 69
 if (!__ok)
 __os.setstate(__ostream::failbit);

#line 72
 return __os;
}

#line 75
template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
 basic_string<_CharT,_Traits, _Alloc>& __s)
{

#line 81
 typedef basic_istream<_CharT, _Traits> __istream;
 typename __istream::sentry __sentry(__is);

#line 84
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
 typedef ctype<_CharT> _C_type;

#line 90
 const _C_type& _Ctype = *(const _C_type*)__is._M_ctype_facet();

#line 103
 __s.clear();
 size_t __n = __is.width(0);
 if (__n == 0)
 __n = static_cast<size_t>(-1) ;
 else
 __s.reserve(__n);

#line 111
 while (__n-- > 0) {
 typename _Traits::int_type __c1 = __buf->sbumpc();
 if (_Traits::eq_int_type(__c1, _Traits::eof())) {
 __is.setstate(__istream::eofbit);
 break;
 }
 else {
 _CharT __c = _Traits::to_char_type(__c1);

#line 120
 if (_Ctype.is(_C_type::space, __c)) {
 if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
 __is.setstate(__istream::failbit);
 break;
 }
 else
 __s.push_back(__c);
 }
 }

#line 131
 if (__s.size() == 0)
 __is.setstate(__istream::failbit);
 }
 else
 __is.setstate(__istream::failbit);

#line 137
 return __is;
}

#line 140
template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
 basic_string<_CharT,_Traits,_Alloc>& __s,
 _CharT __delim)
{

#line 147
 typedef basic_istream<_CharT, _Traits> __istream;
 size_t __nread = 0;
 typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
 __s.clear();

#line 154
 while (__nread < __s.max_size()) {
 int __c1 = __buf->sbumpc();
 if (_Traits::eq_int_type(__c1, _Traits::eof())) {
 __is.setstate(__istream::eofbit);
 break;
 }
 else {
 ++__nread;
 _CharT __c = _Traits::to_char_type(__c1);
 if (!_Traits::eq(__c, __delim))
 __s.push_back(__c);
 else
 break;
 }
 }
 }
 if (__nread == 0 || __nread >= __s.max_size())
 __is.setstate(__istream::failbit);

#line 173
 return __is;
}

#line 325
 }
#line 120 "../../stlport/stl/_string_io.h"

#line 1425 "../../stlport/stl/_string.h"

#line 1 "../../stlport/stl/_string_hash.h"

#line 1 "../../stlport/stl/_hash_fun.h"


#line 38
 namespace _STL {

#line 40
 template <class _Key> struct hash { };

#line 42
inline size_t __stl_hash_string(const char* __s)
{
 __s=__s;
 unsigned long __h = 0;
 for ( ; *__s; ++__s)
 __h = 5*__h + *__s;

#line 49
 return size_t(__h);
}

#line 52
 template<> struct hash<char*>
{
 size_t operator()(const char* __s) const { __s=__s; return __stl_hash_string(__s); }
};

#line 57
 template<> struct hash<const char*>
{
 size_t operator()(const char* __s) const { __s=__s; return __stl_hash_string(__s); }
};

#line 62
 template<> struct hash<char> {
 size_t operator()(char __x) const { return __x; }
};
 template<> struct hash<unsigned char> {
 size_t operator()(unsigned char __x) const { return __x; }
};

#line 69
 template<> struct hash<signed char> {
 size_t operator()(unsigned char __x) const { return __x; }
};

#line 73
 template<> struct hash<short> {
 size_t operator()(short __x) const { return __x; }
};
 template<> struct hash<unsigned short> {
 size_t operator()(unsigned short __x) const { return __x; }
};
 template<> struct hash<int> {
 size_t operator()(int __x) const { return __x; }
};
 template<> struct hash<unsigned int> {
 size_t operator()(unsigned int __x) const { return __x; }
};
 template<> struct hash<long> {
 size_t operator()(long __x) const { return __x; }
};
 template<> struct hash<unsigned long> {
 size_t operator()(unsigned long __x) const { return __x; }
};

#line 93
 template<> struct hash< long long > {
 size_t operator()(long x) const { return x; }
};
 template<> struct hash<unsigned long long > {
 size_t operator()(unsigned long x) const { return x; }
};

#line 101
 }
#line 24 "../../stlport/stl/_string_hash.h"


#line 30
 namespace _STL {

#line 32
 template <class _CharT, class _Traits, class _Alloc>
 inline size_t
__stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
 unsigned long __h = 0;
 typedef typename basic_string<_CharT,_Traits,_Alloc>::const_pointer const_ptr;
 size_t __len = __s.size();
 const _CharT* __data = __s.data();
 for ( size_t __i = 0; __i < __len; ++__i)
 __h = 5*__h + __data[__i];
 return size_t(__h);
}

#line 46
template <class _CharT, class _Traits, class _Alloc>
struct hash<basic_string<_CharT,_Traits,_Alloc> > {
 size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
 { return __stl_string_hash(__s); }
};

#line 68
 }
#line 1426 "../../stlport/stl/_string.h"

#line 32 "../../stlport/stl/_ios_base.h"


#line 34
 namespace _STL {

#line 45
 class ios_base {
public:

#line 48
 class failure : public __Named_exception {
 public:
 explicit failure(const string&);
 virtual ~failure() throw() ;
 };

#line 54
 typedef int fmtflags;
 typedef int iostate;
 typedef int openmode;
 typedef int seekdir;

#line 60
 typedef fmtflags fmt_flags;

#line 68
 static const int

#line 70
 left = 0x0001,
 right = 0x0002,
 internal = 0x0004,
 dec = 0x0008,
 hex = 0x0010,
 oct = 0x0020,
 fixed = 0x0040,
 scientific = 0x0080,
 boolalpha = 0x0100,
 showbase = 0x0200,
 showpoint = 0x0400,
 showpos = 0x0800,
 skipws = 0x1000,
 unitbuf = 0x2000,
 uppercase = 0x4000,
 adjustfield = left | right | internal,
 basefield = dec | hex | oct,
 floatfield = scientific | fixed,

#line 90
 goodbit = 0x00,
 badbit = 0x01,
 eofbit = 0x02,
 failbit = 0x04,

#line 96
 __default_mode = 0x0,
 app = 0x01,
 ate = 0x02,
 binary = 0x04,
 in = 0x08,
 out = 0x10,
 trunc = 0x20,

#line 106
 beg = 0x01,
 cur = 0x02,
 end = 0x04

#line 112
 ;

#line 114
public:
 fmtflags flags() const { return _M_fmtflags; }
 fmtflags flags(fmtflags __flags) {
 fmtflags __tmp = _M_fmtflags;
 _M_fmtflags = __flags;
 return __tmp;
 }

#line 122
 fmtflags setf(fmtflags __flag) {
 fmtflags __tmp = _M_fmtflags;
 _M_fmtflags |= __flag;
 return __tmp;
 }
 fmtflags setf(fmtflags __flag, fmtflags __mask) {
 fmtflags __tmp = _M_fmtflags;
 _M_fmtflags &= ~__mask;
 _M_fmtflags |= __flag & __mask;
 return __tmp;
 }
 void unsetf(fmtflags __mask) { _M_fmtflags &= ~__mask; }

#line 135
 streamsize precision() const { return _M_precision; }
 streamsize precision(streamsize __newprecision) {
 streamsize __tmp = _M_precision;
 _M_precision = __newprecision;
 return __tmp;
 }

#line 142
 streamsize width() const { return _M_width; }
 streamsize width(streamsize __newwidth) {
 streamsize __tmp = _M_width;
 _M_width = __newwidth;
 return __tmp;
 }

#line 149
public:
 locale imbue(const locale&);
 locale getloc() const { return _M_locale; }

#line 153
public:
 static int xalloc();
 long& iword(int __index);
 void*& pword(int __index);

#line 158
public:
 virtual ~ios_base();

#line 161
public:
 enum event { erase_event, imbue_event, copyfmt_event };
 typedef void (*event_callback)(event, ios_base&, int __index);
 void register_callback(event_callback __fn, int __index);

#line 166
public:

#line 169
 static bool sync_with_stdio(bool __sync = true);

#line 171
public:

#line 175
 operator void*() const { return !fail() ? (void*) const_cast<ios_base*>(this) : (void*) 0; }
 bool operator!() const { return fail(); }

#line 178
 iostate rdstate() const { return _M_iostate; }

#line 180
 bool good() const { return _M_iostate == 0; }
 bool eof() const { return (_M_iostate & eofbit) != 0; }
 bool fail() const { return (_M_iostate & (failbit | badbit)) != 0; }
 bool bad() const { return (_M_iostate & badbit) != 0; }

#line 185
protected:

#line 191
 void _M_copy_state(const ios_base& __x);

#line 193
 void _M_setstate_nothrow(iostate __state) { _M_iostate |= __state; }
 void _M_clear_nothrow(iostate __state) { _M_iostate = __state; }
 iostate _M_get_exception_mask() const { return _M_exception_mask; }
 void _M_set_exception_mask(iostate __mask) { _M_exception_mask = __mask; }
 void _M_check_exception_mask() {
 if (_M_iostate & _M_exception_mask)
 _M_throw_failure();
 }

#line 202
 void _M_invoke_callbacks(event);
 void _M_throw_failure();

#line 205
 ios_base();

#line 207
protected:
 static void _S_initialize();
 static void _S_uninitialize();
 static bool _S_was_synced;

#line 212
private:

#line 214
 ios_base(const ios_base&);
 void operator=(const ios_base&);

#line 217
private:

#line 219
 fmtflags _M_fmtflags;
 iostate _M_iostate;
 openmode _M_openmode;
 seekdir _M_seekdir;
 iostate _M_exception_mask;

#line 225
 streamsize _M_precision;
 streamsize _M_width;

#line 228
 locale _M_locale;

#line 230
 pair<event_callback, int>* _M_callbacks;
 size_t _M_num_callbacks;
 size_t _M_callback_index;

#line 235
 long* _M_iwords;
 size_t _M_num_iwords;

#line 238
 void** _M_pwords;
 size_t _M_num_pwords;

#line 241
 static int _S_index;

#line 243
protected:

#line 245
 locale::facet* _M_cached_ctype;
 locale::facet* _M_cached_numpunct;
 string _M_cached_grouping;
public:

#line 250
 const locale::facet* _M_ctype_facet() const { return _M_cached_ctype; }
 const locale::facet* _M_numpunct_facet() const { return _M_cached_numpunct; }
 const string& _M_grouping() const { return _M_cached_grouping; }
public:

#line 261
 class Init {
 public:
 Init();
 ~Init();
 private:
 static long _S_count;
 friend class ios_base;
 };

#line 271
 class _Loc_init {
 public:
 _Loc_init();
 ~_Loc_init();
 private:
 static long _S_count;
 friend class ios_base;
 };

#line 280
 friend class Init;

#line 282
public:

#line 285
 typedef iostate io_state;
 typedef openmode open_mode;
 typedef seekdir seek_dir;
 typedef _STL ::streamoff streamoff;
 typedef _STL ::streampos streampos;

#line 291
};

#line 293
template <class Facet>
locale::facet* _M_get_facet(ios_base& __i, Facet*)
{

#line 297
}

#line 304
inline ios_base& boolalpha(ios_base& __s)
 { __s.setf(ios_base::boolalpha); return __s;}

#line 307
inline ios_base& noboolalpha(ios_base& __s)
 { __s.unsetf(ios_base::boolalpha); return __s;}

#line 310
inline ios_base& showbase(ios_base& __s)
 { __s.setf(ios_base::showbase); return __s;}

#line 313
inline ios_base& noshowbase(ios_base& __s)
 { __s.unsetf(ios_base::showbase); return __s;}

#line 316
inline ios_base& showpoint(ios_base& __s)
 { __s.setf(ios_base::showpoint); return __s;}

#line 319
inline ios_base& noshowpoint(ios_base& __s)
 { __s.unsetf(ios_base::showpoint); return __s;}

#line 322
inline ios_base& showpos(ios_base& __s)
 { __s.setf(ios_base::showpos); return __s;}

#line 325
inline ios_base& noshowpos(ios_base& __s)
 { __s.unsetf(ios_base::showpos); return __s;}

#line 328
inline ios_base& skipws(ios_base& __s)
 { __s.setf(ios_base::skipws); return __s;}

#line 331
inline ios_base& noskipws(ios_base& __s)
 { __s.unsetf(ios_base::skipws); return __s;}

#line 334
inline ios_base& uppercase(ios_base& __s)
 { __s.setf(ios_base::uppercase); return __s;}

#line 337
inline ios_base& nouppercase(ios_base& __s)
 { __s.unsetf(ios_base::uppercase); return __s;}

#line 340
inline ios_base& unitbuf(ios_base& __s)
 { __s.setf(ios_base::unitbuf); return __s;}

#line 343
inline ios_base& nounitbuf(ios_base& __s)
 { __s.unsetf(ios_base::unitbuf); return __s;}

#line 348
inline ios_base& internal(ios_base& __s)
 { __s.setf(ios_base::internal, ios_base::adjustfield); return __s; }

#line 351
inline ios_base& left(ios_base& __s)
 { __s.setf(ios_base::left, ios_base::adjustfield); return __s; }

#line 354
inline ios_base& right(ios_base& __s)
 { __s.setf(ios_base::right, ios_base::adjustfield); return __s; }

#line 358
inline ios_base& dec(ios_base& __s)
 { __s.setf(ios_base::dec, ios_base::basefield); return __s; }

#line 361
inline ios_base& hex(ios_base& __s)
 { __s.setf(ios_base::hex, ios_base::basefield); return __s; }

#line 364
inline ios_base& oct(ios_base& __s)
 { __s.setf(ios_base::oct, ios_base::basefield); return __s; }

#line 369
inline ios_base& fixed(ios_base& __s)
 { __s.setf(ios_base::fixed, ios_base::floatfield); return __s; }

#line 372
inline ios_base& scientific(ios_base& __s)
 { __s.setf(ios_base::scientific, ios_base::floatfield); return __s; }

#line 401
 }
#line 24 "../../stlport/stl/_ios.h"

#line 1 "../../stlport/stl/_ctype.h"

#line 1 "../../stlport/stl/c_locale.h"


#line 107
 struct _Locale_ctype;

#line 108
struct _Locale_numeric;
struct _Locale_time;
struct _Locale_collate;
struct _Locale_monetary;
struct _Locale_messages;
#line 27 "../../stlport/stl/_ctype.h"


#line 35
 namespace _STL {

#line 37
 class ctype_base {
public:
 enum mask {
 space = 0x200 ,
 print = 0x080 ,
 cntrl = 0x008 ,
 upper = 0x400 ,
 lower = 0x040 ,
 alpha = 0x001 ,
 digit = 0x010 ,
 punct = 0x100 ,
 xdigit = 0x800 ,
 alnum = alpha | digit,
 graph = alnum | punct
 };
};

#line 56
template <class charT> class ctype {};
template <class charT> class ctype_byname {};

#line 61
 template<>
 class ctype<char> : public locale::facet, public ctype_base
{

#line 70
 friend class ctype<wchar_t>;

#line 73
 friend class _Locale;
public:

#line 76
 typedef char char_type;

#line 78
 explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
 bool is(mask __m, char __c) const
 { return ((*(_M_ctype_table+(unsigned char)__c)) & __m) != 0; }

#line 82
 const char* is(const char* __low, const char* __high, mask* __vec) const {
 for (const char* __p = __low;__p != __high; ++__p, ++__vec) {
 *__vec = _M_ctype_table[(unsigned char)*__p];
 }
 return __high;
 }

#line 89
 const char* scan_is(mask __m, const char* __low, const char* __high) const;
 const char* scan_not(mask __m, const char* __low, const char* __high) const;

#line 92
 char (toupper)(char __c) const { return do_toupper(__c); }
 const char* (toupper)(char* __low, const char* __high) const {
 return do_toupper(__low, __high);
 }

#line 97
 char (tolower)(char __c) const { return do_tolower(__c); }
 const char* (tolower)(char* __low, const char* __high) const {
 return do_tolower(__low, __high);
 }

#line 102
 char widen(char __c) const { return do_widen(__c); }
 const char* widen(const char* __low, const char* __high, char* __to) const {
 return do_widen(__low, __high, __to);
 }

#line 107
 char narrow(char __c, char __dfault) const {
 return do_narrow(__c, __dfault);
 }
 const char* narrow(const char* __low, const char* __high,
 char __dfault, char* __to) const {
 return do_narrow(__low, __high, __dfault, __to);
 }

#line 115
 static locale::id id;

#line 119
 static const size_t table_size = 256;

#line 122
protected:
 const mask* table() const {return _M_ctype_table;}
 static const mask* classic_table() { return & _S_classic_table [1]; }

#line 126
 ~ctype();

#line 128
 virtual char do_toupper(char __c) const;
 virtual char do_tolower(char __c) const;
 virtual const char* do_toupper(char* __low, const char* __high) const;
 virtual const char* do_tolower(char* __low, const char* __high) const;
 virtual char do_widen(char __c) const;
 virtual const char* do_widen(const char* __low, const char* __high,
 char* __to) const;
 virtual char do_narrow(char __c, char ) const;
 virtual const char* do_narrow(const char* __low, const char* __high,
 char , char* __to) const;
private:
 struct _Is_mask {
 mask __m;
 _Is_mask(mask __x): __m(__x) {}
 bool operator()(char __c) {return (__m & (unsigned char) __c) != 0;}
 };

#line 145
 static const mask _S_classic_table[257 ];
 const mask* _M_ctype_table;
 bool _M_delete;

#line 149
 static const unsigned char _S_upper[256 ];
 static const unsigned char _S_lower[256 ];
};

#line 153
 template<>
 class ctype_byname<char>: public ctype<char> {
public:
 explicit ctype_byname(const char*, size_t = 0);
 ~ctype_byname();

#line 159
 virtual char do_toupper(char __c) const;
 virtual char do_tolower(char __c) const;

#line 162
 virtual const char* do_toupper(char*, const char*) const;
 virtual const char* do_tolower(char*, const char*) const;

#line 165
private:
 mask _M_byname_table[table_size + 1];
 _Locale_ctype* _M_ctype;
};

#line 172
 template<>
 class ctype<wchar_t> : public locale::facet, public ctype_base
{
 friend class _Locale;
public:
 typedef wchar_t char_type;

#line 179
 explicit ctype(size_t __refs = 0) : locale::facet (__refs) {}

#line 181
 bool is(mask __m, wchar_t __c) const
 { return do_is(__m, __c); }

#line 184
 const wchar_t* is(const wchar_t* __low, const wchar_t* __high,
 mask* __vec) const
 { return do_is(__low, __high, __vec); }

#line 188
 const wchar_t* scan_is(mask __m,
 const wchar_t* __low, const wchar_t* __high) const
 { return do_scan_is(__m, __low, __high); }

#line 192
 const wchar_t* scan_not (mask __m,
 const wchar_t* __low, const wchar_t* __high) const
 { return do_scan_not(__m, __low, __high); }

#line 196
 wchar_t (toupper)(wchar_t __c) const { return do_toupper(__c); }
 const wchar_t* (toupper)(wchar_t* __low, wchar_t* __high) const
 { return do_toupper(__low, __high); }

#line 200
 wchar_t (tolower)(wchar_t __c) const { return do_tolower(__c); }
 const wchar_t* (tolower)(wchar_t* __low, wchar_t* __high) const
 { return do_tolower(__low, __high); }

#line 204
 wchar_t widen(char __c) const { return do_widen(__c); }
 const char* widen(const char* __low, const char* __high,
 wchar_t* __to) const
 { return do_widen(__low, __high, __to); }

#line 209
 char narrow(wchar_t __c, char __dfault) const
 { return do_narrow(__c, __dfault); }
 const wchar_t* narrow(const wchar_t* __low, const wchar_t* __high,
 char __dfault, char* __to) const
 { return do_narrow(__low, __high, __dfault, __to); }

#line 215
 static locale::id id;

#line 217
protected:
 ~ctype();

#line 220
 virtual bool do_is(mask __m, wchar_t __c) const;
 virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
 virtual const wchar_t* do_scan_is(mask,
 const wchar_t*, const wchar_t*) const;
 virtual const wchar_t* do_scan_not(mask,
 const wchar_t*, const wchar_t*) const;
 virtual wchar_t do_toupper(wchar_t __c) const;
 virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
 virtual wchar_t do_tolower(wchar_t c) const;
 virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;
 virtual wchar_t do_widen(char c) const;
 virtual const char* do_widen(const char*, const char*, wchar_t*) const;
 virtual char do_narrow(wchar_t __c, char __dfault) const;
 virtual const wchar_t* do_narrow(const wchar_t*, const wchar_t*,
 char, char*) const;
};

#line 237
 template<>
 class ctype_byname<wchar_t>: public ctype<wchar_t> {
public:
 explicit ctype_byname(const char* __name, size_t __refs = 0);

#line 242
protected:
 ~ctype_byname();

#line 245
 virtual bool do_is(mask __m, wchar_t __c) const;
 virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
 virtual const wchar_t* do_scan_is(mask,
 const wchar_t*, const wchar_t*) const;
 virtual const wchar_t* do_scan_not(mask,
 const wchar_t*, const wchar_t*) const;
 virtual wchar_t do_toupper(wchar_t __c) const;
 virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
 virtual wchar_t do_tolower(wchar_t c) const;
 virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;

#line 256
private:
 _Locale_ctype* _M_ctype;
};

#line 262
 }
#line 28 "../../stlport/stl/_ios.h"

#line 1 "../../stlport/stl/_numpunct.h"


#line 38
 namespace _STL {

#line 43
 template <class _CharT> class numpunct {};
template <class _CharT> class numpunct_byname {};
template <class _Ch, class _InIt> class num_get;

#line 47
 template<>
 class numpunct<char> : public locale::facet
{
 friend class _Locale;

#line 52
 template <class _Ch, class _InIt> friend class num_get;

#line 54
public:
 typedef char char_type;
 typedef string string_type;

#line 58
 explicit numpunct(size_t __refs = 0) : locale::facet (__refs) {}

#line 60
 char decimal_point() const { return do_decimal_point(); }
 char thousands_sep() const { return do_thousands_sep(); }
 string grouping() const { return do_grouping(); }
 string truename() const { return do_truename(); }
 string falsename() const { return do_falsename(); }

#line 66
 static locale::id id;

#line 69
protected:

#line 71
 ~numpunct();

#line 73
 static string _M_truename;
 static string _M_falsename;
 static string _M_grouping;

#line 77
 virtual char do_decimal_point() const;
 virtual char do_thousands_sep() const;
 virtual string do_grouping() const;
 virtual string do_truename() const;
 virtual string do_falsename() const;
};

#line 86
 template<>
 class numpunct<wchar_t> : public locale::facet
{
 friend class _Locale;
public:
 typedef wchar_t char_type;
 typedef wstring string_type;

#line 94
 explicit numpunct(size_t __refs = 0) : locale::facet (__refs) {}

#line 96
 wchar_t decimal_point() const { return do_decimal_point(); }
 wchar_t thousands_sep() const { return do_thousands_sep(); }
 string grouping() const { return do_grouping(); }
 wstring truename() const { return do_truename(); }
 wstring falsename() const { return do_falsename(); }

#line 102
 static locale::id id;

#line 104
protected:
 static wstring _M_truename;
 static wstring _M_falsename;
 static string _M_grouping;

#line 109
 ~numpunct();

#line 111
 virtual wchar_t do_decimal_point() const;
 virtual wchar_t do_thousands_sep() const;
 virtual string do_grouping() const;
 virtual wstring do_truename() const;
 virtual wstring do_falsename() const;
};

#line 120
 template<>
 class numpunct_byname<char> : public numpunct<char> {
public:
 typedef char char_type;
 typedef string string_type;

#line 126
 explicit numpunct_byname(const char* __name, size_t __refs = 0);

#line 128
protected:

#line 130
 ~numpunct_byname();

#line 132
 virtual char do_decimal_point() const;
 virtual char do_thousands_sep() const;
 virtual string do_grouping() const;

#line 136
private:
 _Locale_numeric* _M_numeric;
};

#line 141
 template<>
 class numpunct_byname<wchar_t>: public numpunct<wchar_t> {
public:
 typedef wchar_t char_type;
 typedef wstring string_type;

#line 147
 explicit numpunct_byname(const char* __name, size_t __refs = 0);

#line 149
protected:

#line 151
 ~numpunct_byname();

#line 153
 virtual wchar_t do_decimal_point() const;
 virtual wchar_t do_thousands_sep() const;
 virtual string do_grouping() const;

#line 157
private:
 _Locale_numeric* _M_numeric;
};

#line 163
 }
#line 31 "../../stlport/stl/_ios.h"


#line 33
 namespace _STL {

#line 46
 template <class _CharT, class _Traits>
class basic_ios : public ios_base {
 friend class ios_base;
public:
 typedef _CharT char_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;
 typedef _Traits traits_type;

#line 56
public:
 explicit basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf);
 virtual ~basic_ios() {}

#line 60
public:
 basic_ostream<_CharT, _Traits>* tie() const {
 return _M_tied_ostream;
 }
 basic_ostream<_CharT, _Traits>*
 tie(basic_ostream<char_type, traits_type>* __new_tied_ostream) {
 basic_ostream<char_type, traits_type>* __tmp = _M_tied_ostream;
 _M_tied_ostream = __new_tied_ostream;
 return __tmp;
 }

#line 71
 basic_streambuf<_CharT, _Traits>* rdbuf() const
 { return _M_streambuf; }

#line 74
 basic_streambuf<_CharT, _Traits>*
 rdbuf(basic_streambuf<char_type, traits_type>*);

#line 78
 basic_ios<_CharT, _Traits>& copyfmt(const basic_ios<_CharT, _Traits>& __x);

#line 80
 char_type fill() const { return _M_fill; }
 char_type fill(char_type __fill) {
 char_type __tmp(_M_fill);
 _M_fill = __fill;
 return __tmp;
 }

#line 87
public:

#line 90
 void clear(iostate __state = goodbit) {
 _M_clear_nothrow(this->rdbuf() ? __state : iostate(__state|ios_base::badbit));
 _M_check_exception_mask();
 }
 void setstate(iostate __state) { this->clear(rdstate() | __state); }

#line 96
 iostate exceptions() const { return this->_M_get_exception_mask(); }
 void exceptions(iostate __mask) {
 this->_M_set_exception_mask(__mask);
 this->clear(this->rdstate());
 }

#line 102
public:
 locale imbue(const locale&);

#line 105
 inline char narrow(_CharT, char) const ;
 inline _CharT widen(char) const;

#line 109
 static bool _S_eof(int_type __c) {
 const int_type __eof = _Traits::eof();
 return _Traits::eq_int_type(__c, __eof);
 }

#line 114
protected:
 basic_ios();

#line 117
 void init(basic_streambuf<_CharT, _Traits>* __streambuf);

#line 119
public:

#line 123
 void _M_handle_exception(ios_base::iostate __flag);

#line 125
private:
 char_type _M_fill;

#line 128
 basic_streambuf<_CharT, _Traits>* _M_streambuf;
 basic_ostream<_CharT, _Traits>* _M_tied_ostream;

#line 131
};

#line 134
template <class _CharT, class _Traits>
inline char
basic_ios<_CharT, _Traits>::narrow(_CharT __c, char __default) const
{ return ((const ctype<_CharT>*)this->_M_ctype_facet())->narrow(__c, __default); }

#line 139
template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
 return ((const ctype<_CharT>*)this->_M_ctype_facet())->widen(__c); }

#line 153
 template<>
 inline char
basic_ios<char, char_traits<char> >::narrow(char __c, char) const
{
 return __c;
}

#line 160
 template<>
 inline char
basic_ios<char, char_traits<char> >::widen(char __c) const
{
 return __c;
}

#line 169
 }
#line 1 "../../stlport/stl/_ios.c"

#line 1 "../../stlport/stl/_streambuf.h"

#line 1 "../../stlport/stl/_stdio_file.h"

#line 1 "/opt/aCC/include/cstdio"

#line 70 "../../stlport/stl/_stdio_file.h"


#line 79
 namespace _STL {

#line 343
 inline int _FILE_fd(const FILE *__f) { return fileno( const_cast<FILE *>(__f) ); }
inline char* _FILE_I_begin(const FILE *__f) { return ( reinterpret_cast<char*>(__f->__base) ); }
inline char* _FILE_I_next(const FILE *__f) { return ( reinterpret_cast<char*>(__f->__ptr) ); }
inline char* _FILE_I_end(const FILE *__f) { return ( reinterpret_cast<char*>(__f->__ptr +__f->__cnt) ); }

#line 348
inline ptrdiff_t _FILE_I_avail(const FILE *__f) { return __f->__cnt; }

#line 350
inline char& _FILE_I_preincr(FILE *__f) { --__f->__cnt; return * reinterpret_cast<char*>(++__f->__ptr) ; }
inline char& _FILE_I_postincr(FILE *__f) { --__f->__cnt; return * reinterpret_cast<char*>(__f->__ptr++) ; }
inline char& _FILE_I_predecr(FILE *__f) { ++__f->__cnt; return * reinterpret_cast<char*>(--__f->__ptr) ; }
inline char& _FILE_I_postdecr(FILE *__f) { ++__f->__cnt; return * reinterpret_cast<char*>(__f->__ptr--) ; }
inline void _FILE_I_bump(FILE *__f, int __n) { __f->__cnt -= __n; __f->__ptr += __n; }

#line 356
inline void _FILE_I_set(FILE *__f, char* __begin, char* __next, char* __end) {

#line 358
 if( (unsigned long) (__f - &__iob[0]) > 60 )
 __f->__flag |= 0001000 ;

#line 361
 __f->__cnt = __end - __next;
 __f->__base = reinterpret_cast<unsigned char*>(__begin) ;
 __f->__ptr = reinterpret_cast<unsigned char*>(__next) ;
 (*(((__f)->__flag & 0001000) ? &(( reinterpret_cast<_FILEX*>((__f)))->__bufendp) : &(__bufendtab[ reinterpret_cast<FILE*>((__f)) - __iob]))) = reinterpret_cast<unsigned char*>(__end) ;
}

#line 682
inline char* _FILE_O_begin(const FILE *__f) { return _FILE_I_begin(__f); }
inline char* _FILE_O_next(const FILE *__f) { return _FILE_I_next(__f); }
inline char* _FILE_O_end(const FILE *__f) { return _FILE_I_end(__f); }

#line 686
inline ptrdiff_t _FILE_O_avail(const FILE *__f) { return _FILE_I_avail(__f); }

#line 688
inline char& _FILE_O_preincr(FILE *__f) { return _FILE_I_preincr(__f); }
inline char& _FILE_O_postincr(FILE *__f) { return _FILE_I_postincr(__f); }
inline char& _FILE_O_predecr(FILE *__f) { return _FILE_I_predecr(__f); }
inline char& _FILE_O_postdecr(FILE *__f) { return _FILE_I_postdecr(__f); }

#line 693
inline void _FILE_O_bump(FILE *__f, int __n) { _FILE_I_bump(__f, __n); }
inline void _FILE_O_set(FILE *__f, char* __begin, char* __next, char* __end)
 { _FILE_I_set(__f, __begin, __next, __end); }

#line 702
 }
#line 28 "../../stlport/stl/_streambuf.h"


#line 31
 namespace _STL {

#line 53
 template <class _CharT, class _Traits>
class basic_streambuf
{
 friend class basic_istream<_CharT, _Traits>;
 friend class basic_ostream<_CharT, _Traits>;

#line 59
public:
 typedef _CharT char_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;
 typedef _Traits traits_type;

#line 66
private:

#line 68
 char_type* _M_gbegin;
 char_type* _M_gnext;
 char_type* _M_gend;

#line 72
 char_type* _M_pbegin;
 char_type* _M_pnext;
 char_type* _M_pend;

#line 76
 locale _M_locale;

#line 78
public:
 _STLP_mutex _M_lock;

#line 81
public:
 virtual ~basic_streambuf();

#line 84
protected:
 basic_streambuf();

#line 87
protected:
 char_type* eback() const { return _M_gbegin; }
 char_type* gptr() const { return _M_gnext; }
 char_type* egptr() const { return _M_gend; }

#line 92
 void gbump(int __n) { _M_gnext += __n; }
 void setg(char_type* __gbegin, char_type* __gnext, char_type* __gend) {
 _M_gbegin = __gbegin;
 _M_gnext = __gnext;
 _M_gend = __gend;
 }

#line 99
public:

#line 104
 char_type* _M_eback() const { return eback(); }
 char_type* _M_gptr() const { return gptr(); }
 char_type* _M_egptr() const { return egptr(); }
 void _M_gbump(int __n) { gbump(__n); }
 void _M_setg(char_type* __gbegin, char_type* __gnext, char_type* __gend)
 { setg(__gbegin, __gnext, __gend); }

#line 111
protected:

#line 113
 char_type* pbase() const { return _M_pbegin; }
 char_type* pptr() const { return _M_pnext; }
 char_type* epptr() const { return _M_pend; }

#line 117
 void pbump(int __n) { _M_pnext += __n; }
 void setp(char_type* __pbegin, char_type* __pend) {
 _M_pbegin = __pbegin;
 _M_pnext = __pbegin;
 _M_pend = __pend;
 }

#line 124
protected:

#line 126
 virtual basic_streambuf<_CharT, _Traits>* setbuf(char_type*, streamsize);

#line 130
 virtual pos_type seekoff(off_type, ios_base::seekdir,
 ios_base::openmode = ios_base::in | ios_base::out);

#line 135
 virtual pos_type
 seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out);

#line 140
 virtual int sync();

#line 143
public:
 basic_streambuf<_CharT, _Traits>* pubsetbuf(char_type* __s, streamsize __n)
 { return this->setbuf(__s, __n); }

#line 147
 pos_type pubseekoff(off_type __offset, ios_base::seekdir __way,
 ios_base::openmode __mod = ios_base::in | ios_base::out)
 { return this->seekoff(__offset, __way, __mod); }

#line 151
 pos_type pubseekpos(pos_type __sp,
 ios_base::openmode __mod = ios_base::in | ios_base::out)
 { return this->seekpos(__sp, __mod); }

#line 155
 int pubsync() { return this->sync(); }

#line 157
protected:

#line 163
 virtual streamsize showmanyc();

#line 167
 virtual streamsize xsgetn(char_type* __s, streamsize __n);

#line 172
 virtual int_type underflow();

#line 176
 virtual int_type uflow();

#line 181
 virtual int_type pbackfail(int_type = traits_type::eof());

#line 183
protected:

#line 188
 virtual streamsize xsputn(const char_type* __s, streamsize __n);

#line 192
 virtual streamsize _M_xsputnc(char_type __c, streamsize __n);

#line 196
 virtual int_type overflow(int_type = traits_type::eof());

#line 198
public:

#line 200
 int_type sputc(char_type __c) {
 return ((_M_pnext < _M_pend) ? _Traits::to_int_type(*_M_pnext++ = __c)
 : this->overflow(_Traits::to_int_type(__c)));
 }

#line 206
 streamsize sputn(const char_type* __s, streamsize __n)
 { return this->xsputn(__s, __n); }

#line 210
 streamsize _M_sputnc(char_type __c, streamsize __n)
 { return this->_M_xsputnc(__c, __n); }

#line 213
private:
 int_type _M_snextc_aux();

#line 217
public:
 streamsize in_avail() {
 return (_M_gnext < _M_gend) ? (_M_gend - _M_gnext) : this->showmanyc();
 }

#line 223
 int_type snextc() {
 return ( _M_gend - _M_gnext > 1 ?
 _Traits::to_int_type(*++_M_gnext) :
 this->_M_snextc_aux());
 }

#line 230
 int_type sbumpc() {
 return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext++)
 : this->uflow();
 }

#line 236
 int_type sgetc() {
 return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext)
 : this->underflow();
 }

#line 241
 streamsize sgetn(char_type* __s, streamsize __n)
 { return this->xsgetn(__s, __n); }

#line 244
 int_type sputbackc(char_type __c) {
 return ((_M_gbegin < _M_gnext) && _Traits::eq(__c, *(_M_gnext - 1)))
 ? _Traits::to_int_type(*--_M_gnext)
 : this->pbackfail(_Traits::to_int_type(__c));
 }

#line 250
 int_type sungetc() {
 return (_M_gbegin < _M_gnext)
 ? _Traits::to_int_type(*--_M_gnext)
 : this->pbackfail();
 }

#line 256
protected:

#line 262
 virtual void imbue(const locale&);

#line 264
public:
 locale pubimbue(const locale&);
 locale getloc() const { return _M_locale; }

#line 269
 void stossc() { this->sbumpc(); }

#line 282
};

#line 313
 template<>
 class basic_streambuf<char, char_traits<char> >
{
 friend class basic_istream<char, char_traits<char> >;
 friend class basic_ostream<char, char_traits<char> >;
public:
 typedef char char_type;
 typedef char_traits<char>::int_type int_type;
 typedef char_traits<char>::pos_type pos_type;
 typedef char_traits<char>::off_type off_type;
 typedef char_traits<char> traits_type;

#line 325
private:

#line 327
 FILE* _M_get;
 FILE* _M_put;

#line 331
 _FILEX _M_default_get;
 _FILEX _M_default_put;

#line 338
 locale _M_locale;

#line 340
public:
 _STLP_mutex _M_lock;

#line 343
public:
 virtual ~basic_streambuf ();

#line 346
protected:

#line 349
 basic_streambuf ()
 : _M_get( reinterpret_cast<FILE*>(&_M_default_get) ),
 _M_put( reinterpret_cast<FILE*>(&_M_default_put) ), _M_locale()
 {

#line 354
 _FILE_I_set(_M_get, 0, 0, 0);
 _FILE_O_set(_M_put, 0, 0, 0);
 }

#line 359
 basic_streambuf (FILE* __get, FILE* __put);

#line 361
protected:
 char_type* eback() const { return _FILE_I_begin(_M_get); }
 char_type* gptr() const { return _FILE_I_next(_M_get); }
 char_type* egptr() const { return _FILE_I_end(_M_get); }
 void gbump(int __n) { _FILE_I_bump(_M_get, __n); }
 void setg(char_type* __gbegin, char_type* __gnext, char_type* __gend)
 { _FILE_I_set(_M_get, __gbegin, __gnext, __gend); }

#line 369
public:

#line 374
 char_type* _M_eback() const { return _FILE_I_begin(_M_get); }
 char_type* _M_gptr() const { return _FILE_I_next(_M_get); }
 char_type* _M_egptr() const { return _FILE_I_end(_M_get); }

#line 378
 void _M_gbump(int __n) { _FILE_I_bump(_M_get, __n); }
 void _M_setg(char_type* __gbegin, char_type* __gnext, char_type* __gend)
 { _FILE_I_set(_M_get, __gbegin, __gnext, __gend); }

#line 382
protected:
 char_type* pbase() const { return _FILE_O_begin(_M_put); }
 char_type* pptr() const { return _FILE_O_next(_M_put); }
 char_type* epptr() const { return _FILE_O_end(_M_put); }

#line 387
 void pbump(int __n) { _FILE_O_bump(_M_put, __n); }
 void setp(char_type* __pbegin, char_type* __pend)
 { _FILE_O_set(_M_put, __pbegin, __pbegin, __pend); }

#line 391
protected:
 virtual basic_streambuf<char, char_traits<char> >* setbuf(char_type*, streamsize);
 virtual pos_type seekoff(off_type, ios_base::seekdir,
 ios_base::openmode = ios_base::in | ios_base::out);
 virtual pos_type
 seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out);
 virtual int sync();

#line 399
public:
 basic_streambuf<char, char_traits<char> >* pubsetbuf(char_type* __s, streamsize __n)
 { return this->setbuf(__s, __n); }

#line 403
 pos_type pubseekoff(off_type __offset, ios_base::seekdir __way,
 ios_base::openmode __mod = ios_base::in | ios_base::out)
 { return this->seekoff(__offset, __way, __mod); }

#line 407
 pos_type pubseekpos(pos_type __sp,
 ios_base::openmode __mod = ios_base::in | ios_base::out)
 { return this->seekpos(__sp, __mod); }

#line 411
 int pubsync() { return this->sync(); }

#line 413
protected:
 virtual streamsize showmanyc();
 virtual streamsize xsgetn(char_type* __s, streamsize __n);
 virtual int_type underflow();
 virtual int_type uflow();
 virtual int_type pbackfail(int_type __c = traits_type::eof());

#line 420
protected:
 virtual streamsize xsputn(const char_type* __s, streamsize __n);
 virtual streamsize _M_xsputnc(char_type __c, streamsize __n);
 virtual int_type overflow(int_type = traits_type::eof());

#line 425
public:

#line 427
 int_type sputc(char_type __c) {
 int_type __res;
 if( _FILE_O_avail(_M_put) > 0 )
 {
 _FILE_O_postincr(_M_put) = __c;
 __res = traits_type::to_int_type(__c);
 }
 else
 __res = this->overflow(traits_type::to_int_type(__c));
 return __res;
 }

#line 440
 streamsize sputn(const char_type* __s, streamsize __n)
 { return this->xsputn(__s, __n); }

#line 444
 streamsize _M_sputnc(char_type __c, streamsize __n)
 { return this->_M_xsputnc(__c, __n); }

#line 447
private:
 int_type _M_snextc_aux();

#line 450
public:
 streamsize in_avail()
 { return _FILE_I_avail(_M_get) > 0 ? _FILE_I_avail(_M_get)
 : this->showmanyc(); }

#line 456
 int_type snextc() {
 return _FILE_I_avail(_M_get) > 1
 ? traits_type::to_int_type(_FILE_I_preincr(_M_get))
 : this->_M_snextc_aux();
 }

#line 463
 int_type sbumpc() {
 return _FILE_I_avail(_M_get) > 0
 ? traits_type::to_int_type(_FILE_I_postincr(_M_get))
 : this->uflow();
 }

#line 470
 int_type sgetc() {
 return _FILE_I_avail(_M_get) > 0
 ? traits_type::to_int_type(*_FILE_I_next(_M_get))
 : this->underflow();
 }

#line 476
 streamsize sgetn(char_type* __s, streamsize __n)
 { return this->xsgetn(__s, __n); }

#line 479
 int_type sputbackc(char_type __c) {
 return _FILE_I_begin(_M_get) < _FILE_I_next(_M_get) &&
 __c == *(_FILE_I_next(_M_get) - 1)
 ? traits_type::to_int_type(_FILE_I_predecr(_M_get))
 : this->pbackfail(traits_type::to_int_type(__c));
 }

#line 486
 int_type sungetc() {
 return _FILE_I_begin(_M_get) < _FILE_I_next(_M_get)
 ? traits_type::to_int_type(_FILE_I_predecr(_M_get))
 : this->pbackfail();
 }

#line 492
protected:
 virtual void imbue(const locale&);

#line 495
public:
 locale pubimbue(const locale&);
 locale getloc() const { return _M_locale; }

#line 500
public:
 void stossc() { this->sbumpc(); }

#line 516
};
 }
#line 1 "../../stlport/stl/_streambuf.c"


#line 27
 namespace _STL {

#line 31
 template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
 : _M_gbegin(0), _M_gnext(0), _M_gend(0),
 _M_pbegin(0), _M_pnext(0), _M_pend(0),
 _M_locale()
{

#line 38
}

#line 40
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{}

#line 45
template <class _CharT, class _Traits>
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc) {
 this->imbue(__loc);
 locale __tmp = _M_locale;
 _M_locale = __loc;
 return __tmp;
}

#line 54
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(_CharT* __s, streamsize __n)
{
 streamsize __result = 0;
 const int_type __eof = _Traits::eof();

#line 61
 while (__result < __n) {
 if (_M_gnext < _M_gend) {
 size_t __chunk = (min) ( static_cast<size_t>(_M_gend - _M_gnext) ,
 static_cast<size_t>(__n - __result) );
 _Traits::copy(__s, _M_gnext, __chunk);
 __result += __chunk;
 __s += __chunk;
 _M_gnext += __chunk;
 }
 else {
 int_type __c = this->sbumpc();
 if (!_Traits::eq_int_type(__c, __eof)) {
 *__s = __c;
 ++__result;
 ++__s;
 }
 else
 break;
 }
 }

#line 82
 return __result;
}

#line 85
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const _CharT* __s, streamsize __n)
{
 streamsize __result = 0;
 const int_type __eof = _Traits::eof();

#line 92
 while (__result < __n) {
 if (_M_pnext < _M_pend) {
 size_t __chunk = (min) ( static_cast<size_t>(_M_pend - _M_pnext) ,
 static_cast<size_t>(__n - __result) );
 _Traits::copy(_M_pnext, __s, __chunk);
 __result += __chunk;
 __s += __chunk;
 _M_pnext += __chunk;
 }

#line 102
 else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(*__s)),
 __eof)) {
 ++__result;
 ++__s;
 }
 else
 break;
 }
 return __result;
}

#line 113
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::_M_xsputnc(_CharT __c, streamsize __n)
{
 streamsize __result = 0;
 const int_type __eof = _Traits::eof();

#line 120
 while (__result < __n) {
 if (_M_pnext < _M_pend) {
 size_t __chunk = (min) ( static_cast<size_t>(_M_pend - _M_pnext) ,
 static_cast<size_t>(__n - __result) );
 _Traits::assign(_M_pnext, __chunk, __c);
 __result += __chunk;
 _M_pnext += __chunk;
 }

#line 129
 else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(__c)),
 __eof))
 ++__result;
 else
 break;
 }
 return __result;
}

#line 138
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::_M_snextc_aux()
{
 int_type __eof = _Traits::eof();
 if (_M_gend == _M_gnext)
 return _Traits::eq_int_type(this->uflow(), __eof) ? __eof : this->sgetc();
 else {
 _M_gnext = _M_gend;
 return this->underflow();
 }
}

#line 151
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type) {
 return _Traits::eof();
}

#line 157
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type) {
 return _Traits::eof();
}

#line 163
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow() {
 return ( _Traits::eq_int_type(this->underflow(),_Traits::eof()) ?
 _Traits::eof() :
 _Traits::to_int_type(*_M_gnext++));
}

#line 171
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{ return _Traits::eof(); }

#line 176
template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{ return 0; }

#line 181
template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&) {}

#line 185
template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync() { return 0; }

#line 189
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{ return pos_type(-1); }

#line 194
template <class _CharT, class _Traits>
 typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
 ios_base::openmode)
{ return pos_type(-1); }

#line 200
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>:: setbuf(char_type*, streamsize)
{ return this; }

#line 212
 }
#line 521 "../../stlport/stl/_streambuf.h"

#line 29 "../../stlport/stl/_ios.c"


#line 35
 namespace _STL {

#line 40
 template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>
 ::basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf)
 : ios_base(),
 _M_fill( _CharT() ), _M_streambuf(0), _M_tied_ostream(0)
{
 init(__streambuf);
}

#line 49
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __buf)
{
 basic_streambuf<_CharT, _Traits>* __tmp = _M_streambuf;
 _M_streambuf = __buf;
 this->clear();
 return __tmp;
}

#line 59
template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits>& __x)
{
 _M_invoke_callbacks(erase_event);
 _M_copy_state(__x);
 _M_fill = __x._M_fill;
 _M_tied_ostream = __x._M_tied_ostream;
 _M_invoke_callbacks(copyfmt_event);
 this->_M_set_exception_mask(__x.exceptions());
 return *this;
}

#line 72
template <class _CharT, class _Traits>
locale basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
 locale __tmp = ios_base::imbue(__loc);

#line 77
 if (_M_streambuf)
 _M_streambuf->pubimbue(__loc);

#line 81
 this->_M_cached_ctype = __loc._M_get_facet(ctype<char_type>::id) ;
 this->_M_cached_numpunct = __loc._M_get_facet(numpunct<char_type>::id) ;
 this->_M_cached_grouping = ((numpunct<char_type>*)_M_cached_numpunct)->grouping() ;
 return __tmp;
}

#line 91
template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::basic_ios()
 : ios_base(),
 _M_fill( _CharT() ), _M_streambuf(0), _M_tied_ostream(0)
{}

#line 97
template <class _CharT, class _Traits>
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
{
 this->rdbuf(__sb);
 this->imbue(locale());
 this->tie(0);
 this->_M_set_exception_mask(ios_base::goodbit);
 this->_M_clear_nothrow(__sb != 0 ? ios_base::goodbit : ios_base::badbit);
 ios_base::flags(ios_base::skipws | ios_base::dec);
 ios_base::width(0);
 ios_base::precision(6);
 this->fill(widen(' '));

#line 112
}

#line 115
template <class _CharT, class _Traits>
void basic_ios<_CharT, _Traits>::_M_handle_exception(ios_base::iostate __flag)
{
 this->_M_setstate_nothrow(__flag);
 if (this->_M_get_exception_mask() & __flag)
 throw ;
}

#line 123
 }
#line 173 "../../stlport/stl/_ios.h"

#line 28 "../../stlport/stl/_istream.h"

#line 1 "../../stlport/stl/_ostream.h"

#line 1 "../../stlport/stl/_ostreambuf_iterator.h"


#line 30
 namespace _STL {

#line 32
 template <class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* _M_get_ostreambuf(basic_ostream<_CharT, _Traits>& ) ;

#line 36
template<class _CharT, class _Traits>
class ostreambuf_iterator
{
public:
 typedef _CharT char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef basic_streambuf<_CharT, _Traits> streambuf_type;
 typedef basic_ostream<_CharT, _Traits> ostream_type;

#line 46
 typedef output_iterator_tag iterator_category;
 typedef void value_type;
 typedef void difference_type;
 typedef void pointer;
 typedef void reference;

#line 52
public:
 ostreambuf_iterator(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf!=0) {}

#line 55
 inline ostreambuf_iterator(ostream_type& __o) ;

#line 57
 ostreambuf_iterator<_CharT, _Traits>& operator=(char_type __c) {
 _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),
 traits_type::eof());
 return *this;
 }

#line 63
 ostreambuf_iterator<_CharT, _Traits>& operator*() { return *this; }
 ostreambuf_iterator<_CharT, _Traits>& operator++() { return *this; }
 ostreambuf_iterator<_CharT, _Traits>& operator++(int) { return *this; }

#line 67
 bool failed() const { return !_M_ok; }

#line 69
private:
 streambuf_type* _M_buf;
 bool _M_ok;
};

#line 74
template <class _CharT, class _Traits>
inline ostreambuf_iterator<_CharT, _Traits>::ostreambuf_iterator(basic_ostream<_CharT, _Traits>& __o) : _M_buf(_M_get_ostreambuf(__o)), _M_ok(_M_buf != 0) {}

#line 90
 }
#line 29 "../../stlport/stl/_ostream.h"


#line 31
 namespace _STL {

#line 33
 template <class _CharT, class _Traits, class _Number>
basic_ostream<_CharT, _Traits>&
_M_put_num(basic_ostream<_CharT, _Traits>& __os, _Number __x);

#line 42
template <class _CharT, class _Traits>
bool
_M_init(basic_ostream<_CharT, _Traits>& __str);

#line 49
template <class _CharT, class _Traits>
class basic_ostream : virtual public basic_ios<_CharT, _Traits>
{
 typedef basic_ostream<_CharT, _Traits> _Self;

#line 54
public:
 typedef _CharT char_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;
 typedef _Traits traits_type;
 typedef basic_ios<_CharT, _Traits> _Basic_ios;

#line 62
public:
 explicit basic_ostream(basic_streambuf<_CharT, _Traits>* __buf);
 ~basic_ostream();

#line 66
public:
 typedef basic_ios<_CharT, _Traits>& ( *__ios_fn)(basic_ios<_CharT, _Traits>&);
 typedef ios_base& ( *__ios_base_fn)(ios_base&);
 typedef _Self& ( *__ostream_fn)(_Self&);
 _Self& operator<< (__ostream_fn __f) { return __f(*this); }
 _Self & operator<< (__ios_base_fn __f) { __f(*this); return *this; }
 _Self& operator<< (__ios_fn __ff) { __ff(*this); return *this; }

#line 74
private:
 bool _M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
 basic_streambuf<_CharT, _Traits>* __to);
 bool _M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
 basic_streambuf<_CharT, _Traits>* __to);

#line 80
public:
 void _M_put_char(_CharT __c);

#line 83
 void _M_put_nowiden(const _CharT* __s);
 void _M_put_widen(const char* __s);
 bool _M_put_widen_aux(const char* __s, streamsize __n);

#line 87
public:
 _Self& put(char_type __c);
 _Self& write(const char_type* __s, streamsize __n);

#line 91
public:

#line 93
 _Self& operator<<(basic_streambuf<_CharT, _Traits>* __buf);

#line 96
 _Self& operator<<(unsigned char __x) { _M_put_char(__x); return *this; }

#line 98
 _Self& operator<<(short __x) { return _M_put_num(*this, static_cast<long>(__x) ); }
 _Self& operator<<(unsigned short __x) { return _M_put_num(*this, static_cast<unsigned long>(__x) ); }
 _Self& operator<<(int __x) { return _M_put_num(*this, static_cast<long>(__x) ); }
 _Self& operator<<(unsigned int __x) { return _M_put_num(*this, static_cast<unsigned long>(__x) ); }
 _Self& operator<<(long __x) { return _M_put_num(*this, __x); }
 _Self& operator<<(unsigned long __x) { return _M_put_num(*this, __x); }

#line 105
 _Self& operator<< ( long long __x) { return _M_put_num(*this, __x); }
 _Self& operator<< (unsigned long long __x) { return _M_put_num(*this, __x); }

#line 108
 _Self& operator<<(float __x)
 { return _M_put_num(*this, static_cast<double>(__x) ); }
 _Self& operator<<(double __x) { return _M_put_num(*this, __x); }

#line 112
 _Self& operator<<(long double __x) { return _M_put_num(*this, __x); }

#line 114
 _Self& operator<<(const void* __x) { return _M_put_num(*this, __x); }

#line 116
 _Self& operator<<(bool __x) { return _M_put_num(*this, __x); }

#line 119
public:
 _Self& flush() {
 if (this->rdbuf())
 if (this->rdbuf()->pubsync() == -1)
 this->setstate(ios_base::badbit);
 return *this;
 }

#line 127
 pos_type tellp() {
 return this->rdbuf() && !this->fail()
 ? this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out)
 : pos_type(-1);
 }

#line 133
 _Self& seekp(pos_type __pos) {
 if (this->rdbuf() && !this->fail())
 this->rdbuf()->pubseekpos(__pos, ios_base::out);
 return *this;
 }

#line 139
 _Self& seekp(off_type __off, ios_base::seekdir __dir) {
 if (this->rdbuf() && !this->fail())
 this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
 return *this;
 }

#line 155
 class sentry {
 typedef sentry _Self;

#line 158
 private:
 basic_ostream<_CharT, _Traits>& _M_str;

#line 161
 bool _M_ok;
 public:
 explicit sentry(basic_ostream<_CharT, _Traits>& __str)
 : _M_str(__str), _M_ok(_M_init(__str))
 {
 }

#line 168
 ~sentry() {
 if (_M_str.flags() & ios_base::unitbuf)

#line 173
 _M_str.flush();
 }

#line 176
 operator bool() const { return _M_ok; }
 private:
 sentry(const _Self& __s) : _M_str (__s._M_str) {};
 void operator=(const _Self&) {};
 };

#line 185
};

#line 197
template <class _CharT, class _Traits>
inline basic_streambuf<_CharT, _Traits>*
_M_get_ostreambuf(basic_ostream<_CharT, _Traits>& __St)
{
 return __St.rdbuf();
}

#line 206
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c) {
 __os._M_put_char(__c);
 return __os;
}

#line 213
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __s) {
 __os._M_put_nowiden(__s);
 return __os;
}

#line 262
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __c) {
 __os._M_put_char(__os.widen(__c));
 return __os;
}

#line 269
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c) {
 __os._M_put_char(__c);
 return __os;
}

#line 276
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c) {
 __os._M_put_char(__c);
 return __os;
}

#line 283
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c) {
 __os._M_put_char(__c);
 return __os;
}

#line 290
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __s) {
 __os._M_put_widen(__s);
 return __os;
}

#line 297
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __s) {
 __os._M_put_nowiden(__s);
 return __os;
}

#line 304
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __s) {
 __os._M_put_nowiden( reinterpret_cast<const char*>(__s) );
 return __os;
}

#line 311
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __s) {
 __os._M_put_nowiden( reinterpret_cast<const char*>(__s) );
 return __os;
}

#line 322
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os) {
 __os.put(__os.widen('\n'));
 __os.flush();
 return __os;
}

#line 330
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os) {
 __os.put( _CharT() );
 return __os;
}

#line 337
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os) {
 __os.flush();
 return __os;
}

#line 344
 }
#line 1 "../../stlport/stl/_ostream.c"

#line 1 "../../stlport/stl/_num_put.h"


#line 36
 namespace _STL {

#line 44
 template <class _CharT, class _OutputIter = ostreambuf_iterator<_CharT, char_traits<_CharT> > >

#line 46
class num_put: public locale::facet
{
 friend class _Locale;
public:
 typedef _CharT char_type;
 typedef _OutputIter iter_type;

#line 53
 explicit num_put(size_t __refs = 0) : locale::facet (__refs) {}

#line 56
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 bool __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 61
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 long __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 66
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 unsigned long __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 72
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 long long __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 77
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 unsigned long long __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 83
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 double __val) const {
 return do_put(__s, __f, __fill, (double)__val);
 }

#line 89
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 long double __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 95
 iter_type put(iter_type __s, ios_base& __f, char_type __fill,
 const void * __val) const {
 return do_put(__s, __f, __fill, __val);
 }

#line 100
 static locale::id id;

#line 102
protected:
 ~num_put() {}

#line 105
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, bool __val) const;

#line 107
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long __val) const;
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, unsigned long __val) const;
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, double __val) const;

#line 111
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long double __val) const;

#line 115
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long long __val) const;
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 unsigned long long __val) const ;

#line 119
 virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, const void* __val) const;
};

#line 133
template <class _Integer>
char*
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x);

#line 137
void __string_to_float(const string&, float&);
void __string_to_float(const string&, double&);
extern char* __write_float(char*, ios_base::fmtflags, int, double);

#line 141
void __string_to_float(const string&, long double&);
extern char* __write_float(char*, ios_base::fmtflags, int, long double);

#line 146
extern wchar_t* __convert_float_buffer(const char*, const char*, wchar_t*, const ctype<wchar_t>&, wchar_t);

#line 148
extern void __adjust_float_buffer(char*, char*, char);

#line 150
extern char*
__write_integer(char* buf, ios_base::fmtflags flags, long x);

#line 153
extern ptrdiff_t __insert_grouping(char* first, char* last, const string&, char, char, char, int);

#line 155
extern ptrdiff_t __insert_grouping(wchar_t*, wchar_t*, const string&, wchar_t, wchar_t, wchar_t, int);

#line 175
 }
#line 1 "../../stlport/stl/_num_put.c"

#line 1 "../../stlport/stl/_limits.h"

#line 1 "/opt/aCC/include/cfloat"

#line 1 "/usr/include/float.h"

#line 5 "/opt/aCC/include/cfloat"

#line 33 "../../stlport/stl/_limits.h"


#line 39
 namespace _STL {

#line 41
 enum float_round_style {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3
};

#line 49
enum float_denorm_style {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1
};

#line 57
template <class __number>
class _Numeric_limits_base {
public:

#line 61
 static __number ( min)() { return __number(); }
 static __number ( max)() { return __number(); }

#line 67
 static const int

#line 70
 digits = 0,
 digits10 = 0,
 radix = 0,
 min_exponent = 0,
 min_exponent10 = 0,
 max_exponent = 0,
 max_exponent10 = 0

#line 83
 ;
 static const float_denorm_style has_denorm = denorm_absent;
 static const float_round_style round_style = round_toward_zero;
 static const bool

#line 89
 is_specialized = false,
 is_signed = false,
 is_integer = false,
 is_exact = false,
 has_infinity = false,
 has_quiet_NaN = false,
 has_signaling_NaN = false,
 has_denorm_loss = false,
 is_iec559 = false,
 is_bounded = false,
 is_modulo = false,
 traps = false,
 tinyness_before = false

#line 105
 ;

#line 107
 static __number epsilon() { return __number(); }
 static __number round_error() { return __number(); }

#line 110
 static __number infinity() { return __number(); }
 static __number quiet_NaN() { return __number(); }
 static __number signaling_NaN() { return __number(); }
 static __number denorm_min() { return __number(); }

#line 116
};

#line 133
template <class _Int,
 _Int __imin,
 _Int __imax,
 int __idigits, bool __ismod>
class _Integer_limits : public _Numeric_limits_base<_Int>
{
public:

#line 141
 static _Int ( min) () { return (_Int)__imin; }
 static _Int ( max) () { return (_Int)__imax; }

#line 147
 static const int

#line 149
 digits = (__idigits < 0) ?
 ((int)((sizeof(_Int) * ( 8 ))) - ((__imin == 0) ? 0 : 1))
 : (__idigits),
 digits10 = (digits * 301UL) / 1000,
 radix = 2

#line 155
 ;
 static const bool

#line 160
 is_specialized = true,
 is_signed = (__imin != 0),
 is_integer = true,
 is_exact = true,
 is_bounded = true,
 is_modulo = __ismod

#line 169
 ;
};

#line 173
template <class __number,
 int __Digits, int __Digits10,
 int __MinExp, int __MaxExp,
 int __MinExp10, int __MaxExp10,
 bool __IsIEC559,
 float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number>
{
public:

#line 186
 static const int

#line 189
 digits = __Digits,
 digits10 = __Digits10,

#line 192
 radix = ( 2 ),
 min_exponent = __MinExp,
 max_exponent = __MaxExp,
 min_exponent10 = __MinExp10,
 max_exponent10 = __MaxExp10

#line 203
 ;
 static const float_denorm_style has_denorm = denorm_indeterminate;
 static const float_round_style round_style = __RoundStyle;
 static const bool

#line 209
 is_specialized = true,
 is_signed = true,

#line 213
 has_infinity = true,
 has_quiet_NaN = true,
 has_signaling_NaN= true,

#line 222
 has_denorm_loss = false,
 is_iec559 = __IsIEC559,
 is_bounded = true,
 traps = true,
 tinyness_before= false

#line 231
 ;

#line 233
};

#line 239
template<class _Tp>
class numeric_limits : public _Numeric_limits_base<_Tp> {};

#line 246
 template<>
 class numeric_limits<bool>
 : public _Integer_limits<bool, false, true, 1, false>
{};

#line 253
 template<>
 class numeric_limits<char>
 : public _Integer_limits<char, (-128) , 127 , -1, true>
{};

#line 259
 template<>
 class numeric_limits<signed char>
 : public _Integer_limits<signed char, (-128) , 127 , -1, true>
{};

#line 265
 template<>
 class numeric_limits<unsigned char>
 : public _Integer_limits<unsigned char, 0, 0377 , -1, true>
{};

#line 272
 template<>
 class numeric_limits<wchar_t>
 : public _Integer_limits<wchar_t, 0 , -1U , -1, true>
{};

#line 279
 template<>
 class numeric_limits<short>
 : public _Integer_limits<short, (-32768) , 32767 , -1, true>
{};

#line 284
 template<>
 class numeric_limits<unsigned short>
 : public _Integer_limits<unsigned short, 0, 0177777 , -1, true>
{};

#line 295
 template<>
 class numeric_limits<int>
 : public _Integer_limits<int, (-2147483647 - 1) , 2147483647 , -1, true>
{};

#line 300
 template<>
 class numeric_limits<unsigned int>
 : public _Integer_limits<unsigned int, 0, 4294967295U , -1, true>
{};

#line 305
 template<>
 class numeric_limits<long>
 : public _Integer_limits<long, (-2147483647L - 1) , 2147483647L , -1, true>
{};

#line 310
 template<>
 class numeric_limits<unsigned long>
 : public _Integer_limits<unsigned long, 0, 4294967295UL , -1, true>
{};

#line 339
 template<>
 class numeric_limits< long long >
 : public _Integer_limits< long long , (- 0x7fffffffffffffffLL-1LL) , 0x7fffffffffffffffLL , -1, true>
{};

#line 344
 template<>
 class numeric_limits<unsigned long long >
 : public _Integer_limits<unsigned long long , 0, 0xffffffffffffffffULL , -1, true>
{};

#line 433
union _F_rep
{
 unsigned short rep[2];
 float val;
};
union _D_rep
{
 unsigned short rep[4];
 double val;
};

#line 445
union _L_rep
{
 unsigned short rep[8];
 long double val;
};

#line 452
template <class __dummy>
class _LimG
{
public:
 static const _F_rep _F_inf;
 static const _F_rep _F_qNaN;
 static const _F_rep _F_sNaN;
 static const _D_rep _D_inf;
 static const _D_rep _D_qNaN;
 static const _D_rep _D_sNaN;

#line 464
 static const _L_rep _L_inf;
 static const _L_rep _L_qNaN;
 static const _L_rep _L_sNaN;

#line 468
};

#line 474
 template<> class numeric_limits<float>
 : public _Floating_limits<float,
 24 ,
 6 ,
 (-125) ,
 128 ,
 (-37) ,
 38 ,
 true,
 round_to_nearest>
{
public:
 static float ( min) () { return ((float)1.17549435e-38) ; }
 static float denorm_min() { return ((float)1.17549435e-38) ; }
 static float ( max) () { return ((float)3.40282347e+38) ; }
 static float epsilon() { return ((float)1.19209290E-07) ; }
 static float round_error() { return 0.5f; }
 static float infinity() { return _LimG<bool>::_F_inf.val; }
 static float quiet_NaN() { return _LimG<bool>::_F_qNaN.val; }
 static float signaling_NaN() { return _LimG<bool>::_F_sNaN.val; }
};

#line 496
 template<> class numeric_limits<double>
 : public _Floating_limits<double,
 53 ,
 15 ,
 (-1021) ,
 1024 ,
 (-307) ,
 308 ,
 true,
 round_to_nearest>
{
public:
 static double ( min)() { return 2.2250738585072014e-308 ; }
 static double denorm_min() { return 2.2250738585072014e-308 ; }
 static double ( max)() { return 1.7976931348623157e+308 ; }
 static double epsilon() { return 2.2204460492503131E-16 ; }
 static double round_error() { return 0.5; }
 static double infinity() { return _LimG<bool>::_D_inf.val; }
 static double quiet_NaN(){ return _LimG<bool>::_D_qNaN.val; }
 static double signaling_NaN() { return _LimG<bool>::_D_sNaN.val; }
};

#line 520
 template<>
 class numeric_limits<long double>
 : public _Floating_limits<long double,
 113 ,
 33 ,
 (-16381) ,
 16384 ,
 (-4931) ,
 4932 ,
 false,
 round_to_nearest>
{
public:
 static long double ( min) () { return 3.3621031431120935062626778173217526026E-4932L ; }
 static long double denorm_min() { return 3.3621031431120935062626778173217526026E-4932L ; }
 static long double ( max) () { return 1.1897314953572317650857593266280070162E4932L ; }
 static long double epsilon() { return 1.9259299443872358530559779425849273E-34L ; }
 static long double round_error() { return 4; }
 static long double infinity() { return _LimG<bool>::_L_inf.val; }
 static long double quiet_NaN() { return _LimG<bool>::_L_qNaN.val; }
 static long double signaling_NaN() { return _LimG<bool>::_L_sNaN.val; }
};

#line 547
 }
#line 1 "../../stlport/stl/_limits.c"


#line 30
 namespace _STL {

#line 38
 template <class __number> const bool _Numeric_limits_base<__number>:: is_specialized ;
 template <class __number> const int _Numeric_limits_base<__number>:: digits ;
 template <class __number> const int _Numeric_limits_base<__number>:: digits10 ;
 template <class __number> const bool _Numeric_limits_base<__number>:: is_signed ;
 template <class __number> const bool _Numeric_limits_base<__number>:: is_integer ;
 template <class __number> const bool _Numeric_limits_base<__number>:: is_exact ;
 template <class __number> const int _Numeric_limits_base<__number>:: radix ;
 template <class __number> const int _Numeric_limits_base<__number>:: min_exponent ;
 template <class __number> const int _Numeric_limits_base<__number>:: max_exponent ;
 template <class __number> const int _Numeric_limits_base<__number>:: min_exponent10 ;
 template <class __number> const int _Numeric_limits_base<__number>:: max_exponent10 ;
 template <class __number> const bool _Numeric_limits_base<__number>:: has_infinity ;
 template <class __number> const bool _Numeric_limits_base<__number>:: has_quiet_NaN ;
 template <class __number> const bool _Numeric_limits_base<__number>:: has_signaling_NaN ;
 template <class __number> const float_denorm_style _Numeric_limits_base<__number>:: has_denorm ;
 template <class __number> const bool _Numeric_limits_base<__number>:: has_denorm_loss ;
 template <class __number> const bool _Numeric_limits_base<__number>:: is_iec559 ;
 template <class __number> const bool _Numeric_limits_base<__number>:: is_bounded ;
 template <class __number> const bool _Numeric_limits_base<__number>:: is_modulo ;
 template <class __number> const bool _Numeric_limits_base<__number>:: traps ;
 template <class __number> const bool _Numeric_limits_base<__number>:: tinyness_before ;
 template <class __number> const float_round_style _Numeric_limits_base<__number>:: round_style ;

#line 67
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_specialized ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits10 ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_signed ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_integer ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_exact ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: radix ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_bounded ;
 template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_modulo ;

#line 91
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_specialized ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: digits ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: digits10 ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_signed ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: radix ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: min_exponent ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: max_exponent ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: min_exponent10 ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: max_exponent10 ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_infinity ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_quiet_NaN ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_signaling_NaN ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const float_denorm_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_denorm ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_denorm_loss ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_iec559 ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_bounded ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: traps ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: tinyness_before ;
 template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const float_round_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: round_style ;

#line 290
 }
#line 551 "../../stlport/stl/_limits.h"

#line 29 "../../stlport/stl/_num_put.c"


#line 31
 namespace _STL {

#line 37
 template <class _CharT, class _OutputIter,class _Float>
_OutputIter
_M_do_put_float(_OutputIter __s, ios_base& __f, _CharT __fill,_Float __x);

#line 45
template <class _CharT, class _OutputIter>
_OutputIter
__copy_float_and_fill(const _CharT* __first, const _CharT* __last,
 _OutputIter __out,
 ios_base::fmtflags __flags,
 streamsize __width, _CharT __fill,
 _CharT __xplus, _CharT __xminus) {
 if (__width <= __last - __first)
 return copy(__first, __last, __out);
 else {
 streamsize __pad = __width - (__last - __first);
 ios_base::fmtflags __dir = __flags & ios_base::adjustfield;

#line 58
 if (__dir == ios_base::left) {
 __out = copy(__first, __last, __out);
 return fill_n(__out, __pad, __fill);
 }
 else if (__dir == ios_base::internal && __first != __last &&
 (*__first == __xplus || *__first == __xminus)) {
 *__out++ = *__first++;
 __out = fill_n(__out, __pad, __fill);
 return copy(__first, __last, __out);
 }
 else {
 __out = fill_n(__out, __pad, __fill);
 return copy(__first, __last, __out);
 }
 }
}

#line 77
template <class _OutputIter>
_OutputIter
__put_float(char* __ibuf, char* __iend, _OutputIter __out,
 ios_base& __f, wchar_t __fill,
 wchar_t __decimal_point,
 wchar_t __sep, const string& __grouping)
{
 const ctype<wchar_t>& __ct = *(ctype<wchar_t>*)__f._M_ctype_facet() ;

#line 86
 wchar_t __wbuf[128];
 wchar_t* __eend = __convert_float_buffer(__ibuf, __iend, __wbuf,
 __ct, __decimal_point);
 if (__grouping.size() != 0) {

#line 95
 string __new_grouping = __grouping;
 wchar_t* __decimal_pos = find(__wbuf, __eend, __decimal_point);
 if (__grouping.size() == 1)
 __new_grouping.push_back(__grouping[0]);

#line 102
 __new_grouping[0] += static_cast<char>(__eend - __decimal_pos) ;
 ptrdiff_t __len = __insert_grouping(__wbuf, __eend, __new_grouping,
 __sep,
 __ct.widen('+'), __ct.widen('-'),
 0);
 __eend = __wbuf + __len;
 }

#line 110
 return __copy_float_and_fill(__wbuf, __eend, __out,
 __f.flags(), __f.width(0), __fill,
 __ct.widen('+'), __ct.widen('-'));
}

#line 117
template <class _OutputIter>
_OutputIter
__put_float(char* __ibuf, char* __iend, _OutputIter __out,
 ios_base& __f, char __fill,
 char __decimal_point,
 char __sep, const string& __grouping)
{
 __adjust_float_buffer(__ibuf, __iend, __decimal_point);
 if (__grouping.size() != 0) {
 string __new_grouping = __grouping;
 const char * __decimal_pos = find(__ibuf, __iend, __decimal_point);
 if (__grouping.size() == 1)
 __new_grouping.push_back(__grouping[0]);
 __new_grouping[0] += static_cast<char>((__iend - __decimal_pos)) ;
 ptrdiff_t __len = __insert_grouping(__ibuf, __iend, __new_grouping,
 __sep, '+', '-', 0);
 __iend = __ibuf + __len;
 }

#line 136
 return __copy_float_and_fill(__ibuf, __iend, __out,
 __f.flags(), __f.width(0), __fill, '+', '-');
}

#line 140
template <class _CharT, class _OutputIter, class _Float>
_OutputIter
_M_do_put_float(_OutputIter __s, ios_base& __f,
 _CharT __fill, _Float __x)
{
 char __buf[128];
 char* __iend = __write_float(__buf, __f.flags(), (int)__f.precision(), __x);

#line 149
 const numpunct<_CharT>& __np = *(const numpunct<_CharT>*)__f._M_numpunct_facet();

#line 151
 return __put_float(__buf, __iend, __s, __f, __fill,
 __np.decimal_point(),
 __np.thousands_sep(), __f._M_grouping());
}

#line 158
template <class _CharT, class _OutputIter>
_OutputIter
__copy_integer_and_fill(const _CharT* __buf, ptrdiff_t __len,
 _OutputIter __out,
 ios_base::fmtflags __flg, streamsize __wid, _CharT __fill,
 _CharT __xplus, _CharT __xminus)
{
 if (__len >= __wid)
 return copy(__buf, __buf + __len, __out);
 else {
 ptrdiff_t __pad = __wid - __len;
 ios_base::fmtflags __dir = __flg & ios_base::adjustfield;

#line 171
 if (__dir == ios_base::left) {
 __out = copy(__buf, __buf + __len, __out);
 return fill_n(__out, __pad, __fill);
 }
 else if (__dir == ios_base::internal && __len != 0 &&
 (__buf[0] == __xplus || __buf[0] == __xminus)) {
 *__out++ = __buf[0];
 __out = fill_n(__out, __pad, __fill);
 return copy(__buf + 1, __buf + __len, __out);
 }
 else if (__dir == ios_base::internal && __len >= 2 &&
 (__flg & ios_base::showbase) &&
 (__flg & ios_base::basefield) == ios_base::hex) {
 *__out++ = __buf[0];
 *__out++ = __buf[1];
 __out = fill_n(__out, __pad, __fill);
 return copy(__buf + 2, __buf + __len, __out);
 }
 else {
 __out = fill_n(__out, __pad, __fill);
 return copy(__buf, __buf + __len, __out);
 }
 }
}

#line 198
template <class _OutputIter>
_OutputIter
__put_integer(char* __buf, char* __iend, _OutputIter __s,
 ios_base& __f,
 ios_base::fmtflags __flags, wchar_t __fill)
{
 locale __loc = __f.getloc();

#line 206
 const ctype<wchar_t>& __ct = *(const ctype<wchar_t>*)__f._M_ctype_facet();

#line 208
 wchar_t __xplus = __ct.widen('+');
 wchar_t __xminus = __ct.widen('-');

#line 211
 wchar_t __wbuf[64];
 __ct.widen(__buf, __iend, __wbuf);
 ptrdiff_t __len = __iend - __buf;
 wchar_t* __eend = __wbuf + __len;

#line 219
 const numpunct<wchar_t>& __np = *(const numpunct<wchar_t>*)__f._M_numpunct_facet();
 const string& __grouping = __f._M_grouping();

#line 222
 if (!__grouping.empty()) {
 int __basechars;
 if (__flags & ios_base::showbase)
 switch (__flags & ios_base::basefield) {
 case ios_base::hex: __basechars = 2; break;
 case ios_base::oct: __basechars = 1; break;
 default: __basechars = 0;
 }
 else
 __basechars = 0;

#line 233
 __len = __insert_grouping(__wbuf, __eend, __grouping, __np.thousands_sep(),
 __xplus, __xminus, __basechars);
 }

#line 237
 return __copy_integer_and_fill((wchar_t*)__wbuf, __len, __s,
 __flags, __f.width(0), __fill, __xplus, __xminus);
}

#line 243
template <class _OutputIter>
_OutputIter
__put_integer(char* __buf, char* __iend, _OutputIter __s,
 ios_base& __f, ios_base::fmtflags __flags, char __fill)
{
 ptrdiff_t __len = __iend - __buf;

#line 253
 const numpunct<char>& __np = *(const numpunct<char>*)__f._M_numpunct_facet();
 const string& __grouping = __f._M_grouping();

#line 256
 if (!__grouping.empty()) {
 int __basechars;
 if (__flags & ios_base::showbase)
 switch (__flags & ios_base::basefield) {
 case ios_base::hex: __basechars = 2; break;
 case ios_base::oct: __basechars = 1; break;
 default: __basechars = 0;
 }
 else
 __basechars = 0;

#line 269
 char __grpbuf[64];
 copy(__buf, __iend, (char *) __grpbuf);
 __buf = __grpbuf;
 __iend = __grpbuf + __len;
 __len = __insert_grouping(__buf, __iend, __grouping, __np.thousands_sep(),
 '+', '-', __basechars);
 }

#line 277
 return __copy_integer_and_fill(__buf, __len, __s, __flags, __f.width(0), __fill, '+', '-');
}

#line 281
typedef long long __max_int_t;
typedef unsigned long long __umax_int_t;

#line 288
extern const char __hex_char_table_lo[];
extern const char __hex_char_table_hi[];

#line 291
template <class _Integer>
inline char*
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __true_type& )
{
 __max_int_t __temp = __x;

#line 297
 const bool __negative = __x < 0 ;

#line 299
 if (__negative) __temp = -__temp;

#line 301
 for (; __temp != 0; __temp /= 10)
 *--__ptr = (int)(__temp % 10) + '0';

#line 304
 if (__negative)
 *--__ptr = '-';
 else if (__flags & ios_base::showpos)
 *--__ptr = '+';
 return __ptr;
}

#line 311
template <class _Integer>
inline char*
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags, const __false_type& )
{
 for (; __x != 0; __x /= 10)
 *--__ptr = (int)(__x % 10) + '0';
 return __ptr;
}

#line 320
template <class _Integer>
char*
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x)
{
 char* __ptr = __buf;
 __umax_int_t __temp;

#line 327
 if (__x == 0) {
 *--__ptr = '0';
 if ((__flags & ios_base::showpos) && ( (__flags & (ios_base::hex | ios_base::oct)) == 0 ))
 *--__ptr = '+';
 }
 else {

#line 334
 switch (__flags & ios_base::basefield) {
 case ios_base::oct:
 __temp = __x;

#line 338
 if ( sizeof(__x) < 8 && sizeof(__umax_int_t) >= 8 )
 __temp &= 0xFFFFFFFF;

#line 341
 for (; __temp != 0; __temp >>=3)
 *--__ptr = (((unsigned)__temp)& 0x7) + '0';

#line 345
 if (__flags & ios_base::showbase)
 *--__ptr = '0';
 break;
 case ios_base::hex:
 {
 const char* __table_ptr = (__flags & ios_base::uppercase) ?
 __hex_char_table_hi : __hex_char_table_lo;
 __temp = __x;

#line 354
 if ( sizeof(__x) < 8 && sizeof(__umax_int_t) >= 8 )
 __temp &= 0xFFFFFFFF;

#line 357
 for (; __temp != 0; __temp >>=4)
 *--__ptr = __table_ptr[((unsigned)__temp & 0xF)];

#line 360
 if (__flags & ios_base::showbase) {
 *--__ptr = __table_ptr[16];
 *--__ptr = '0';
 }
 }
 break;
 default:
 {

#line 375
 typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;
 __ptr = __write_decimal_backward(__ptr, __x, __flags, _IsSigned());

#line 378
 }
 break;
 }
 }

#line 383
 return __ptr;
}

#line 392
template <class _CharT, class _OutputIterator>
locale::id num_put<_CharT, _OutputIterator>::id;

#line 422
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f,
 char_type __fill, bool __val) const {
 if (!(__f.flags() & ios_base::boolalpha))
 return this->do_put(__s, __f, __fill, static_cast<long>(__val) );

#line 429
 locale __loc = __f.getloc();

#line 433
 const numpunct<_CharT>& __np = *(const numpunct<_CharT>*)__f._M_numpunct_facet();

#line 435
 basic_string<_CharT> __str = __val ? __np.truename() : __np.falsename();

#line 440
 ios_base::fmtflags __flags = __f.flags();
 if ((__flags & ios_base::adjustfield) == ios_base::internal)
 __flags = (__flags & ~ios_base::adjustfield) | ios_base::right;

#line 444
 return __copy_integer_and_fill(__str.c_str(), __str.size(), __s,
 __flags, __f.width(0), __fill,
 (_CharT) 0, (_CharT) 0);
}

#line 451
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 long __val) const {

#line 456
 char __buf[64];

#line 458
 ios_base::fmtflags __flags = __f.flags();
 char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
 return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}

#line 464
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 unsigned long __val) const {
 char __buf[64];

#line 471
 ios_base::fmtflags __flags = __f.flags();
 char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
 return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}

#line 476
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 double __val) const {
 return _M_do_put_float(__s, __f, __fill, __val);
}

#line 484
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 long double __val) const {
 return _M_do_put_float(__s, __f, __fill, __val);
}

#line 493
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 long long __val) const {
 char __buf[64];

#line 500
 ios_base::fmtflags __flags = __f.flags();
 char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
 return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}

#line 505
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
 unsigned long long __val) const {
 char __buf[64];

#line 512
 ios_base::fmtflags __flags = __f.flags();
 char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
 return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}

#line 521
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT ,
 const void* __val) const {
 const ctype<_CharT>& __c_type = *(const ctype<_CharT>*)__f._M_ctype_facet();
 ios_base::fmtflags __save_flags = __f.flags();

#line 528
 __f.setf(ios_base::hex, ios_base::basefield);
 __f.setf(ios_base::showbase);
 __f.setf(ios_base::internal, ios_base::adjustfield);
 __f.width((sizeof(void*) * 2) + 2);

#line 533
 _OutputIter result = this->do_put(__s, __f, __c_type.widen('0'), reinterpret_cast<unsigned long long>(__val) );

#line 537
 __f.flags(__save_flags);
 return result;
}

#line 541
 }
#line 179 "../../stlport/stl/_num_put.h"

#line 30 "../../stlport/stl/_ostream.c"


#line 32
 namespace _STL {

#line 35
 template <class _CharT, class _Traits>
bool
_M_init(basic_ostream<_CharT, _Traits>& __str) {
 if (__str.good()) {

#line 40
 if (!__str.rdbuf())
 __str.setstate(ios_base::badbit);
 if (__str.tie())
 __str.tie()->flush();
 return __str.good();
 } else
 return false;
}

#line 54
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>
 ::basic_ostream(basic_streambuf<_CharT, _Traits>* __buf)
 : basic_ios<_CharT, _Traits>()
{
 this->init(__buf);
}

#line 62
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{}

#line 67
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<_CharT, _Traits>* __from)
{
 sentry __sentry(*this);
 if (__sentry) {
 if (__from) {
 bool __any_inserted = __from->gptr() != __from->egptr()
 ? this->_M_copy_buffered(__from, this->rdbuf())
 : this->_M_copy_unbuffered(__from, this->rdbuf());
 if (!__any_inserted)
 this->setstate(ios_base::failbit);
 }
 else
 this->setstate(ios_base::badbit);
 }

#line 84
 return *this;
}

#line 92
template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
 ::_M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
 basic_streambuf<_CharT, _Traits>* __to)
{
 bool __any_inserted = false;

#line 99
 while (__from->egptr() != __from->gptr()) {
 const ptrdiff_t __avail = __from->egptr() - __from->gptr();

#line 102
 streamsize __nwritten;
 try {
 __nwritten = __to->sputn(__from->gptr(), __avail);
 __from->gbump((int)__nwritten);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 return __any_inserted;
 }

#line 112
 if (__nwritten == __avail) {
 try {
 if (this->_S_eof(__from->sgetc()))
 return true;
 else
 __any_inserted = true;
 }
 catch(...) {
 this->_M_handle_exception(ios_base::failbit);
 return false;
 }
 }

#line 125
 else if (__nwritten != 0)
 return true;

#line 128
 else
 return __any_inserted;
 }

#line 134
 return __any_inserted || this->_M_copy_unbuffered(__from, __to);
}

#line 137
template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
 ::_M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
 basic_streambuf<_CharT, _Traits>* __to)
{
 bool __any_inserted = false;

#line 144
 while (true) {
 int_type __c;
 try {
 __c = __from->sbumpc();
 }
 catch(...) {
 this->_M_handle_exception(ios_base::failbit);
 return __any_inserted;
 }

#line 154
 if (this->_S_eof(__c))
 return __any_inserted;

#line 157
 else {
 int_type __tmp;
 try {
 __tmp = __to->sputc(__c);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 return __any_inserted;
 }

#line 167
 if (this->_S_eof(__tmp)) {
 try {
 __from->sputbackc(__c);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 return __any_inserted;
 }
 }
 else
 __any_inserted = true;
 }
 }
}

#line 184
template <class _CharT, class _Traits, class _Number>
basic_ostream<_CharT, _Traits>&
_M_put_num(basic_ostream<_CharT, _Traits>& __os, _Number __x)
{
 typedef typename basic_ostream<_CharT, _Traits>::sentry _Sentry;
 _Sentry __sentry(__os);
 bool __failed = true;

#line 192
 if (__sentry) {
 try {
 typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > _NumPut;
 __failed = (use_facet<_NumPut>(__os.getloc())).put(
 ostreambuf_iterator<_CharT, _Traits>(__os.rdbuf()),
 __os, __os.fill(),
 __x).failed();
 }
 catch(...) {
 __os._M_handle_exception(ios_base::badbit);
 }
 }
 if (__failed)
 __os.setstate(ios_base::badbit);
 return __os;
}

#line 222
template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_char(_CharT __c)
{
 sentry __sentry(*this);
 if (__sentry) {
 bool __failed = true;
 try {
 streamsize __npad = this->width() > 0 ? this->width() - 1 : 0;

#line 231
 if (__npad == 0)
 __failed = this->_S_eof(this->rdbuf()->sputc(__c));
 else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
 __failed = this->_S_eof(this->rdbuf()->sputc(__c));
 __failed = __failed ||
 this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
 }
 else {
 __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
 __failed = __failed || this->_S_eof(this->rdbuf()->sputc(__c));
 }

#line 243
 this->width(0);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }

#line 249
 if (__failed)
 this->setstate(ios_base::badbit);
 }
}

#line 254
template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_nowiden(const _CharT* __s)
{
 sentry __sentry(*this);
 if (__sentry) {
 bool __failed = true;
 streamsize __n = _Traits::length(__s);
 streamsize __npad = this->width() > __n ? this->width() - __n : 0;

#line 263
 try {
 if (__npad == 0)
 __failed = this->rdbuf()->sputn(__s, __n) != __n;
 else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
 __failed = this->rdbuf()->sputn(__s, __n) != __n;
 __failed = __failed ||
 this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
 }
 else {
 __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
 __failed = __failed || this->rdbuf()->sputn(__s, __n) != __n;
 }

#line 276
 this->width(0);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }

#line 282
 if (__failed)
 this->setstate(ios_base::failbit);
 }
}

#line 287
template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_widen(const char* __s)
{
 sentry __sentry(*this);
 if (__sentry) {
 bool __failed = true;
 streamsize __n = char_traits<char>::length(__s);
 streamsize __npad = this->width() > __n ? this->width() - __n : 0;

#line 296
 try {
 if (__npad == 0)
 __failed = !this->_M_put_widen_aux(__s, __n);
 else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
 __failed = !this->_M_put_widen_aux(__s, __n);
 __failed = __failed ||
 this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
 }
 else {
 __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
 __failed = __failed || !this->_M_put_widen_aux(__s, __n);
 }

#line 309
 this->width(0);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }

#line 315
 if (__failed)
 this->setstate(ios_base::failbit);
 }
}

#line 320
template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>::_M_put_widen_aux(const char* __s,
 streamsize __n)
{
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

#line 326
 for ( ; __n > 0 ; --__n)
 if (this->_S_eof(__buf->sputc(this->widen(*__s++))))
 return false;
 return true;
}

#line 333
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{
 sentry __sentry(*this);
 bool __failed = true;

#line 340
 if (__sentry) {
 try {
 __failed = this->_S_eof(this->rdbuf()->sputc(__c));
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }
 }

#line 349
 if (__failed)
 this->setstate(ios_base::badbit);

#line 352
 return *this;
}

#line 356
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{
 sentry __sentry(*this);
 bool __failed = true;

#line 363
 if (__sentry) {
 try {
 __failed = this->rdbuf()->sputn(__s, __n) != __n;
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }
 }

#line 372
 if (__failed)
 this->setstate(ios_base::badbit);

#line 375
 return *this;
}

#line 378
 }
#line 350 "../../stlport/stl/_ostream.h"

#line 32 "../../stlport/stl/_istream.h"

#line 1 "../../stlport/stl/_istreambuf_iterator.h"


#line 34
 namespace _STL {

#line 37
 template <class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* _M_get_istreambuf(basic_istream<_CharT, _Traits>& ) ;

#line 44
template<class _CharT, class _Traits>
class istreambuf_iterator
{
public:
 typedef _CharT char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef basic_streambuf<_CharT, _Traits> streambuf_type;
 typedef basic_istream<_CharT, _Traits> istream_type;

#line 54
 typedef input_iterator_tag iterator_category;
 typedef _CharT value_type;
 typedef typename _Traits::off_type difference_type;
 typedef const _CharT* pointer;
 typedef const _CharT& reference;

#line 60
public:
 istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }

#line 63
 inline istreambuf_iterator(basic_istream<_CharT, _Traits>& __is);

#line 65
 char_type operator*() const { this->_M_getc(); return _M_c; }
 istreambuf_iterator<_CharT, _Traits>& operator++() { this->_M_bumpc(); return *this; }
 istreambuf_iterator<_CharT, _Traits> operator++(int);

#line 69
 bool equal(const istreambuf_iterator<_CharT, _Traits>& __i) const {
 if (this->_M_buf)
 this->_M_getc();
 if (__i._M_buf)
 __i._M_getc();
 return this->_M_eof == __i._M_eof;
 }

#line 77
private:
 void _M_init(streambuf_type* __p) {
 _M_buf = __p;
 _M_eof = !__p;

#line 82
 _M_have_c = false;
 }

#line 85
 void _M_getc() const {
 if (_M_have_c)
 return;
 int_type __c = _M_buf->sgetc();

#line 90
 _M_c = traits_type::to_char_type(__c);
 _M_eof = traits_type::eq_int_type(__c, traits_type::eof());
 _M_have_c = true;

#line 100
 }

#line 102
 void _M_bumpc() {
 _M_buf->sbumpc();
 _M_have_c = false;
 }

#line 107
private:
 streambuf_type* _M_buf;
 mutable _CharT _M_c;
 mutable unsigned char _M_eof;
 mutable unsigned char _M_have_c;
};

#line 114
template<class _CharT, class _Traits>
inline istreambuf_iterator<_CharT, _Traits>::istreambuf_iterator(basic_istream<_CharT, _Traits>& __is)
{ this->_M_init(_M_get_istreambuf(__is)); }

#line 118
template<class _CharT, class _Traits>
inline bool operator==(const istreambuf_iterator<_CharT, _Traits>& __x,
 const istreambuf_iterator<_CharT, _Traits>& __y) {
 return __x.equal(__y);
}

#line 126
template<class _CharT, class _Traits>
inline bool operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,
 const istreambuf_iterator<_CharT, _Traits>& __y) {
 return !__x.equal(__y);
}

#line 151
template <class _CharT, class _Traits>
istreambuf_iterator<_CharT, _Traits>
istreambuf_iterator<_CharT, _Traits>::operator++(int) {
 istreambuf_iterator<_CharT, _Traits> __tmp = *this;
 this->_M_bumpc();
 this->_M_have_c = false;
 return __tmp;
}

#line 160
 }
#line 36 "../../stlport/stl/_istream.h"


#line 40
 namespace _STL {

#line 42
 template <class _CharT, class _Traits, class _Number>
ios_base::iostate
_M_get_num(basic_istream<_CharT, _Traits>& __that, _Number& __val);

#line 51
struct _No_Skip_WS {};

#line 53
template <class _CharT, class _Traits>
bool _M_init_skip(basic_istream<_CharT, _Traits>& __is);
template <class _CharT, class _Traits>
bool _M_init_noskip(basic_istream<_CharT, _Traits>& __is);

#line 66
template <class _CharT, class _Traits>
class basic_istream : virtual public basic_ios<_CharT, _Traits> {
public:

#line 70
 typedef _CharT char_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;
 typedef _Traits traits_type;
 typedef basic_ios<_CharT, _Traits> _Basic_ios;
 typedef basic_istream<_CharT, _Traits> _Self;

#line 78
 typedef basic_ios<_CharT, _Traits>& ( *__ios_fn)(basic_ios<_CharT, _Traits>&);
 typedef ios_base& ( *__ios_base_fn)(ios_base&);
 typedef _Self& ( *__istream_fn)(_Self&);

#line 82
public:
 explicit basic_istream(basic_streambuf<_CharT, _Traits>* __buf) :
 basic_ios<_CharT, _Traits>(), _M_gcount(0) {
 this->init(__buf);
 }
 ~basic_istream() {};

#line 89
public:

#line 91
public:

#line 93
 _Self& operator>> (__istream_fn __f) { return __f(*this); }
 _Self& operator>> (__ios_fn __f) { __f(*this); return *this; }
 _Self& operator>> (__ios_base_fn __f) { __f(*this); return *this; }

#line 97
public:
 _Self& operator>> (short& __val) {
 long __lval;
 unsigned short __uval;
 _M_get_num(*this, __lval);
 __val = static_cast<short>(__lval) ;
 __uval = __lval;

#line 106
 if ((__val != __lval) && ((long)__uval != __lval))
 this->setstate(ios_base::failbit);
 return *this;
 }
 _Self& operator>> (int& __val) {
 long __lval;
 unsigned int __uval;
 _M_get_num(*this, __lval);
 __val = __lval;
 __uval = __lval;

#line 118
 if ((__val != __lval) && ((long)__uval != __lval))
 this->setstate(ios_base::failbit);
 return *this;
 }
 _Self& operator>> (unsigned short& __val) { _M_get_num(*this, __val); return *this; }
 _Self& operator>> (unsigned int& __val) { _M_get_num(*this, __val); return *this; }
 _Self& operator>> (long& __val) { _M_get_num(*this, __val); return *this; }
 _Self& operator>> (unsigned long& __val) { _M_get_num(*this, __val); return *this; }

#line 127
 _Self& operator>> ( long long & __val) { _M_get_num(*this, __val); return *this; }
 _Self& operator>> (unsigned long long & __val) { _M_get_num(*this, __val); return *this; }

#line 130
 _Self& operator>> (float& __val) { _M_get_num(*this, __val); return *this; }
 _Self& operator>> (double& __val) { _M_get_num(*this, __val); return *this; }

#line 133
 _Self& operator>> (long double& __val) { _M_get_num(*this, __val); return *this; }

#line 136
 _Self& operator>> (bool& __val) { _M_get_num(*this, __val); return *this; }

#line 138
 _Self& operator>> (void*& __val) { _M_get_num(*this, __val); return *this; }

#line 140
public:
 _Self& operator>>(basic_streambuf<_CharT, _Traits>*);

#line 143
public:
 streamsize gcount() const { return _M_gcount; }
 int_type peek();

#line 147
public:
 int_type get();
 _Self& get(char_type& __c);

#line 151
public:
 _Self& get(char_type* __s, streamsize __n, char_type __delim);
 _Self& get(char_type* __s, streamsize __n)
 { return get(__s, __n, this->widen('\n')); }

#line 156
public:
 _Self& get(basic_streambuf<_CharT, _Traits>& __buf,
 char_type __delim);
 _Self& get(basic_streambuf<_CharT, _Traits>& __buf)
 { return get(__buf, this->widen('\n')); }

#line 162
public:
 _Self& getline(char_type* __s, streamsize __n, char_type delim);
 _Self& getline(char_type* __s, streamsize __n)
 { return getline(__s, __n, this->widen('\n')); }

#line 167
public:
 _Self& ignore();
 _Self& ignore(streamsize __n);

#line 173
 _Self& ignore(streamsize __n, int_type __delim);

#line 175
 _Self& read(char_type* __s, streamsize __n);
 streamsize readsome(char_type* __s, streamsize __n);

#line 178
public:
 _Self& putback(char_type __c);
 _Self& unget();

#line 182
public:
 int sync();

#line 185
 pos_type tellg();
 _Self& seekg(pos_type __pos);
 _Self& seekg(off_type, ios_base::seekdir);

#line 189
public:
 void _M_formatted_get(_CharT& __c);
 void _M_formatted_get(_CharT* __s);
 void _M_skip_whitespace(bool __set_failbit);

#line 194
private:
 streamsize _M_gcount;

#line 197
public:

#line 209
 class sentry {
 typedef sentry _Self;

#line 213
 private:
 const bool _M_ok;

#line 217
 public:
 typedef _Traits traits_type;

#line 220
 explicit sentry(basic_istream<_CharT, _Traits>& __is,
 bool __noskipws = false) :
 _M_ok((__noskipws || !(__is.flags() & ios_base::skipws)) ? _M_init_noskip(__is) : _M_init_skip(__is) )

#line 224
 {}

#line 228
 sentry(basic_istream<_CharT, _Traits>& __is, _No_Skip_WS) :
 _M_ok(_M_init_noskip(__is)) {}

#line 231
 ~sentry() {}

#line 233
 operator bool() const { return _M_ok; }

#line 235
 private:
 sentry(const _Self&) : _M_ok(false) {}
 void operator=(const _Self&) {}
 };

#line 244
};

#line 258
template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c) {
 __in._M_formatted_get(__c);
 return __in;
}

#line 265
template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c) {
 __in._M_formatted_get( reinterpret_cast<char&>(__c) );
 return __in;
}

#line 272
template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, signed char& __c) {
 __in._M_formatted_get( reinterpret_cast<char&>(__c) );
 return __in;
}

#line 279
template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s) {
 __in._M_formatted_get(__s);
 return __in;
}

#line 286
template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s) {
 __in._M_formatted_get( reinterpret_cast<char*>(__s) );
 return __in;
}

#line 293
template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, signed char* __s) {
 __in._M_formatted_get( reinterpret_cast<char*>(__s) );
 return __in;
}

#line 302
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is);

#line 309
template <class _CharT, class _Traits>
class basic_iostream
 : public basic_istream<_CharT, _Traits>,
 public basic_ostream<_CharT, _Traits>
{
public:
 typedef basic_ios<_CharT, _Traits> _Basic_ios;

#line 317
 explicit basic_iostream(basic_streambuf<_CharT, _Traits>* __buf);
 virtual ~basic_iostream();
};

#line 328
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>* _M_get_istreambuf(basic_istream<_CharT, _Traits>& __is)
{
 return __is.rdbuf();
}

#line 334
 }
#line 1 "../../stlport/stl/_istream.c"

#line 1 "../../stlport/stl/_num_get.h"


#line 41
 namespace _STL {

#line 49
 template <class _CharT, class _InputIter = istreambuf_iterator<_CharT> >

#line 51
class num_get: public locale::facet
{
 friend class _Locale;
public:
 typedef _CharT char_type;
 typedef _InputIter iter_type;

#line 58
 explicit num_get(size_t __refs = 0): locale::facet(__refs) {}

#line 61
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, bool& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 79
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 84
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned short& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 89
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned int& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 94
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned long& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 101
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long long & __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 106
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned long long & __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 113
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, float& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 118
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, double& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 125
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long double& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 131
 _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, void*& __val) const {
 return do_get(__in, __end, __str, __err, __val);
 }

#line 136
 static locale::id id;

#line 138
protected:
 ~num_get() {}

#line 141
 typedef string string_type;
 typedef ctype<_CharT> _Ctype;
 typedef numpunct<_CharT> _Numpunct;

#line 146
 virtual _InputIter do_get(_InputIter __in, _InputIter __end,
 ios_base& __str, ios_base::iostate& __err, bool& __val) const;

#line 150
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long& __val) const;
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned short& __val) const;
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned int& __val) const;
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned long& __val) const;

#line 165
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, float& __val) const;
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, double& __val) const;
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 void*& __p) const;

#line 174
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long double& __val) const;

#line 180
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long long & __val) const;
 virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, unsigned long long & __val) const;

#line 186
};

#line 200
extern bool __valid_grouping(const char*, const char*, const char*, const char*);

#line 202
template <class _InputIter, class _Integer>
bool
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val);

#line 206
inline bool __get_fdigit(char& __c, const char*);
inline bool __get_fdigit_or_sep(char& __c, char __sep, const char *);

#line 209
bool __get_fdigit(wchar_t&, const wchar_t*);
bool __get_fdigit_or_sep(wchar_t&, wchar_t, const wchar_t*);

#line 213
inline void
_Initialize_get_float(const ctype<char>&,
 char& Plus, char& Minus,
 char& pow_e, char& pow_E,
 char*)
{
 Plus = '+';
 Minus = '-';
 pow_e = 'e';
 pow_E = 'E';
}

#line 226
void _Initialize_get_float(const ctype<wchar_t>&,
 wchar_t&, wchar_t&, wchar_t&, wchar_t&, wchar_t*);

#line 229
void __string_to_float(const string&, float&);
void __string_to_float(const string&, double&);

#line 232
void __string_to_float(const string&, long double&);

#line 248
 }
#line 1 "../../stlport/stl/_num_get.c"


#line 31
 namespace _STL {

#line 33
 extern const unsigned char __digit_val_table[];

#line 35
template < class _InputIter, class _Integer, class _CharT>
_InputIter
_M_do_get_integer(_InputIter&, _InputIter&, ios_base&, ios_base::iostate&, _Integer&, _CharT*);

#line 41
inline bool __get_fdigit(char& __c, const char*)
 { return __c >= '0' && __c <= '9'; }

#line 44
inline bool __get_fdigit_or_sep(char& __c, char __sep, const char *)
{
 if (__c == __sep) {
 __c = ',' ;
 return true ;
 } else
 return ( __c >= '0' && __c <= '9');
}

#line 53
inline int
__get_digit_from_table(unsigned __index)
{
 return (__index > 127 ? 0xFF : __digit_val_table[__index]);
}

#line 59
extern const char __narrow_atoms[];

#line 61
template <class _InputIter, class _CharT>
int
_M_get_base_or_zero(_InputIter& __in, _InputIter& __end, ios_base& __str, _CharT*)
{
 _CharT __atoms[5];
 const ctype<_CharT>& __c_type = *(const ctype<_CharT>*)__str._M_ctype_facet();

#line 68
 __c_type.widen(__narrow_atoms, __narrow_atoms + 5, __atoms);

#line 70
 bool __negative = false;
 _CharT __c = *__in;

#line 73
 if (__c == __atoms[1] ) {
 __negative = true;
 ++__in;
 }
 else if (__c == __atoms[0] )
 ++__in;

#line 81
 int __base;
 int __valid_zero = 0;

#line 84
 ios_base::fmtflags __basefield = __str.flags() & ios_base::basefield;

#line 86
 switch (__basefield) {
 case ios_base::oct:
 __base = 8;
 break;
 case ios_base::dec:
 __base = 10;
 break;
 case ios_base::hex:
 __base = 16;
 if (__in != __end && *__in == __atoms[2] ) {
 ++__in;
 if (__in != __end &&
 (*__in == __atoms[3] || *__in == __atoms[4] ))
 ++__in;
 else
 __valid_zero = 1;
 }
 break;
 default:
 if (__in != __end && *__in == __atoms[2] ) {
 ++__in;
 if (__in != __end &&
 (*__in == __atoms[3] || *__in == __atoms[4] )) {
 ++__in;
 __base = 16;
 }
 else
 {
 __base = 8;
 __valid_zero = 1;
 }
 }
 else
 __base = 10;
 break;
 }
 return (__base << 2) | ((int)__negative << 1) | __valid_zero;
}

#line 126
template <class _InputIter, class _Integer>
bool
__get_integer(_InputIter& __first, _InputIter& __last,
 int __base, _Integer& __val,
 int __got, bool __is_negative, char __separator, const string& __grouping, const __true_type&)
{
 bool __ovflow = false;
 _Integer __result = 0;
 bool __is_group = !__grouping.empty();
 char __group_sizes[64];
 int __current_group_size = 0;
 char* __group_sizes_end = __group_sizes;

#line 139
 _Integer __over_base = (numeric_limits<_Integer>::min)() / static_cast<_Integer>(__base) ;

#line 141
 for ( ; __first != __last ; ++__first) {

#line 143
 const char __c = *__first;

#line 145
 if (__is_group && __c == __separator) {
 *__group_sizes_end++ = __current_group_size;
 __current_group_size = 0;
 continue;
 }

#line 151
 int __n = __get_digit_from_table(__c);

#line 153
 if (__n >= __base)
 break;

#line 156
 ++__got;
 ++__current_group_size;

#line 159
 if (__result < __over_base)
 __ovflow = true;
 else {
 _Integer __next = static_cast<_Integer>(__base * __result - __n) ;
 if (__result != 0)
 __ovflow = __ovflow || __next >= __result;
 __result = __next;
 }
 }

#line 169
 if (__is_group && __group_sizes_end != __group_sizes) {
 *__group_sizes_end++ = __current_group_size;
 }

#line 174
 if (__got > 0) {
 __val = __ovflow
 ? __is_negative ? (numeric_limits<_Integer>::min)()
 : (numeric_limits<_Integer>::max)()
 : (__is_negative ? __result : static_cast<_Integer>(-__result) );
 }

#line 181
 return ((__got > 0) && !__ovflow) && (__is_group == 0 || __valid_grouping(__group_sizes, __group_sizes_end,
 __grouping.data(), __grouping.data()+ __grouping.size())) ;
}

#line 185
template <class _InputIter, class _Integer>
bool
__get_integer(_InputIter& __first, _InputIter& __last,
 int __base, _Integer& __val,
 int __got, bool __is_negative, char __separator, const string& __grouping, const __false_type&)
{
 bool __ovflow = false;
 _Integer __result = 0;
 bool __is_group = !__grouping.empty();
 char __group_sizes[64];
 int __current_group_size = 0;
 char* __group_sizes_end = __group_sizes;

#line 198
 _Integer __over_base = (numeric_limits<_Integer>::max)() / static_cast<_Integer>(__base) ;

#line 200
 for ( ; __first != __last ; ++__first) {

#line 202
 const char __c = *__first;

#line 204
 if (__is_group && __c == __separator) {
 *__group_sizes_end++ = __current_group_size;
 __current_group_size = 0;
 continue;
 }

#line 210
 int __n = __get_digit_from_table(__c);

#line 212
 if (__n >= __base)
 break;

#line 215
 ++__got;
 ++__current_group_size;

#line 218
 if (__result > __over_base)
 __ovflow = true;
 else {
 _Integer __next = static_cast<_Integer>(__base * __result + __n) ;
 if (__result != 0)
 __ovflow = __ovflow || __next <= __result;
 __result = __next;
 }
 }

#line 228
 if (__is_group && __group_sizes_end != __group_sizes) {
 *__group_sizes_end++ = __current_group_size;
 }

#line 233
 if (__got > 0) {
 __val = __ovflow
 ? (numeric_limits<_Integer>::max)()
 : (__is_negative ? static_cast<_Integer>(-__result) : __result);
 }

#line 239
 return ((__got > 0) && !__ovflow) &&
 (__is_group == 0 || __valid_grouping(__group_sizes, __group_sizes_end,
 __grouping.data(), __grouping.data()+ __grouping.size())) ;
}

#line 245
template <class _InputIter, class _Integer>
bool
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val)
{
 string __grp;
 return __get_integer(__first, __last, 10, __val, 0, false, ' ', __grp, __false_type());
}

#line 253
template <class _InputIter, class _Integer, class _CharT>
_InputIter
_M_do_get_integer(_InputIter& __in, _InputIter& __end, ios_base& __str,
 ios_base::iostate& __err, _Integer& __val, _CharT* __pc)
{

#line 262
 typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;

#line 265
 const numpunct<_CharT>& __numpunct = *(const numpunct<_CharT>*)__str._M_numpunct_facet();
 const string& __grouping = __str._M_grouping();

#line 268
 const int __base_or_zero = _M_get_base_or_zero(__in, __end, __str, __pc);
 int __got = __base_or_zero & 1;

#line 271
 bool __result;

#line 273
 if (__in == __end) {

#line 275
 if (__got > 0) {
 __val = 0;
 __result = true;
 }
 else
 __result = false;
 } else {

#line 283
 const bool __negative = __base_or_zero & 2;
 const int __base = __base_or_zero >> 2;

#line 292
 __result = __get_integer(__in, __end, __base, __val, __got, __negative, __numpunct.thousands_sep(), __grouping, _IsSigned());

#line 294
 }

#line 296
 __err = static_cast<ios_base::iostate>(__result ? ios_base::goodbit : ios_base::failbit) ;

#line 298
 if (__in == __end)
 __err |= ios_base::eofbit;
 return __in;
}

#line 304
template <class _InputIter, class _CharT>
_InputIter
__copy_sign(_InputIter __first, _InputIter __last, string& __v,
 _CharT __xplus, _CharT __xminus) {
 if (__first != __last) {
 _CharT __c = *__first;
 if (__c == __xplus)
 ++__first;
 else if (__c == __xminus) {
 __v.push_back('-');
 ++__first;
 }
 }
 return __first;
}

#line 321
template <class _InputIter, class _CharT>
bool
__copy_digits(_InputIter& __first, _InputIter& __last,
 string& __v, const _CharT* __digits)
{
 bool __ok = false;

#line 328
 for ( ; __first != __last; ++__first) {
 _CharT __c = *__first;
 if (__get_fdigit(__c, __digits)) {
 __v.push_back((char)__c);
 __ok = true;
 }
 else
 break;
 }
 return __ok;
}

#line 340
template <class _InputIter, class _CharT>
bool
__copy_grouped_digits(_InputIter& __first, _InputIter& __last,
 string& __v, const _CharT * __digits,
 _CharT __sep, const string& __grouping,
 bool& __grouping_ok)
{
 bool __ok = false;
 char __group_sizes[64];
 char*__group_sizes_end = __group_sizes;
 char __current_group_size = 0;

#line 352
 for ( ; __first != __last; ++__first) {
 _CharT __c = *__first;
 bool __tmp = __get_fdigit_or_sep(__c, __sep, __digits);
 if (__tmp) {
 if (__c == ',') {
 *__group_sizes_end++ = __current_group_size;
 __current_group_size = 0;
 }
 else {
 __ok = true;
 __v.push_back((char)__c);
 ++__current_group_size;
 }
 }
 else
 break;
 }

#line 370
 if (__group_sizes_end != __group_sizes)
 *__group_sizes_end++ = __current_group_size;
 __grouping_ok = __valid_grouping(__group_sizes, __group_sizes_end, __grouping.data(), __grouping.data() + __grouping.size());
 return __ok;
}

#line 377
template <class _InputIter, class _CharT>
bool
_M_read_float(string& __buf, _InputIter& __in, _InputIter& __end, ios_base& __s, _CharT*)
{

#line 384
 bool __digits_before_dot ;
 bool __digits_after_dot = false;
 bool __ok;

#line 388
 bool __grouping_ok = true;

#line 390
 const ctype<_CharT>& __ct = *(const ctype<_CharT>*)__s._M_ctype_facet();
 const numpunct<_CharT>& __numpunct = *(const numpunct<_CharT>*)__s._M_numpunct_facet();
 const string& __grouping = __s._M_grouping();

#line 394
 _CharT __dot = __numpunct.decimal_point();
 _CharT __sep = __numpunct.thousands_sep();

#line 397
 _CharT __digits[10];
 _CharT __xplus;
 _CharT __xminus;

#line 401
 _CharT __pow_e;
 _CharT __pow_E;

#line 404
 _Initialize_get_float(__ct, __xplus, __xminus, __pow_e, __pow_E, __digits);

#line 407
 __in = __copy_sign(__in, __end, __buf, __xplus, __xminus);

#line 410
 if (__grouping.size() != 0)
 __digits_before_dot = __copy_grouped_digits(__in, __end, __buf, __digits,
 __sep, __grouping, __grouping_ok);
 else
 __digits_before_dot = __copy_digits(__in, __end, __buf, __digits);

#line 417
 if (__in != __end && *__in == __dot) {
 __buf.push_back('.');
 ++__in;
 __digits_after_dot = __copy_digits(__in, __end, __buf, __digits);
 }

#line 424
 __ok = __digits_before_dot || __digits_after_dot;

#line 427
 if (__ok && __in != __end && (*__in == __pow_e || *__in == __pow_E)) {
 __buf.push_back('e');
 ++__in;
 __in = __copy_sign(__in, __end, __buf, __xplus, __xminus);
 __ok = __copy_digits(__in, __end, __buf, __digits);

#line 434
 }

#line 436
 return __ok;
}

#line 444
template <class _CharT, class _InputIterator>
locale::id num_get<_CharT, _InputIterator>::id;

#line 467
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end,
 ios_base& __s,
 ios_base::iostate& __err, bool& __x) const
{
 if (__s.flags() & ios_base::boolalpha) {
 locale __loc = __s.getloc();
 const _Numpunct& __np = *(const _Numpunct*)__s._M_numpunct_facet();

#line 479
 const basic_string<_CharT> __truename = __np.truename();
 const basic_string<_CharT> __falsename = __np.falsename();
 bool __true_ok = true;
 bool __false_ok = true;

#line 484
 size_t __n = 0;
 for ( ; __in != __end; ++__in) {
 _CharT __c = *__in;
 __true_ok = __true_ok && (__c == __truename[__n]);
 __false_ok = __false_ok && (__c == __falsename[__n]);
 ++__n;

#line 491
 if ((!__true_ok && !__false_ok) ||
 (__true_ok && __n >= __truename.size()) ||
 (__false_ok && __n >= __falsename.size())) {
 ++__in;
 break;
 }
 }
 if (__true_ok && __n < __truename.size()) __true_ok = false;
 if (__false_ok && __n < __falsename.size()) __false_ok = false;

#line 501
 if (__true_ok || __false_ok) {
 __err = ios_base::goodbit;
 __x = __true_ok;
 }
 else
 __err = ios_base::failbit;

#line 508
 if (__in == __end)
 __err |= ios_base::eofbit;

#line 511
 return __in;
 }

#line 514
 else {
 long __lx;
 _InputIter __tmp = this->do_get(__in, __end, __s, __err, __lx);
 if (!(__err & ios_base::failbit)) {
 if (__lx == 0)
 __x = false;
 else if (__lx == 1)
 __x = true;
 else
 __err |= ios_base::failbit;
 }
 return __tmp;
 }
}

#line 548
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err, long& __val) const {
 return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

#line 555
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 unsigned short& __val) const {
 return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

#line 563
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 unsigned int& __val) const {
 return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

#line 571
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 unsigned long& __val) const {
 return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

#line 580
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 float& __val) const {
 string __buf ;
 bool __ok = _M_read_float(__buf, __in, __end, __str, (_CharT*)0 );
 __string_to_float(__buf, __val);
 __err = static_cast<ios_base::iostate>(__ok ? ios_base::goodbit : ios_base::failbit) ;
 if (__in == __end)
 __err |= ios_base::eofbit;
 return __in;
}

#line 594
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 double& __val) const {
 string __buf ;
 bool __ok = _M_read_float(__buf, __in, __end, __str, (_CharT*)0 );
 __string_to_float(__buf, __val);
 __err = static_cast<ios_base::iostate>(__ok ? ios_base::goodbit : ios_base::failbit) ;
 if (__in == __end)
 __err |= ios_base::eofbit;
 return __in;
}

#line 609
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 long double& __val) const {
 string __buf ;
 bool __ok = _M_read_float(__buf, __in, __end, __str, (_CharT*)0 );
 __string_to_float(__buf, __val);
 __err = static_cast<ios_base::iostate>(__ok ? ios_base::goodbit : ios_base::failbit) ;
 if (__in == __end)
 __err |= ios_base::eofbit;
 return __in;
}

#line 624
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 void*& __p) const {

#line 630
 unsigned long long __val;

#line 634
 iter_type __tmp = _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
 if (!(__err & ios_base::failbit))
 __p = reinterpret_cast<void*>(__val) ;
 return __tmp;
 }

#line 643
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 long long & __val) const {
 return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

#line 651
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
 ios_base::iostate& __err,
 unsigned long long & __val) const {
 return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

#line 661
 }
#line 252 "../../stlport/stl/_num_get.h"

#line 33 "../../stlport/stl/_istream.c"


#line 46
 namespace _STL {

#line 51
 template <class _Traits>
struct _Is_not_wspace {
 typedef typename _Traits::char_type argument_type;
 typedef bool result_type;

#line 56
 const ctype<argument_type>* _M_ctype;

#line 58
 _Is_not_wspace(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
 bool operator()(argument_type __c) const
 { return !_M_ctype->is(ctype_base::space, __c); }
};

#line 63
template <class _Traits>
struct _Is_wspace_null {
 typedef typename _Traits::char_type argument_type;
 typedef bool result_type;

#line 68
 const ctype<argument_type>* _M_ctype;

#line 70
 _Is_wspace_null(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
 bool operator()(argument_type __c) const {
 return _Traits::eq(__c, argument_type()) ||
 _M_ctype->is(ctype_base::space, __c);
 }
};

#line 77
template <class _Traits>
struct _Scan_for_wspace {
 typedef typename _Traits::char_type char_type;
 typedef char_type* first_argument_type;
 typedef char_type* second_argument_type;
 typedef char_type* result_type;

#line 84
 const ctype<char_type>* _M_ctype;

#line 86
 _Scan_for_wspace(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
 const char_type*
 operator()(const char_type* __first, const char_type* __last) const {
 return _M_ctype->scan_is(ctype_base::space, __first, __last);
 }
};

#line 93
template <class _Traits>
struct _Scan_wspace_null {
 typedef typename _Traits::char_type char_type;
 typedef char_type* first_argument_type;
 typedef char_type* second_argument_type;
 typedef char_type* result_type;

#line 100
 const ctype<char_type>* _M_ctype;

#line 102
 _Scan_wspace_null(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
 const char_type*
 operator()(const char_type* __first, const char_type* __last) const {
 __last = find_if(__first, __last,
 _Eq_char_bound<_Traits>(char_type()));
 return _M_ctype->scan_is(ctype_base::space, __first, __last);
 }
};

#line 111
template <class _Traits>
struct _Scan_for_not_wspace {
 typedef typename _Traits::char_type char_type;
 typedef char_type* first_argument_type;
 typedef char_type* second_argument_type;
 typedef char_type* result_type;

#line 118
 const ctype<char_type>* _M_ctype;

#line 120
 _Scan_for_not_wspace(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
 const char_type*
 operator()(const char_type* __first, const char_type* __last) const {
 return _M_ctype->scan_not(ctype_base::space, __first, __last);
 }
};

#line 127
template <class _Traits>
struct _Scan_for_char_val
{
 typedef typename _Traits::char_type char_type;
 typedef char_type* first_argument_type;
 typedef char_type* second_argument_type;
 typedef char_type* result_type;

#line 135
 char_type _M_val;

#line 137
 _Scan_for_char_val(char_type __val) : _M_val(__val) {}

#line 139
 const char_type*
 operator()(const char_type* __first, const char_type* __last) const {
 return find_if(__first, __last, _Eq_char_bound<_Traits>(_M_val));
 }
};

#line 145
template <class _Traits>
struct _Scan_for_int_val
{
 typedef typename _Traits::char_type char_type;
 typedef typename _Traits::int_type int_type;
 typedef char_type* first_argument_type;
 typedef char_type* second_argument_type;
 typedef char_type* result_type;

#line 154
 int_type _M_val;

#line 156
 _Scan_for_int_val(int_type __val) : _M_val(__val) {}

#line 158
 const char_type*
 operator()(const char_type* __first, const char_type* __last) const {
 return find_if(__first, __last,
 _Eq_int_bound<_Traits>(_M_val));
 }
};

#line 168
template <class _CharT, class _Traits>
bool
__pushback(basic_streambuf<_CharT, _Traits>* __buf, _CharT __c)
{
 bool ret;
 try {
 const typename _Traits::int_type __eof = _Traits::eof();
 ret = !_Traits::eq_int_type(__buf->sputbackc(__c), __eof);
 }
 catch(...) {
 ret = false;
 }
 return ret;
}

#line 183
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{
 typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
 _Sentry __sentry(__is, _No_Skip_WS());
 if (__sentry)
 __is._M_skip_whitespace(false);
 return __is;
}

#line 195
template <class _CharT, class _Traits>
bool
_M_init_skip(basic_istream<_CharT, _Traits>& __is) {
 if (__is.good()) {
 if (__is.tie())
 __is.tie()->flush();

#line 202
 __is._M_skip_whitespace(true);
 }

#line 205
 if (!__is.good()) {
 __is.setstate(ios_base::failbit);
 return false;
 } else
 return true;
}

#line 212
template <class _CharT, class _Traits>
bool
_M_init_noskip(basic_istream<_CharT, _Traits>& __is){
 if (__is.good()) {
 if (__is.tie())
 __is.tie()->flush();

#line 219
 if (!__is.rdbuf())
 __is.setstate(ios_base::badbit);
 }
 else
 __is.setstate(ios_base::failbit);
 return __is.good();
}

#line 231
template <class _CharT, class _Traits, class _Number>
ios_base::iostate
_M_get_num(basic_istream<_CharT, _Traits>& __that, _Number& __val)
{
 typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
 ios_base::iostate __err = 0;
 _Sentry __sentry( __that );
 if (__sentry) {
 typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > _Num_get;
 try {
 ((const _Num_get&)use_facet<_Num_get>(__that.getloc())).get(istreambuf_iterator<_CharT, _Traits>(__that.rdbuf()),
 0, __that, __err, __val);
 }
 catch(...) {
 __that._M_handle_exception(ios_base::badbit);
 }
 if (__err) __that.setstate(__err);
 }
 return __err;
}

#line 255
template <class _CharT, class _Traits>
 typename basic_istream<_CharT, _Traits>::int_type
 basic_istream<_CharT, _Traits>::peek()
{
 typename _Traits::int_type __tmp = _Traits::eof();

#line 261
 this->_M_gcount = 0;
 sentry __sentry(*this, _No_Skip_WS());

#line 264
 if (__sentry) {
 try {
 __tmp = this->rdbuf()->sgetc();
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }
 if (this->_S_eof(__tmp))
 this->setstate(ios_base::eofbit);
 }

#line 275
 return __tmp;
}

#line 279
template <class _CharT, class _Traits>
 typename basic_istream<_CharT, _Traits>::int_type
 basic_istream<_CharT, _Traits>::get()
{
 typename _Traits::int_type __tmp = _Traits::eof();
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 287
 if (__sentry) {
 try {
 __tmp = this->rdbuf()->sbumpc();
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }

#line 295
 if (!this->_S_eof(__tmp))
 this->_M_gcount = 1;
 }

#line 299
 if (_M_gcount == 0)
 this->setstate(ios_base::eofbit | ios_base::failbit);

#line 302
 return __tmp;
}

#line 305
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT& __c)
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 312
 if (__sentry) {
 typename _Traits::int_type __tmp = _Traits::eof();
 try {
 __tmp = this->rdbuf()->sbumpc();
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }

#line 321
 if (!this->_S_eof(__tmp)) {
 this->_M_gcount = 1;
 __c = _Traits::to_char_type(__tmp);
 }
 }

#line 327
 if (this->_M_gcount == 0)
 this->setstate(ios_base::eofbit | ios_base::failbit);

#line 330
 return *this;
}

#line 339
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore()
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 345
 if (__sentry) {
 int_type __c;
 try {
 __c = this->rdbuf()->sbumpc();
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 return *this;
 }

#line 355
 if (!this->_S_eof(__c))
 this->_M_gcount = 1;
 else
 this->setstate(ios_base::eofbit);
 }

#line 361
 return *this;
}

#line 366
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(_CharT __c) {
 this->_M_gcount = 0;
 sentry __sentry(*this, _No_Skip_WS());

#line 372
 if (__sentry) {
 typename _Traits::int_type __tmp = _Traits::eof();
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

#line 376
 if (__buf) {
 try {
 __tmp = __buf->sputbackc(__c);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }
 }
 if (this->_S_eof(__tmp))
 this->setstate(ios_base::badbit);
 }
 else
 this->setstate(ios_base::failbit);

#line 390
 return *this;
}

#line 393
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
 this->_M_gcount = 0;

#line 397
 sentry __sentry(*this, _No_Skip_WS());

#line 399
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

#line 402
 if (__buf) {
 try {
 _CharT __tmp;
 __tmp = __buf->sungetc();
 if (this->_S_eof(__tmp))
 this->setstate(ios_base::badbit);
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 }
 } else
 this->setstate(ios_base::badbit);
 }
 else
 this->setstate(ios_base::failbit);

#line 418
 return *this;
}

#line 423
template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
 sentry __sentry(*this, _No_Skip_WS());

#line 427
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 if (__buf) {
 if (__buf->pubsync() == -1) {
 this->setstate(ios_base::badbit);
 return -1;
 }
 else
 return 0;
 }
 else
 return -1;
}

#line 440
template <class _CharT, class _Traits>
 typename basic_istream<_CharT, _Traits>::pos_type
 basic_istream<_CharT, _Traits>::tellg() {

#line 444
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 return (__buf && !this->fail()) ? __buf->pubseekoff(0, ios_base::cur, ios_base::in)
 : pos_type(-1);
}

#line 449
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
 sentry __sentry(*this, _No_Skip_WS());

#line 454
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 if (!this->fail() && __buf)
 __buf->pubseekpos(__pos, ios_base::in);
 return *this;
}

#line 460
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
 sentry __sentry(*this, _No_Skip_WS());

#line 466
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 if (!this->fail() && __buf)
 __buf->pubseekoff(__off, __dir, ios_base::in);
 return *this;
}

#line 474
template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT& __c)
{

#line 479
 sentry __sentry(*this);

#line 481
 if (__sentry) {
 typename _Traits::int_type __tmp = _Traits::eof();

#line 484
 try {
 __tmp = this->rdbuf()->sbumpc();
 }
 catch(...) {
 this->_M_handle_exception(ios_base::badbit);
 return;
 }

#line 492
 if (!this->_S_eof(__tmp))
 __c = _Traits::to_char_type(__tmp);
 else
 this->setstate(ios_base::eofbit | ios_base::failbit);
 }
}

#line 521
template < class _CharT, class _Traits, class _Is_Delim>
streamsize
_M_read_unbuffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
 streamsize _Num, _CharT* __s,
 _Is_Delim __is_delim,
 bool __extract_delim, bool __append_null,
 bool __is_getline)
{
 streamsize __n = 0;
 ios_base::iostate __status = 0;

#line 532
 typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

#line 534
 try {

#line 564
while (true) {

#line 566
int_type __c = __buf->sbumpc();

#line 568
if (__that->_S_eof(__c)) {
if (__n < _Num || __is_getline)
__status |= ios_base::eofbit;
break;
}

#line 574
else if (__is_delim(__c)) {
if (__extract_delim) {

#line 577
++__n;
}
break;
}

#line 582
else {

#line 584
*__s++ = _Traits::to_char_type(__c);
++__n;

#line 587
}

#line 589
if (__n == _Num) {
if (__is_getline)
__status |= ios_base::failbit;
break;
}

#line 598
}

#line 602
 }
 catch(...) {
 __that->_M_handle_exception(ios_base::badbit);
 *__s = _CharT() ;
 return __n;
 }

#line 609
 if (__append_null)
 *__s = _CharT() ;
 if (__status)
 __that->setstate(__status);
 return __n;
}

#line 620
template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize
_M_read_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
 streamsize _Num, _CharT* __s,
 _Is_Delim __is_delim, _Scan_Delim __scan_delim,
 bool __extract_delim, bool __append_null,
 bool __is_getline)
{
 streamsize __n = 0;
 ios_base::iostate __status = 0;
 bool __done = false;

#line 632
 try {
 while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
 const _CharT* __first = __buf->_M_gptr();
 const _CharT* __last = __buf->_M_egptr();
 ptrdiff_t __request = _Num - __n;

#line 638
 const _CharT* __p = __scan_delim(__first, __last);
 ptrdiff_t __chunk = (min) (ptrdiff_t(__p - __first), __request);
 _Traits::copy(__s, __first, __chunk);
 __s += __chunk;
 __n += __chunk;
 __buf->_M_gbump((int)__chunk);

#line 646
 if (__p != __last && __p - __first <= __request) {
 if (__extract_delim) {
 __n += 1;
 __buf->_M_gbump(1);
 }
 __done = true;
 }

#line 655
 else if(__n == _Num) {

#line 658
 if (__is_getline) {
 if (__chunk == __last - __first) {
 if (__that->_S_eof(__buf->sgetc()))
 __status |= ios_base::eofbit;
 }
 else
 __status |= ios_base::failbit;
 }
 __done = true;
 }

#line 671
 else {
 if (__that->_S_eof(__buf->sgetc())) {
 __status |= ios_base::eofbit;
 __done = true;
 }
 }
 }
 }
 catch(...) {
 __that->_M_handle_exception(ios_base::badbit);
 __done = true;
 }

#line 684
 if (__done) {
 if (__append_null)
 *__s = _CharT() ;
 if (__status != 0)
 __that->setstate(__status);
 return __n;
 }

#line 697
 return __n + _M_read_unbuffered(__that, __buf, _Num - __n, __s, __is_delim,
 __extract_delim,__append_null,__is_getline);
}

#line 704
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT* __s, streamsize __n,
 _CharT __delim) {
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 711
 if (__sentry) {
 if (__n > 0) {
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

#line 715
 if (__buf->egptr() != __buf->gptr())
 this->_M_gcount =
 _M_read_buffered(this, __buf, __n - 1, __s,
 _Eq_char_bound<_Traits>(__delim),
 _Scan_for_char_val<_Traits>(__delim),
 false, true, false);
 else
 this->_M_gcount =
 _M_read_unbuffered(this, __buf, __n - 1, __s,
 _Eq_char_bound<_Traits>(__delim),
 false, true, false);
 }
 }

#line 729
 if (this->_M_gcount == 0)
 this->setstate(ios_base::failbit);

#line 732
 return *this;
}

#line 737
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(_CharT* __s, streamsize __n,
 _CharT __delim) {
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 744
 if (__sentry) {
 if (__n > 0) {
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 this->_M_gcount = __buf->egptr() != __buf->gptr()
 ? _M_read_buffered(this, __buf, __n - 1, __s,
 _Eq_char_bound<_Traits>(__delim),
 _Scan_for_char_val<_Traits>(__delim),
 true, true, true)
 : _M_read_unbuffered(this, __buf, __n - 1, __s,
 _Eq_char_bound<_Traits>(__delim),
 true, true, true);
 }
 }

#line 758
 if (this->_M_gcount == 0)
 this->setstate(ios_base::failbit);

#line 761
 return *this;
}

#line 766
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 773
 if (__sentry && !this->eof()) {
 basic_streambuf<_CharT, _Traits>*__buf = this->rdbuf();
 if (__buf->gptr() != __buf->egptr())
 _M_gcount
 = _M_read_buffered(this, __buf, __n, __s,
 _Constant_unary_fun<bool, int_type>(false),
 _Project2nd<const _CharT*, const _CharT*>(),
 false, false, false);
 else
 _M_gcount
 = _M_read_unbuffered(this, __buf, __n, __s,
 _Constant_unary_fun<bool, int_type>(false),
 false, false, false);
 }
 else
 this->setstate(ios_base::failbit);

#line 790
 if (this->eof())
 this->setstate(ios_base::eofbit | ios_base::failbit);

#line 793
 return *this;
}

#line 799
template <class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __nmax)
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 806
 if (__sentry && !this->eof() && __nmax >= 0) {

#line 808
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 streamsize __avail = __buf->in_avail();

#line 812
 if (__avail == -1)
 this->_M_setstate_nothrow(ios_base::eofbit);

#line 815
 else if (__avail != 0) {

#line 817
 if (__buf->gptr() != __buf->egptr())
 _M_gcount
 = _M_read_buffered(this, __buf, (min) (__avail, __nmax), __s,
 _Constant_unary_fun<bool, int_type>(false),
 _Project2nd<const _CharT*, const _CharT*>(),
 false, false, false);
 else
 _M_gcount
 = _M_read_unbuffered(this, __buf, (min) (__avail, __nmax), __s,
 _Constant_unary_fun<bool, int_type>(false),
 false, false, false);
 }
 }
 else {

#line 832
 if (this->eof())
 this->setstate(ios_base::eofbit | ios_base::failbit);
 else
 this->setstate(ios_base::failbit);
 }

#line 841
 return _M_gcount;
}

#line 844
template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT* __s)
{
 sentry __sentry(*this);

#line 849
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 streamsize __nmax = this->width() > 0
 ? this->width() - 1
 : (numeric_limits<streamsize>::max)() / sizeof(_CharT) - 1;

#line 855
 streamsize __n = __buf->gptr() != __buf->egptr()
 ? _M_read_buffered(this, __buf, __nmax, __s,
 _Is_wspace_null<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
 _Scan_wspace_null<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
 false, true, false)
 : _M_read_unbuffered(this, __buf, __nmax, __s,
 _Is_wspace_null<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
 false, true, false);
 if (__n == 0)
 this->setstate(ios_base::failbit);
 }
 this->width(0);
}

#line 874
template < class _CharT, class _Traits, class _Is_Delim>
void
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
 basic_streambuf<_CharT, _Traits>* __buf,
 _Is_Delim __is_delim,
 bool __extract_delim, bool __set_failbit)
{
 bool __done = false;
 ios_base::iostate __status = 0;
 typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

#line 885
 try {
 while (!__done) {
 int_type __c = __buf->sbumpc();

#line 889
 if (__that->_S_eof(__c)) {
 __done = true;
 __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
 : ios_base::eofbit;
 }

#line 895
 else if (__is_delim(__c)) {
 __done = true;
 if (!__extract_delim)
 if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
 __status |= ios_base::failbit;
 }
 }
 }
 catch(...) {
 __that->_M_handle_exception(ios_base::badbit);
 }

#line 907
 __that->setstate(__status);
}

#line 915
template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
void
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
 basic_streambuf<_CharT, _Traits>* __buf,
 _Is_Delim __is_delim, _Scan_Delim __scan_delim,
 bool __extract_delim, bool __set_failbit)
{
 bool __at_eof = false;
 bool __found_delim = false;

#line 925
 try {
 while (__buf->_M_egptr() != __buf->_M_gptr() && !__at_eof && !__found_delim) {
 const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
 __buf->_M_gbump((int)(__p - __buf->_M_gptr()));

#line 930
 if (__p != __buf->_M_egptr()) {
 if (__extract_delim)
 __buf->_M_gbump(1);
 __found_delim = true;
 }

#line 936
 else
 __at_eof = __that->_S_eof(__buf->sgetc());
 }
 }
 catch(...) {
 __that->_M_handle_exception(ios_base::badbit);
 return;
 }

#line 945
 if (__at_eof) {
 __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
 : ios_base::eofbit);
 return;
 }
 if (__found_delim)
 return;

#line 957
 _M_ignore_unbuffered(__that, __buf, __is_delim, __extract_delim, __set_failbit);
}

#line 971
template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim>
streamsize
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
 basic_streambuf<_CharT, _Traits>* __buf,
 streamsize _Num, _Max_Chars __max_chars,
 _Is_Delim __is_delim,
 bool __extract_delim, bool __set_failbit)
{
 streamsize __n = 0;
 ios_base::iostate __status = 0;
 typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

#line 983
 try {
 while (__max_chars(_Num, __n) > 0) {
 int_type __c = __buf->sbumpc();

#line 987
 if (__that->_S_eof(__c)) {
 __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
 : ios_base::eofbit;
 break;
 }

#line 993
 else if (__is_delim(__c)) {
 if (__extract_delim)
 ++__n;
 else if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
 __status |= ios_base::failbit;

#line 999
 break;
 }

#line 1002
 ++__n;
 }
 }
 catch(...) {
 __that->_M_handle_exception(ios_base::badbit);
 }

#line 1009
 if (__status)
 __that->setstate(__status);
 return __n;
}

#line 1014
template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim, class _Scan_Delim>
streamsize
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
 basic_streambuf<_CharT, _Traits>* __buf,
 streamsize _Num,
 _Max_Chars __max_chars,
 _Is_Delim __is_delim, _Scan_Delim __scan_delim,
 bool __extract_delim, bool __set_failbit)
{
 streamsize __n = 0;
 bool __at_eof = false;
 bool __done = false;

#line 1027
 try {
 while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
 ptrdiff_t __avail = __buf->_M_egptr() - __buf->_M_gptr();
 streamsize __m = __max_chars(_Num, __n);

#line 1032
 if (__avail >= __m) {
 const _CharT* __last = __buf->_M_gptr() + __m;
 const _CharT* __p = __scan_delim(__buf->_M_gptr(), __last);
 ptrdiff_t __chunk = __p - __buf->_M_gptr();
 __n += __chunk;
 __buf->_M_gbump((int)__chunk);

#line 1039
 if (__extract_delim && __p != __last) {
 __n += 1;
 __buf->_M_gbump(1);
 }

#line 1044
 __done = true;
 }

#line 1047
 else {
 const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
 ptrdiff_t __chunk = __p - __buf->_M_gptr();
 __n += __chunk;
 __buf->_M_gbump((int)__chunk);

#line 1053
 if (__p != __buf->_M_egptr()) {
 if (__extract_delim) {
 __n += 1;
 __buf->_M_gbump(1);
 }

#line 1059
 __done = true;
 }

#line 1063
 else if (__that->_S_eof(__buf->sgetc())) {
 __done = true;
 __at_eof = true;
 }
 }
 }
 }
 catch(...) {
 __that->_M_handle_exception(ios_base::badbit);
 return __n;
 }

#line 1075
 if (__at_eof)
 __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
 : ios_base::eofbit);

#line 1079
 if (__done)
 return __n;

#line 1087
 return __n + _M_ignore_unbuffered( __that, __buf, _Num, __max_chars,
 __is_delim, __extract_delim, __set_failbit);
}

#line 1092
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n)
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 1099
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 typedef _Constant_unary_fun<bool, int_type> _Const_bool;
 typedef _Constant_binary_fun<streamsize, streamsize, streamsize>
 _Const_streamsize;
 const streamsize __maxss = (numeric_limits<streamsize>::max)();

#line 1106
 if (__n == (numeric_limits<int>::max)()) {
 if (__buf->gptr() != __buf->egptr())
 _M_gcount
 = _M_ignore_buffered(this, __buf,
 __maxss, _Const_streamsize(__maxss),
 _Const_bool(false),
 _Project2nd<const _CharT*, const _CharT*>(),
 false, false);
 else
 _M_gcount = _M_ignore_unbuffered(this, __buf,
 __maxss, _Const_streamsize(__maxss),
 _Const_bool(false), false, false);
 }
 else {
 if (__buf->gptr() != __buf->egptr())
 _M_gcount
 = _M_ignore_buffered(this, __buf,
 __n, minus<streamsize>(),
 _Const_bool(false),
 _Project2nd<const _CharT*, const _CharT*>(),
 false, false);
 else
 _M_gcount = _M_ignore_unbuffered(this, __buf, __n, minus<streamsize>(),
 _Const_bool(false), false, false);
 }
 }

#line 1133
 return *this;
}

#line 1136
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __delim)
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 1143
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 typedef _Constant_unary_fun<bool, int_type> _Const_bool;
 typedef _Constant_binary_fun<streamsize, streamsize, streamsize>
 _Const_streamsize;
 const streamsize __maxss = (numeric_limits<streamsize>::max)();

#line 1150
 if (__n == (numeric_limits<int>::max)()) {
 if (__buf->gptr() != __buf->egptr())
 _M_gcount = _M_ignore_buffered(this, __buf,
 __maxss, _Const_streamsize(__maxss),
 _Eq_int_bound<_Traits>(__delim),
 _Scan_for_int_val<_Traits>(__delim),
 true, false);
 else
 _M_gcount = _M_ignore_unbuffered(this, __buf,
 __maxss, _Const_streamsize(__maxss),
 _Eq_int_bound<_Traits>(__delim),
 true, false);
 }
 else {
 if (__buf->gptr() != __buf->egptr())
 _M_gcount = _M_ignore_buffered(this, __buf,
 __n, minus<streamsize>(),
 _Eq_int_bound<_Traits>(
 __delim),
 _Scan_for_int_val<_Traits>(__delim),
 true, false);
 else
 _M_gcount = _M_ignore_unbuffered(this, __buf, __n, minus<streamsize>(),
 _Eq_int_bound<_Traits>(__delim),
 true, false);
 }
 }

#line 1178
 return *this;
}

#line 1183
template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_skip_whitespace(bool __set_failbit)
{
 basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
 if (!__buf)
 this->setstate(ios_base::badbit);
 else if (__buf->gptr() != __buf->egptr())
 _M_ignore_buffered(this, __buf,
 _Is_not_wspace<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
 _Scan_for_not_wspace<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
 false, __set_failbit);
 else
 _M_ignore_unbuffered(this, __buf,
 _Is_not_wspace<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
 false, __set_failbit);
}

#line 1208
template < class _CharT, class _Traits, class _Is_Delim>
streamsize
_M_copy_unbuffered( basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
 basic_streambuf<_CharT, _Traits>* __dest,
 _Is_Delim __is_delim,
 bool __extract_delim, bool __rethrow)
{
 streamsize __extracted = 0;
 ios_base::iostate __status = 0;
 typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
 int_type __c;

#line 1220
 try {

#line 1222
 while (true) {

#line 1225
 __c = __src->sbumpc();

#line 1228
 if (__that->_S_eof(__c)) {
 __status |= ios_base::eofbit;
 break;
 }

#line 1233
 else if (__is_delim(__c)) {
 if (!__extract_delim && !__pushback(__src, _Traits::to_char_type(__c)))
 __status |= ios_base::failbit;
 break;
 }

#line 1239
 else {

#line 1242
 bool __failed = false;
 try {
 if (!__that->_S_eof(__dest->sputc(__c)))
 ++__extracted;
 else
 __failed = true;
 }
 catch(...) {
 __failed = true;
 }

#line 1255
 if (__failed && !__pushback(__src, _Traits::to_char_type(__c)))
 __status |= ios_base::failbit;

#line 1259
 if (__failed)
 break;
 }

#line 1263
 }

#line 1265
 }

#line 1268
 catch(...) {

#line 1270
 if (__rethrow && __extracted == 0)
 __that->_M_handle_exception(ios_base::failbit);
 }
 __that->setstate(__status);
 return __extracted;
}

#line 1282
template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize
_M_copy_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
 basic_streambuf<_CharT, _Traits>* __dest,
 _Scan_Delim __scan_delim, _Is_Delim __is_delim,
 bool __extract_delim, bool __rethrow)
{
 streamsize __extracted = 0;
 ios_base::iostate __status = 0;
 typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
 int_type __c = _Traits::eof();
 _CharT* __first = __src->_M_gptr();
 ptrdiff_t __avail = __src->_M_egptr() - __first;

#line 1296
 bool __do_handle_exceptions;

#line 1298
 try {
 while (true) {
 __do_handle_exceptions = false ;
 const _CharT* __last = __scan_delim(__first, __src->_M_egptr());

#line 1304
 streamsize __n = __dest->sputn(__first, __extract_delim && __last != __src->_M_egptr()
 ? (__last - __first) + 1
 : (__last - __first));
 __src->_M_gbump((int)__n);
 __extracted += __n;

#line 1311
 __do_handle_exceptions = true;

#line 1313
 if (__n < __avail)
 break;

#line 1316
 __c = __src->sgetc();

#line 1320
 __first = __src->_M_gptr();
 __avail = __src->_M_egptr() - __first;

#line 1323
 if (__avail > 0)
 {}
 else if (__that->_S_eof(__c)) {
 __status |= ios_base::eofbit;
 break;
 }
 else
 return __extracted + _M_copy_unbuffered(__that, __src, __dest, __is_delim,
 __extract_delim, __rethrow);
 }
 }

#line 1335
 catch(...) {

#line 1337
 if (__rethrow && __do_handle_exceptions && __extracted == 0)
 __that->_M_handle_exception(ios_base::failbit);
 }

#line 1341
 if (__status)
 __that->setstate(__status);
 return __extracted;
}

#line 1348
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
 ::get(basic_streambuf<_CharT, _Traits>& __dest, _CharT __delim)
{
 sentry __sentry(*this, _No_Skip_WS());
 this->_M_gcount = 0;

#line 1356
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();

#line 1359
 if (__src)
 this->_M_gcount = __src->egptr() != __src->gptr()
 ? _M_copy_buffered(this, __src, &__dest,
 _Scan_for_char_val<_Traits>(__delim),
 _Eq_char_bound<_Traits>(__delim),
 false, false)
 : _M_copy_unbuffered(this, __src, &__dest,
 _Eq_char_bound<_Traits>(__delim),
 false, false);
 }

#line 1370
 if (this->_M_gcount == 0)
 this->setstate(ios_base::failbit);

#line 1373
 return *this;
}

#line 1377
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
 ::operator>>(basic_streambuf<_CharT, _Traits>* __dest)
{
 streamsize __n = 0;
 typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
 _Sentry __sentry(*this);
 if (__sentry) {
 basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();
 if (__src && __dest)
 __n = __src->egptr() != __src->gptr()
 ? _M_copy_buffered(this, __src, __dest,
 _Project2nd<const _CharT*, const _CharT*>(),
 _Constant_unary_fun<bool, int_type>(false),
 false, true)
 : _M_copy_unbuffered(this, __src, __dest,
 _Constant_unary_fun<bool, int_type>(false),
 false, true);
 }

#line 1398
 if (__n == 0)
 this->setstate(ios_base::failbit);

#line 1401
 return *this;
}

#line 1408
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>
 ::basic_iostream(basic_streambuf<_CharT, _Traits>* __buf)
 : basic_ios<_CharT, _Traits>(),
 basic_istream<_CharT, _Traits>(__buf),
 basic_ostream<_CharT, _Traits>(__buf)
{
 this->init(__buf);
}

#line 1418
template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{}

#line 1422
 }
#line 338 "../../stlport/stl/_istream.h"

#line 35 "../../stlport/iostream"


#line 36
 namespace _STL {

#line 54
 extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;

#line 60
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;

#line 69
static ios_base::_Loc_init _LocInit;

#line 75
static ios_base::Init _IosInit;

#line 78
 }
#line 1 "../../stlport/stl/_epilog.h"

#line 1 "../../stlport/config/_epilog.h"

#line 11 "../../stlport/stl/_epilog.h"

#line 1 "../../stlport/stl/_config_compat_post.h"

#line 15 "../../stlport/stl/_epilog.h"


#line 34
 namespace _STL {}

#line 35
namespace std {
 using namespace _STL ;
}
#line 90 "../../stlport/iostream"

#line 9 "hmap1.cpp"

#line 1 "../../stlport/hash_map"

#line 1 "../../stlport/stl/_prolog.h"

#line 1 "../../stlport/config/_prolog.h"

#line 17 "../../stlport/stl/_prolog.h"

#line 25 "../../stlport/hash_map"

#line 1 "../../stlport/stl/_hash_map.h"

#line 1 "../../stlport/stl/_hashtable.h"

#line 1 "../../stlport/stl/_vector.h"


#line 58
 namespace _STL {

#line 64
 template <class _Tp, class _Alloc>
class _Vector_base {
public:

#line 68
 typedef typename _Alloc_traits<_Tp,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_Tp>::other _STLP_dummy_type2;
 typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;

#line 71
 _Vector_base(const _Alloc& __a)
 : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {
 }
 _Vector_base(size_t __n, const _Alloc& __a)
 : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0)
 {
 _M_start = _M_end_of_storage.allocate(__n);
 _M_finish = _M_start;
 _M_end_of_storage._M_data = _M_start + __n;

#line 81
 }

#line 83
 ~_Vector_base() {
 if (_M_start !=0)
 _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);
 }

#line 88
protected:
 _Tp* _M_start;
 _Tp* _M_finish;
 _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _M_end_of_storage;
};

#line 94
template <class _Tp, class _Alloc = allocator< _Tp > >
class vector : public _Vector_base<_Tp, _Alloc>
{
private:
 typedef _Vector_base<_Tp, _Alloc> _Base;
public:
 typedef _Tp value_type;
 typedef value_type* pointer;
 typedef const value_type* const_pointer;
 typedef value_type* iterator;
 typedef const value_type* const_iterator;

#line 106
public:
 typedef value_type& reference;
 typedef const value_type& const_reference;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef random_access_iterator_tag _Iterator_category;

#line 113
 typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator ;
 typedef typename _Alloc_traits<_Tp,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_Tp>::other _STLP_dummy_type2;
 typedef typename _Vector_base<_Tp, _Alloc>::allocator_type allocator_type;

#line 117
 allocator_type get_allocator() const {
 return (const allocator_type&)this->_M_end_of_storage ;
 }
protected:
 typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialAss;
 typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _IsPODType;

#line 125
 void _M_insert_overflow(pointer __position, const _Tp& __x, const __false_type&,
 size_type __fill_len, bool __atend = false) {
 const size_type __old_size = size();
 const size_type __len = __old_size + (max)(__old_size, __fill_len);

#line 130
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = __new_start;
 try {
 __new_finish = __uninitialized_copy(this->_M_start, __position, __new_start, __false_type());

#line 135
 if (__fill_len == 1) {
 _Construct(__new_finish, __x);
 ++__new_finish;
 } else
 __new_finish = __uninitialized_fill_n(__new_finish, __fill_len, __x, __false_type());
 if (!__atend)

#line 142
 __new_finish = __uninitialized_copy(__position, this->_M_finish, __new_finish, __false_type());
 }
 catch(...) { (_Destroy(__new_start,__new_finish), this->_M_end_of_storage.deallocate(__new_start,__len)); throw; } ;

 _M_clear();
 _M_set(__new_start, __new_finish, __new_start + __len);
 }

#line 150
 void _M_insert_overflow(pointer __position, const _Tp& __x, const __true_type&,
 size_type __fill_len, bool __atend = false) {
 const size_type __old_size = size();
 const size_type __len = __old_size + (max)(__old_size, __fill_len);

#line 155
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = (pointer)__copy_trivial(this->_M_start, __position, __new_start);

#line 158
 __new_finish = fill_n(__new_finish, __fill_len, __x);
 if (!__atend)

#line 161
 __new_finish = (pointer)__copy_trivial(__position, this->_M_finish, __new_finish);
 _M_clear();
 _M_set(__new_start, __new_finish, __new_start + __len);
 }

#line 166
 void _M_range_check(size_type __n) const {
 if (__n >= size_type(this->_M_finish-this->_M_start))
 __stl_throw_out_of_range("vector");
 }

#line 171
public:
 iterator begin() { return this->_M_start; }
 const_iterator begin() const { return this->_M_start; }
 iterator end() { return this->_M_finish; }
 const_iterator end() const { return this->_M_finish; }

#line 177
 reverse_iterator rbegin() { return reverse_iterator(end()); }
 const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 reverse_iterator rend() { return reverse_iterator(begin()); }
 const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }

#line 182
 size_type size() const { return size_type(this->_M_finish - this->_M_start); }
 size_type max_size() const { return size_type(-1) / sizeof(_Tp); }
 size_type capacity() const { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }
 bool empty() const { return this->_M_start == this->_M_finish; }

#line 187
 reference operator[](size_type __n) { return *(begin() + __n); }
 const_reference operator[](size_type __n) const { return *(begin() + __n); }

#line 190
 reference front() { return *begin(); }
 const_reference front() const { return *begin(); }
 reference back() { return *(end() - 1); }
 const_reference back() const { return *(end() - 1); }

#line 195
 reference at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
 const_reference at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }

#line 198
 explicit vector (const allocator_type& __a = allocator_type()) :
 _Vector_base<_Tp, _Alloc>(__a) {}

#line 201
 vector (size_type __n, const _Tp& __val,
 const allocator_type& __a = allocator_type())
 : _Vector_base<_Tp, _Alloc>(__n, __a) {
 this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __val);
 }

#line 207
 explicit vector (size_type __n)
 : _Vector_base<_Tp, _Alloc>(__n, allocator_type() ) {
 this->_M_finish = uninitialized_fill_n(this->_M_start, __n, _Tp());
 }

#line 212
 vector (const vector <_Tp, _Alloc>& __x)
 : _Vector_base<_Tp, _Alloc>(__x.size(), __x.get_allocator()) {
 this->_M_finish = __uninitialized_copy((const_pointer)__x._M_start,
 (const_pointer)__x._M_finish, this->_M_start, _IsPODType());
 }

#line 220
 template <class _Integer>
 void _M_initialize_aux(_Integer __n, _Integer __val, const __true_type&) {
 this->_M_start = this->_M_end_of_storage.allocate(__n);
 this->_M_end_of_storage._M_data = this->_M_start + __n;
 this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __val);
 }

#line 227
 template <class _InputIterator>
 void _M_initialize_aux(_InputIterator __first, _InputIterator __last,
 const __false_type&) {
 _M_range_initialize(__first, __last, typename iterator_traits< _InputIterator >::iterator_category() );
 }

#line 242
 template <class _InputIterator>
 vector (_InputIterator __first, _InputIterator __last,
 const allocator_type& __a = allocator_type() ) :
 _Vector_base<_Tp, _Alloc>(__a) {
 typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
 _M_initialize_aux(__first, __last, _Integral());
 }

#line 258
 ~ vector () { _Destroy(this->_M_start, this->_M_finish); }

#line 260
 vector <_Tp, _Alloc>& operator=(const vector <_Tp, _Alloc>& __x);

#line 262
 void reserve(size_type __n);

#line 269
 void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
 void _M_fill_assign(size_type __n, const _Tp& __val);

#line 273
 template <class _ForwardIter>
 void _M_assign_aux(_ForwardIter __first, _ForwardIter __last, const forward_iterator_tag &)

#line 278
 {
 size_type __len = distance(__first, __last);

#line 281
 if (__len > capacity()) {
 iterator __tmp = _M_allocate_and_copy(__len, __first, __last);
 _M_clear();
 _M_set(__tmp, __tmp + __len, __tmp + __len);
 }
 else if (size() >= __len) {
 iterator __new_finish = copy(__first, __last, this->_M_start);
 _Destroy(__new_finish, this->_M_finish);
 this->_M_finish = __new_finish;
 }
 else {

#line 293
 _ForwardIter __mid = __first;
 advance(__mid, size());

#line 298
 copy(__first, __mid, this->_M_start);
 this->_M_finish = __uninitialized_copy(__mid, __last, this->_M_finish, _IsPODType());
 }
 }

#line 304
 template <class _InputIter>
 void _M_assign_aux(_InputIter __first, _InputIter __last,
 const input_iterator_tag &) {
 iterator __cur = begin();
 for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
 *__cur = *__first;
 if (__first == __last)
 erase(__cur, end());
 else
 insert(end(), __first, __last);
 }

#line 316
 template <class _Integer>
 void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
 { assign((size_type) __n, (_Tp) __val); }

#line 320
 template <class _InputIter>
 void _M_assign_dispatch(_InputIter __first, _InputIter __last, const __false_type&)
 { _M_assign_aux(__first, __last, typename iterator_traits< _InputIter >::iterator_category() ); }

#line 324
 template <class _InputIterator>
 void assign(_InputIterator __first, _InputIterator __last) {
 typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
 }

#line 331
 void push_back(const _Tp& __x) {
 if (this->_M_finish != this->_M_end_of_storage._M_data) {
 _Construct(this->_M_finish, __x);
 ++this->_M_finish;
 }
 else
 _M_insert_overflow(this->_M_finish, __x, _IsPODType(), 1UL, true);
 }

#line 340
 void swap( vector <_Tp, _Alloc>& __x) {
 _STL ::swap(this->_M_start, __x._M_start);
 _STL ::swap(this->_M_finish, __x._M_finish);
 _STL ::swap(this->_M_end_of_storage, __x._M_end_of_storage);
 }

#line 346
 iterator insert(iterator __position, const _Tp& __x) {
 size_type __n = __position - begin();
 if (this->_M_finish != this->_M_end_of_storage._M_data) {
 if (__position == end()) {
 _Construct(this->_M_finish, __x);
 ++this->_M_finish;
 } else {
 _Construct(this->_M_finish, *(this->_M_finish - 1));
 ++this->_M_finish;
 _Tp __x_copy = __x;
 __copy_backward_ptrs(__position, this->_M_finish - 2, this->_M_finish - 1, _TrivialAss());
 *__position = __x_copy;
 }
 }
 else
 _M_insert_overflow(__position, __x, _IsPODType(), 1UL);
 return begin() + __n;
 }

#line 366
 void push_back() { push_back(_Tp()); }
 iterator insert(iterator __position) { return insert(__position, _Tp()); }

#line 370
 void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);

#line 374
 template <class _Integer>
 void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
 const __true_type&) {
 _M_fill_insert(__pos, (size_type) __n, (_Tp) __val);
 }

#line 380
 template <class _InputIterator>
 void _M_insert_dispatch(iterator __pos,
 _InputIterator __first, _InputIterator __last,
 const __false_type&) {
 _M_range_insert(__pos, __first, __last, typename iterator_traits< _InputIterator >::iterator_category() );
 }

#line 388
 template <class _InputIterator>
 void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
 typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
 _M_insert_dispatch(__pos, __first, __last, _Integral());
 }

#line 394
 template <class _InputIterator>
 void _M_range_insert(iterator __pos,
 _InputIterator __first,
 _InputIterator __last,
 const input_iterator_tag &) {
 for ( ; __first != __last; ++__first) {
 __pos = insert(__pos, *__first);
 ++__pos;
 }
 }

#line 405
 template <class _ForwardIterator>
 void _M_range_insert(iterator __position,
 _ForwardIterator __first,
 _ForwardIterator __last,
 const forward_iterator_tag &)

#line 415
 {
 if (__first != __last) {
 size_type __n = distance(__first, __last);

#line 419
 if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
 const size_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after > __n) {
 __uninitialized_copy(this->_M_finish - __n, this->_M_finish, this->_M_finish, _IsPODType());
 this->_M_finish += __n;
 __copy_backward_ptrs(__position, __old_finish - __n, __old_finish, _TrivialAss());
 copy(__first, __last, __position);
 }
 else {

#line 430
 _ForwardIterator __mid = __first;
 advance(__mid, __elems_after);

#line 435
 __uninitialized_copy(__mid, __last, this->_M_finish, _IsPODType());
 this->_M_finish += __n - __elems_after;
 __uninitialized_copy(__position, __old_finish, this->_M_finish, _IsPODType());
 this->_M_finish += __elems_after;
 copy(__first, __mid, __position);
 }
 }
 else {
 const size_type __old_size = size();
 const size_type __len = __old_size + (max)(__old_size, __n);
 pointer __new_start = this->_M_end_of_storage.allocate(__len);
 pointer __new_finish = __new_start;
 try {
 __new_finish = __uninitialized_copy(this->_M_start, __position, __new_start, _IsPODType());
 __new_finish = __uninitialized_copy(__first, __last, __new_finish, _IsPODType());
 __new_finish = __uninitialized_copy(__position, this->_M_finish, __new_finish, _IsPODType());
 }
 catch(...) { (_Destroy(__new_start,__new_finish), this->_M_end_of_storage.deallocate(__new_start,__len)); throw; } ;

 _M_clear();
 _M_set(__new_start, __new_finish, __new_start + __len);
 }
 }
 }
 void insert (iterator __pos, size_type __n, const _Tp& __x)
 { _M_fill_insert(__pos, __n, __x); }

#line 462
 void pop_back() {
 --this->_M_finish;
 _Destroy(this->_M_finish);
 }
 iterator erase(iterator __position) {
 if (__position + 1 != end())
 __copy_ptrs(__position + 1, this->_M_finish, __position, _TrivialAss());
 --this->_M_finish;
 _Destroy(this->_M_finish);
 return __position;
 }
 iterator erase(iterator __first, iterator __last) {
 pointer __i = __copy_ptrs(__last, this->_M_finish, __first, _TrivialAss());
 _Destroy(__i, this->_M_finish);
 this->_M_finish = __i;
 return __first;
 }

#line 480
 void resize(size_type __new_size, const _Tp& __x) {
 if (__new_size < size())
 erase(begin() + __new_size, end());
 else
 insert(end(), __new_size - size(), __x);
 }
 void resize(size_type __new_size) { resize(__new_size, _Tp()); }
 void clear() {
 erase(begin(), end());
 }

#line 491
protected:

#line 493
 void _M_clear() {

#line 495
 _Destroy(this->_M_start, this->_M_finish);
 this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);

#line 498
 }

#line 500
 void _M_set(pointer __s, pointer __f, pointer __e) {
 this->_M_start = __s;
 this->_M_finish = __f;
 this->_M_end_of_storage._M_data = __e;
 }

#line 507
 template <class _ForwardIterator>
 pointer _M_allocate_and_copy(size_type __n, _ForwardIterator __first,
 _ForwardIterator __last)

#line 514
 {
 pointer __result = this->_M_end_of_storage.allocate(__n);
 try {

#line 518
 __uninitialized_copy(__first, __last, __result, _IsPODType());

#line 522
 return __result;
 }
 catch(...) { this->_M_end_of_storage.deallocate(__result, __n); throw; } ;

#line 528
 }

#line 532
 template <class _InputIterator>
 void _M_range_initialize(_InputIterator __first,
 _InputIterator __last, const input_iterator_tag &) {
 for ( ; __first != __last; ++__first)
 push_back(*__first);
 }

#line 539
 template <class _ForwardIterator>
 void _M_range_initialize(_ForwardIterator __first,
 _ForwardIterator __last, const forward_iterator_tag &) {
 size_type __n = distance(__first, __last);
 this->_M_start = this->_M_end_of_storage.allocate(__n);
 this->_M_end_of_storage._M_data = this->_M_start + __n;
 this->_M_finish = __uninitialized_copy(__first, __last, this->_M_start, _IsPODType());
 }

#line 549
};
#line 1 "../../stlport/stl/_relops_cont.h"


#line 5
 template <class _Tp, class _Alloc>
 inline bool operator==(const vector<_Tp, _Alloc> & __x,
 const vector<_Tp, _Alloc> & __y) {
 return __x.size() == __y.size() &&
 equal(__x.begin(), __x.end(), __y.begin());
}

#line 12
 template <class _Tp, class _Alloc>
 inline bool operator<(const vector<_Tp, _Alloc> & __x,
 const vector<_Tp, _Alloc> & __y) {
 return lexicographical_compare(__x.begin(), __x.end(),
 __y.begin(), __y.end());
}

#line 19
 template <class _Tp, class _Alloc> inline bool operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return !(__x == __y);}template <class _Tp, class _Alloc> inline bool operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return __y < __x;}template <class _Tp, class _Alloc> inline bool operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__y < __x);}template <class _Tp, class _Alloc> inline bool operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__x < __y);}

#line 22
 template <class _Tp, class _Alloc>
 inline void swap( vector<_Tp, _Alloc> & __x,
 vector<_Tp, _Alloc> & __y) {
 __x.swap(__y);
}
#line 554 "../../stlport/stl/_vector.h"


#line 568
 }
#line 1 "../../stlport/stl/_vector.c"


#line 41
 namespace _STL {

#line 43
 template <class _Tp, class _Alloc>
void
 vector <_Tp, _Alloc>::reserve(size_type __n) {
 if (capacity() < __n) {
 const size_type __old_size = size();
 pointer __tmp;
 if (this->_M_start) {
 __tmp = _M_allocate_and_copy(__n, this->_M_start, this->_M_finish);
 _M_clear();
 } else {
 __tmp = this->_M_end_of_storage.allocate(__n);
 }
 _M_set(__tmp, __tmp + __old_size, __tmp + __n);
 }
}

#line 59
template <class _Tp, class _Alloc>
void
 vector <_Tp, _Alloc>::_M_fill_insert(
 iterator __position,
 size_type __n, const _Tp& __x) {
 if (__n != 0) {
 if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
 _Tp __x_copy = __x;
 const size_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after > __n) {
 __uninitialized_copy(this->_M_finish - __n, this->_M_finish, this->_M_finish, _IsPODType());
 this->_M_finish += __n;
 __copy_backward_ptrs(__position, __old_finish - __n, __old_finish, _TrivialAss());
 _STL ::fill(__position, __position + __n, __x_copy);
 }
 else {
 uninitialized_fill_n(this->_M_finish, __n - __elems_after, __x_copy);
 this->_M_finish += __n - __elems_after;
 __uninitialized_copy(__position, __old_finish, this->_M_finish, _IsPODType());
 this->_M_finish += __elems_after;
 _STL ::fill(__position, __old_finish, __x_copy);
 }
 }
 else
 _M_insert_overflow(__position, __x, _IsPODType(), __n);
 }
}

#line 88
template <class _Tp, class _Alloc>
 vector <_Tp,_Alloc>&
 vector <_Tp,_Alloc>::operator=(const vector <_Tp, _Alloc>& __x)
{
 if (&__x != this) {
 const size_type __xlen = __x.size();
 if (__xlen > capacity()) {
 pointer __tmp = _M_allocate_and_copy(__xlen, (const_pointer)__x._M_start+0, (const_pointer)__x._M_finish+0);
 _M_clear();
 this->_M_start = __tmp;
 this->_M_end_of_storage._M_data = this->_M_start + __xlen;
 }
 else if (size() >= __xlen) {
 pointer __i = __copy_ptrs((const_pointer)__x._M_start+0, (const_pointer)__x._M_finish+0, (pointer)this->_M_start, _TrivialAss());
 _Destroy(__i, this->_M_finish);
 }
 else {
 __copy_ptrs((const_pointer)__x._M_start, (const_pointer)__x._M_start + size(), (pointer)this->_M_start, _TrivialAss());
 __uninitialized_copy((const_pointer)__x._M_start + size(), (const_pointer)__x._M_finish+0, this->_M_finish, _IsPODType());
 }
 this->_M_finish = this->_M_start + __xlen;
 }
 return *this;
}

#line 113
template <class _Tp, class _Alloc>
void vector <_Tp, _Alloc>::_M_fill_assign(size_t __n, const _Tp& __val) {
 if (__n > capacity()) {
 vector <_Tp, _Alloc> __tmp(__n, __val, get_allocator());
 __tmp.swap(*this);
 }
 else if (__n > size()) {
 fill(begin(), end(), __val);
 this->_M_finish = _STL ::uninitialized_fill_n(this->_M_finish, __n - size(), __val);
 }
 else
 erase( _STL ::fill_n(begin(), __n, __val), end());
}

#line 127
 }
#line 572 "../../stlport/stl/_vector.h"

#line 1 "../../stlport/stl/_bvector.h"


#line 39
 namespace _STL {

#line 41
 struct _Bit_reference {
 unsigned int* _M_p;
 unsigned int _M_mask;
 _Bit_reference(unsigned int* __x, unsigned int __y)
 : _M_p(__x), _M_mask(__y) {}

#line 47
public:
 _Bit_reference() : _M_p(0), _M_mask(0) {}
 operator bool() const { return !(!(*_M_p & _M_mask)); }
 _Bit_reference& operator=(bool __x)
 {
 if (__x) *_M_p |= _M_mask;
 else *_M_p &= ~_M_mask;
 return *this;
 }
 _Bit_reference& operator=(const _Bit_reference& __x)
 { return *this = bool(__x); }
 bool operator==(const _Bit_reference& __x) const
 { return bool(*this) == bool(__x); }
 bool operator<(const _Bit_reference& __x) const {
 return !bool(*this) && bool(__x);
 }
 void flip() { *_M_p ^= _M_mask; }
};

#line 66
inline void swap(_Bit_reference __x, _Bit_reference& __y)
{
 bool __tmp = (bool)__x;
 __x = __y;
 __y = __tmp;
}

#line 73
struct _Bit_iterator_base;

#line 75
struct _Bit_iterator_base
{
 typedef ptrdiff_t difference_type;

#line 79
 unsigned int* _M_p;
 unsigned int _M_offset;

#line 82
 void _M_bump_up() {
 if (_M_offset++ == (int( 8*sizeof(unsigned int))) - 1) {
 _M_offset = 0;
 ++_M_p;
 }
 }

#line 89
 void _M_bump_down() {
 if (_M_offset-- == 0) {
 _M_offset = (int( 8*sizeof(unsigned int))) - 1;
 --_M_p;
 }
 }

#line 96
 _Bit_iterator_base() : _M_p(0), _M_offset(0) {}
 _Bit_iterator_base(unsigned int* __x, unsigned int __y) : _M_p(__x), _M_offset(__y) {}

#line 101
 void _M_advance (difference_type __i) {
 difference_type __n = __i + _M_offset;
 _M_p += __n / (int( 8*sizeof(unsigned int))) ;
 __n = __n % (int( 8*sizeof(unsigned int))) ;
 if (__n < 0) {
 _M_offset = (unsigned int) __n + (int( 8*sizeof(unsigned int))) ;
 --_M_p;
 } else
 _M_offset = (unsigned int) __n;
 }

#line 112
 difference_type _M_subtract(const _Bit_iterator_base& __x) const {
 return (int( 8*sizeof(unsigned int))) * (_M_p - __x._M_p) + _M_offset - __x._M_offset;
 }
};

#line 117
inline bool operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
 return __y._M_p == __x._M_p && __y._M_offset == __x._M_offset;
}
inline bool operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
 return __y._M_p != __x._M_p || __y._M_offset != __x._M_offset;
}

#line 124
inline bool operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
 return __x._M_p < __y._M_p || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
}

#line 128
inline bool operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
 return operator <(__y , __x);
}
inline bool operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
 return !(__y < __x);
}
inline bool operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
 return !(__x < __y);
}

#line 138
template <class _Ref, class _Ptr>
struct _Bit_iter : public _Bit_iterator_base
{
 typedef _Ref reference;
 typedef _Ptr pointer;
 typedef _Bit_iter<_Ref, _Ptr> _Self;
 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef ptrdiff_t difference_type;
 typedef size_t size_type;

#line 149
 _Bit_iter(unsigned int* __x, unsigned int __y) : _Bit_iterator_base(__x, __y) {}
 _Bit_iter() {}

#line 152
 _Bit_iter(const _Bit_iter<_Bit_reference, _Bit_reference*>& __x):
 _Bit_iterator_base((const _Bit_iterator_base&)__x) {}

#line 158
 reference operator*() const {
 return _Bit_reference(_M_p, 1UL << _M_offset);
 }
 _Self& operator++() {
 _M_bump_up();
 return *this;
 }
 _Self operator++(int) {
 _Self __tmp = *this;
 _M_bump_up();
 return __tmp;
 }
 _Self& operator--() {
 _M_bump_down();
 return *this;
 }
 _Self operator--(int) {
 _Self __tmp = *this;
 _M_bump_down();
 return __tmp;
 }
 _Self& operator+=(difference_type __i) {
 _M_advance(__i);
 return *this;
 }
 _Self& operator-=(difference_type __i) {
 *this += -__i;
 return *this;
 }
 _Self operator+(difference_type __i) const {
 _Self __tmp = *this;
 return __tmp += __i;
 }
 _Self operator-(difference_type __i) const {
 _Self __tmp = *this;
 return __tmp -= __i;
 }
 difference_type operator-(const _Self& __x) const {
 return _M_subtract(__x);
 }
 reference operator[](difference_type __i) { return *(*this + __i); }
};

#line 201
template <class _Ref, class _Ptr>
inline _Bit_iter<_Ref,_Ptr>
operator+(ptrdiff_t __n, const _Bit_iter<_Ref, _Ptr>& __x) {
 return __x + __n;
}

#line 214
typedef _Bit_iter<bool, const bool*> _Bit_const_iterator;
typedef _Bit_iter<_Bit_reference, _Bit_reference*> _Bit_iterator;

#line 221
template <class _Alloc>
class _Bvector_base
{
public:
 typedef typename _Alloc_traits<bool,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<bool>::other _STLP_dummy_type2;
 typedef typename _Alloc_traits<bool, _Alloc>::allocator_type allocator_type;
 typedef unsigned int __chunk_type;
 typedef typename _Alloc_traits<__chunk_type,
 _Alloc>::allocator_type __chunk_allocator_type;
 allocator_type get_allocator() const {
 return (const __chunk_allocator_type&)_M_end_of_storage ;
 }
 static allocator_type __get_dfl_allocator() { return allocator_type(); }

#line 235
 _Bvector_base(const allocator_type& __a)
 : _M_start(), _M_finish(), _M_end_of_storage( __a ,
 (__chunk_type*)0) {
 }
 ~_Bvector_base() { _M_deallocate();
 }

#line 242
protected:

#line 244
 unsigned int* _M_bit_alloc(size_t __n)
 { return _M_end_of_storage.allocate((__n + (int( 8*sizeof(unsigned int))) - 1)/ (int( 8*sizeof(unsigned int))) ); }
 void _M_deallocate() {
 if (_M_start._M_p)
 _M_end_of_storage.deallocate(_M_start._M_p,
 _M_end_of_storage._M_data - _M_start._M_p);
 }

#line 252
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _STLP_alloc_proxy<__chunk_type*, __chunk_type, __chunk_allocator_type> _M_end_of_storage;
};

#line 297
 template <class _Alloc>
 class vector <bool, _Alloc> : public _Bvector_base<_Alloc >
{
 typedef _Bvector_base<_Alloc > _Base;
 typedef vector <bool, _Alloc> _Self;
public:
 typedef bool value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Bit_reference reference;
 typedef bool const_reference;
 typedef _Bit_reference* pointer;
 typedef const bool* const_pointer;
 typedef random_access_iterator_tag _Iterator_category;

#line 312
 typedef _Bit_iterator iterator;
 typedef _Bit_const_iterator const_iterator;

#line 316
 typedef _STL ::reverse_iterator<const_iterator> const_reverse_iterator;
 typedef _STL ::reverse_iterator<iterator> reverse_iterator;

#line 333
 typedef typename _Bvector_base<_Alloc >::allocator_type allocator_type;
 typedef typename _Bvector_base<_Alloc >::__chunk_type __chunk_type ;

#line 340
protected:

#line 342
 void _M_initialize(size_type __n) {
 unsigned int* __q = this->_M_bit_alloc(__n);
 this->_M_end_of_storage._M_data = __q + (__n + (int( 8*sizeof(unsigned int))) - 1)/ (int( 8*sizeof(unsigned int))) ;
 this->_M_start = iterator(__q, 0);
 this->_M_finish = this->_M_start + difference_type(__n);
 }
 void _M_insert_aux(iterator __position, bool __x) {
 if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
 __copy_backward(__position, this->_M_finish, this->_M_finish + 1, random_access_iterator_tag(), (difference_type*)0 );
 *__position = __x;
 ++this->_M_finish;
 }
 else {
 size_type __len = size() ? 2 * size() : (int( 8*sizeof(unsigned int))) ;
 unsigned int* __q = this->_M_bit_alloc(__len);
 iterator __i = copy(begin(), __position, iterator(__q, 0));
 *__i++ = __x;
 this->_M_finish = copy(__position, end(), __i);
 this->_M_deallocate();
 this->_M_end_of_storage._M_data = __q + (__len + (int( 8*sizeof(unsigned int))) - 1)/ (int( 8*sizeof(unsigned int))) ;
 this->_M_start = iterator(__q, 0);
 }
 }

#line 367
 template <class _InputIterator>
 void _M_initialize_range(_InputIterator __first, _InputIterator __last,
 const input_iterator_tag &) {
 this->_M_start = iterator();
 this->_M_finish = iterator();
 this->_M_end_of_storage._M_data = 0;
 for ( ; __first != __last; ++__first)
 push_back(*__first);
 }

#line 377
 template <class _ForwardIterator>
 void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
 const forward_iterator_tag &) {
 size_type __n = distance(__first, __last);
 _M_initialize(__n);

#line 383
 copy(__first, __last, this->_M_start);
 }

#line 386
 template <class _InputIterator>
 void _M_insert_range(iterator __pos,
 _InputIterator __first, _InputIterator __last,
 const input_iterator_tag &) {
 for ( ; __first != __last; ++__first) {
 __pos = insert(__pos, *__first);
 ++__pos;
 }
 }

#line 396
 template <class _ForwardIterator>
 void _M_insert_range(iterator __position,
 _ForwardIterator __first, _ForwardIterator __last,
 const forward_iterator_tag &) {
 if (__first != __last) {
 size_type __n = distance(__first, __last);
 if (capacity() - size() >= __n) {
 __copy_backward(__position, end(), this->_M_finish + difference_type(__n), random_access_iterator_tag(), (difference_type*)0 );
 copy(__first, __last, __position);
 this->_M_finish += difference_type(__n);
 }
 else {
 size_type __len = size() + (max)(size(), __n);
 unsigned int* __q = this->_M_bit_alloc(__len);
 iterator __i = copy(begin(), __position, iterator(__q, 0));
 __i = copy(__first, __last, __i);
 this->_M_finish = copy(__position, end(), __i);
 this->_M_deallocate();
 this->_M_end_of_storage._M_data = __q + (__len + (int( 8*sizeof(unsigned int))) - 1)/ (int( 8*sizeof(unsigned int))) ;
 this->_M_start = iterator(__q, 0);
 }
 }
 }

#line 422
public:
 iterator begin() { return this->_M_start; }
 const_iterator begin() const { return this->_M_start; }
 iterator end() { return this->_M_finish; }
 const_iterator end() const { return this->_M_finish; }

#line 428
 reverse_iterator rbegin() { return reverse_iterator(end()); }
 const_reverse_iterator rbegin() const {
 return const_reverse_iterator(end());
 }
 reverse_iterator rend() { return reverse_iterator(begin()); }
 const_reverse_iterator rend() const {
 return const_reverse_iterator(begin());
 }

#line 437
 size_type size() const { return size_type(end() - begin()); }
 size_type max_size() const { return size_type(-1); }
 size_type capacity() const {
 return size_type(const_iterator(this->_M_end_of_storage._M_data, 0) - begin());
 }
 bool empty() const { return begin() == end(); }
 reference operator[](size_type __n)
 { return *(begin() + difference_type(__n)); }
 const_reference operator[](size_type __n) const
 { return *(begin() + difference_type(__n)); }

#line 448
 void _M_range_check(size_type __n) const {
 if (__n >= this->size())
 __stl_throw_range_error("vector<bool>");
 }

#line 453
 reference at(size_type __n)
 { _M_range_check(__n); return (*this)[__n]; }
 const_reference at(size_type __n) const
 { _M_range_check(__n); return (*this)[__n]; }

#line 458
 explicit vector (const allocator_type& __a = allocator_type())
 : _Bvector_base<_Alloc >(__a) {}

#line 461
 vector (size_type __n, bool __val,
 const allocator_type& __a =
 allocator_type())
 : _Bvector_base<_Alloc >(__a)
 {
 _M_initialize(__n);
 fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __val ? ~0 : 0);
 }

#line 470
 explicit vector (size_type __n)
 : _Bvector_base<_Alloc >(allocator_type())
 {
 _M_initialize(__n);
 fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), 0);
 }

#line 477
 vector (const _Self& __x) : _Bvector_base<_Alloc >(__x.get_allocator()) {
 _M_initialize(__x.size());
 copy(__x.begin(), __x.end(), this->_M_start);
 }

#line 483
 template <class _Integer>
 void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
 _M_initialize(__n);
 fill(this->_M_start._M_p, this->_M_end_of_storage._M_data, __x ? ~0 : 0);
 }

#line 489
 template <class _InputIterator>
 void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
 const __false_type&) {
 _M_initialize_range(__first, __last, typename iterator_traits< _InputIterator >::iterator_category() );
 }

#line 504
 template <class _InputIterator>
 vector (_InputIterator __first, _InputIterator __last,
 const allocator_type& __a = allocator_type() )
 : _Base(__a)
 {
 typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
 }

#line 531
 ~ vector () { }

#line 533
 vector <bool, _Alloc> & operator=(const vector <bool, _Alloc> & __x) {
 if (&__x == this) return *this;
 if (__x.size() > capacity()) {
 this->_M_deallocate();
 _M_initialize(__x.size());
 }
 copy(__x.begin(), __x.end(), begin());
 this->_M_finish = begin() + difference_type(__x.size());
 return *this;
 }

#line 549
 void _M_fill_assign(size_t __n, bool __x) {
 if (__n > size()) {
 fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
 insert(end(), __n - size(), __x);
 }
 else {
 erase(begin() + __n, end());
 fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
 }
 }
 void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }

#line 563
 template <class _InputIterator>
 void assign(_InputIterator __first, _InputIterator __last) {
 typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
 }

#line 569
 template <class _Integer>
 void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
 { _M_fill_assign((size_t) __n, (bool) __val); }

#line 573
 template <class _InputIter>
 void _M_assign_dispatch(_InputIter __first, _InputIter __last, const __false_type&)
 { _M_assign_aux(__first, __last, typename iterator_traits< _InputIter >::iterator_category() ); }

#line 577
 template <class _InputIterator>
 void _M_assign_aux(_InputIterator __first, _InputIterator __last,
 const input_iterator_tag &) {
 iterator __cur = begin();
 for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
 *__cur = *__first;
 if (__first == __last)
 erase(__cur, end());
 else
 insert(end(), __first, __last);
 }

#line 589
 template <class _ForwardIterator>
 void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
 const forward_iterator_tag &) {
 size_type __len = distance(__first, __last);
 if (__len < size())
 erase(copy(__first, __last, begin()), end());
 else {
 _ForwardIterator __mid = __first;
 advance(__mid, size());
 copy(__first, __mid, begin());
 insert(end(), __mid, __last);
 }
 }

#line 605
 void reserve(size_type __n) {
 if (capacity() < __n) {
 unsigned int* __q = this->_M_bit_alloc(__n);
 _Bit_iterator __z(__q, 0);
 this->_M_finish = copy(begin(), end(), __z);
 this->_M_deallocate();
 this->_M_start = iterator(__q, 0);
 this->_M_end_of_storage._M_data = __q + (__n + (int( 8*sizeof(unsigned int))) - 1)/ (int( 8*sizeof(unsigned int))) ;
 }
 }

#line 616
 reference front() { return *begin(); }
 const_reference front() const { return *begin(); }
 reference back() { return *(end() - 1); }
 const_reference back() const { return *(end() - 1); }
 void push_back(bool __x) {
 if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
 *(this->_M_finish) = __x;
 ++this->_M_finish;
 }
 else
 _M_insert_aux(end(), __x);
 }
 void swap( vector <bool, _Alloc> & __x) {
 _STL ::swap(this->_M_start, __x._M_start);
 _STL ::swap(this->_M_finish, __x._M_finish);
 _STL ::swap(this->_M_end_of_storage, __x._M_end_of_storage);
 }
 iterator insert(iterator __position, bool __x = bool()) {
 difference_type __n = __position - begin();
 if (this->_M_finish._M_p != this->_M_end_of_storage._M_data && __position == end()) {
 *(this->_M_finish) = __x;
 ++this->_M_finish;
 }
 else
 _M_insert_aux(__position, __x);
 return begin() + __n;
 }

#line 646
 template <class _Integer>
 void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
 const __true_type&) {
 _M_fill_insert(__pos, (size_type) __n, (bool) __x);
 }

#line 652
 template <class _InputIterator>
 void _M_insert_dispatch(iterator __pos,
 _InputIterator __first, _InputIterator __last,
 const __false_type&) {
 _M_insert_range(__pos, __first, __last, typename iterator_traits< _InputIterator >::iterator_category() );
 }

#line 660
 template <class _InputIterator>
 void insert(iterator __position,
 _InputIterator __first, _InputIterator __last) {
 typedef typename _Is_integer<_InputIterator>::_Integral _Is_Integral;
 _M_insert_dispatch(__position, __first, __last, _Is_Integral());
 }

#line 711
 void _M_fill_insert(iterator __position, size_type __n, bool __x) {
 if (__n == 0) return;
 if (capacity() - size() >= __n) {
 __copy_backward(__position, end(), this->_M_finish + difference_type(__n), random_access_iterator_tag(), (difference_type*)0 );
 fill(__position, __position + difference_type(__n), __x);
 this->_M_finish += difference_type(__n);
 }
 else {
 size_type __len = size() + (max)(size(), __n);
 unsigned int* __q = this->_M_bit_alloc(__len);
 iterator __i = copy(begin(), __position, iterator(__q, 0));
 fill_n(__i, __n, __x);
 this->_M_finish = copy(__position, end(), __i + difference_type(__n));
 this->_M_deallocate();
 this->_M_end_of_storage._M_data = __q + (__len + (int( 8*sizeof(unsigned int))) - 1)/ (int( 8*sizeof(unsigned int))) ;
 this->_M_start = iterator(__q, 0);
 }
 }

#line 730
 void insert(iterator __position, size_type __n, bool __x) {
 _M_fill_insert(__position, __n, __x);
 }

#line 734
 void pop_back() {
 --this->_M_finish;
 }
 iterator erase(iterator __position) {
 if (__position + 1 != end())
 copy(__position + 1, end(), __position);
 --this->_M_finish;
 return __position;
 }
 iterator erase(iterator __first, iterator __last) {
 this->_M_finish = copy(__last, end(), __first);
 return __first;
 }
 void resize(size_type __new_size, bool __x = bool()) {
 if (__new_size < size())
 erase(begin() + difference_type(__new_size), end());
 else
 insert(end(), __new_size - size(), __x);
 }
 void flip() {
 for (unsigned int* __p = this->_M_start._M_p; __p != this->_M_end_of_storage._M_data; ++__p)
 *__p = ~*__p;
 }

#line 758
 void clear() { erase(begin(), end()); }
};

#line 763
 template <class _Alloc>
 inline void swap( vector <bool, _Alloc> & __x, vector <bool, _Alloc> & __y) {
 __x.swap(__y);
}

#line 768
 template <class _Alloc>
 inline bool
operator==(const vector <bool, _Alloc> & __x, const vector <bool, _Alloc> & __y)
{
 return (__x.size() == __y.size() &&
 equal(__x.begin(), __x.end(), __y.begin()));
}

#line 777
 template <class _Alloc>
 inline bool
operator<(const vector <bool, _Alloc> & __x, const vector <bool, _Alloc> & __y)
{
 return lexicographical_compare(__x.begin(), __x.end(),
 __y.begin(), __y.end());
}

#line 785
 template <class _Alloc> inline bool operator!=(const vector <bool, _Alloc>& __x, const vector <bool, _Alloc>& __y) {return !(__x == __y);}template <class _Alloc> inline bool operator>(const vector <bool, _Alloc>& __x, const vector <bool, _Alloc>& __y) {return __y < __x;}template <class _Alloc> inline bool operator<=(const vector <bool, _Alloc>& __x, const vector <bool, _Alloc>& __y) { return !(__y < __x);}template <class _Alloc> inline bool operator>=(const vector <bool, _Alloc>& __x, const vector <bool, _Alloc>& __y) { return !(__x < __y);}

#line 791
 typedef vector <bool, allocator<bool> > bit_vector;

#line 794
 }
#line 576 "../../stlport/stl/_vector.h"

#line 35 "../../stlport/stl/_hashtable.h"


#line 60
 namespace _STL {

#line 62
 template <class _Val>
struct _Hashtable_node
{
 typedef _Hashtable_node<_Val> _Self;
 _Self* _M_next;
 _Val _M_val;

#line 69
};

#line 72
template <class _Val, class _Key, class _HF,
 class _ExK, class _EqK, class _All>
class hashtable;

#line 76
template <class _Val, class _Key, class _HF,
 class _ExK, class _EqK, class _All>
struct _Hashtable_iterator
{
 typedef hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 _Hashtable;
 typedef _Hashtable_node<_Val> _Node;

#line 84
 _Node* _M_cur;
 _Hashtable* _M_ht;

#line 87
 _Hashtable_iterator(_Node* __n, _Hashtable* __tab)
 : _M_cur(__n), _M_ht(__tab) {}
 _Hashtable_iterator() {}

#line 91
 _Node* _M_skip_to_next();
};

#line 95
template <class _Val, class _Traits, class _Key, class _HF,
 class _ExK, class _EqK, class _All>
struct _Ht_iterator : public _Hashtable_iterator< _Val, _Key,_HF, _ExK,_EqK,_All>
{

#line 100
 typedef _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All> _Base;

#line 104
 typedef _Ht_iterator<_Val, _Traits,_Key,_HF,_ExK,_EqK,_All> _Self;

#line 106
 typedef hashtable<_Val,_Key,_HF,_ExK,_EqK,_All> _Hashtable;
 typedef _Hashtable_node<_Val> _Node;

#line 109
 typedef _Val value_type;
 typedef forward_iterator_tag iterator_category;
 typedef ptrdiff_t difference_type;
 typedef size_t size_type;
 typedef typename _Traits::reference reference;
 typedef typename _Traits::pointer pointer;

#line 116
 _Ht_iterator(const _Node* __n, const _Hashtable* __tab) :
 _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>((_Node*)__n, (_Hashtable*)__tab) {}
 _Ht_iterator() {}
 _Ht_iterator(const _Ht_iterator<_Val, _Nonconst_traits<_Val>,_Key,_HF,_ExK,_EqK,_All>& __it) :
 _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>(__it) {}

#line 122
 reference operator*() const {
 return this->_M_cur->_M_val;
 }
 pointer operator->() const { return &(operator*()); }

#line 127
 _Self& operator++() {
 _Node* __n = this->_M_cur->_M_next;
 this->_M_cur = (__n !=0 ? __n : this->_M_skip_to_next());
 return *this;
 }
 inline _Self operator++(int) {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
 }
};

#line 139
template <class _Val, class _Traits, class _Traits1, class _Key, class _HF,
 class _ExK, class _EqK, class _All>
inline bool
operator==(const _Ht_iterator<_Val, _Traits,_Key,_HF,_ExK,_EqK,_All>& __x,
 const _Ht_iterator<_Val, _Traits1,_Key,_HF,_ExK,_EqK,_All>& __y) {
 return __x._M_cur == __y._M_cur;
}

#line 148
template <class _Val, class _Key, class _HF,
 class _ExK, class _EqK, class _All>
inline bool
operator!=(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>& __x,
 const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>& __y) {
 return __x._M_cur != __y._M_cur;
}

#line 186
template <class _Tp>
class _Stl_prime {
public:
 static const size_t _M_list[ 28 ];
};

#line 196
typedef _Stl_prime<bool> _Stl_prime_type;

#line 206
template <class _Val, class _Key, class _HF,
 class _ExK, class _EqK, class _All>
class hashtable {
 typedef hashtable<_Val, _Key, _HF, _ExK, _EqK, _All> _Self;
public:
 typedef _Key key_type;
 typedef _Val value_type;
 typedef _HF hasher;
 typedef _EqK key_equal;

#line 216
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type* pointer;
 typedef const value_type* const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 typedef forward_iterator_tag _Iterator_category;

#line 224
 hasher hash_funct() const { return _M_hash; }
 key_equal key_eq() const { return _M_equals; }

#line 227
private:
 typedef _Hashtable_node<_Val> _Node;

#line 230
private:
 typedef typename _Alloc_traits<_Val,_All>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_Val>::other _STLP_dummy_type2;
 typedef typename _Alloc_traits<_Node, _All>::allocator_type _M_node_allocator_type;
 typedef typename _Alloc_traits<void*, _All>::allocator_type _M_node_ptr_allocator_type;
 typedef vector <void*, _M_node_ptr_allocator_type> _BucketVector;
public:
 typedef typename _Alloc_traits<_Val,_All>::allocator_type allocator_type;
 allocator_type get_allocator() const {
 return (const _M_node_allocator_type&)_M_num_elements ;
 }
private:
 hasher _M_hash;
 key_equal _M_equals;
 _ExK _M_get_key;
 _BucketVector _M_buckets;
 _STLP_alloc_proxy<size_type, _Node, _M_node_allocator_type> _M_num_elements;
 const _Node* _M_get_bucket(size_t __n) const { return (_Node*)_M_buckets[__n]; }

#line 248
public:
 typedef _Const_traits<_Val> __const_val_traits;
 typedef _Nonconst_traits<_Val> __nonconst_val_traits;
 typedef _Ht_iterator<_Val, __const_val_traits,_Key,_HF,_ExK,_EqK, _All> const_iterator;
 typedef _Ht_iterator<_Val, __nonconst_val_traits,_Key,_HF,_ExK,_EqK,_All> iterator;
 friend struct _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>;
 friend struct _Ht_iterator<_Val, _Nonconst_traits<_Val>,_Key,_HF,_ExK,_EqK,_All>;
 friend struct _Ht_iterator<_Val, _Const_traits<_Val>,_Key,_HF,_ExK,_EqK, _All>;

#line 257
public:
 hashtable(size_type __n,
 const _HF& __hf,
 const _EqK& __eql,
 const _ExK& __ext,
 const allocator_type& __a = allocator_type())
 :
 _M_hash(__hf),
 _M_equals(__eql),
 _M_get_key(__ext),
 _M_buckets( __a ),
 _M_num_elements( __a , (size_type)0)
 {
 _M_initialize_buckets(__n);
 }

#line 273
 hashtable(size_type __n,
 const _HF& __hf,
 const _EqK& __eql,
 const allocator_type& __a = allocator_type())
 :
 _M_hash(__hf),
 _M_equals(__eql),
 _M_get_key(_ExK()),
 _M_buckets( __a ),
 _M_num_elements( __a , (size_type)0)
 {
 _M_initialize_buckets(__n);
 }

#line 287
 hashtable(const _Self& __ht)
 :
 _M_hash(__ht._M_hash),
 _M_equals(__ht._M_equals),
 _M_get_key(__ht._M_get_key),
 _M_buckets( __ht.get_allocator() ),
 _M_num_elements((const _M_node_allocator_type&)__ht._M_num_elements, (size_type)0)
 {
 _M_copy_from(__ht);
 }

#line 298
 _Self& operator= (const _Self& __ht)
 {
 if (&__ht != this) {
 clear();
 _M_hash = __ht._M_hash;
 _M_equals = __ht._M_equals;
 _M_get_key = __ht._M_get_key;
 _M_copy_from(__ht);
 }
 return *this;
 }

#line 310
 ~hashtable() { clear(); }

#line 312
 size_type size() const { return _M_num_elements._M_data; }
 size_type max_size() const { return size_type(-1); }
 bool empty() const { return size() == 0; }

#line 316
 void swap(_Self& __ht)
 {
 _STL ::swap(_M_hash, __ht._M_hash);
 _STL ::swap(_M_equals, __ht._M_equals);
 _STL ::swap(_M_get_key, __ht._M_get_key);
 _M_buckets.swap(__ht._M_buckets);
 _STL ::swap(_M_num_elements, __ht._M_num_elements);
 }

#line 325
 iterator begin()
 {
 for (size_type __n = 0; __n < _M_buckets.size(); ++__n)
 if (_M_buckets[__n])
 return iterator((_Node*)_M_buckets[__n], this);
 return end();
 }

#line 333
 iterator end() { return iterator((_Node*)0, this); }

#line 335
 const_iterator begin() const
 {
 for (size_type __n = 0; __n < _M_buckets.size(); ++__n)
 if (_M_buckets[__n])
 return const_iterator((_Node*)_M_buckets[__n], this);
 return end();
 }

#line 343
 const_iterator end() const { return const_iterator((_Node*)0, this); }

#line 345
 static bool _M_equal (const hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>&,
 const hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>&);

#line 348
public:

#line 350
 size_type bucket_count() const { return _M_buckets.size(); }

#line 352
 size_type max_bucket_count() const
 { return _Stl_prime_type::_M_list[(int) 28 - 1]; }

#line 355
 size_type elems_in_bucket(size_type __bucket) const
 {
 size_type __result = 0;
 for (_Node* __cur = (_Node*)_M_buckets[__bucket]; __cur; __cur = __cur->_M_next)
 __result += 1;
 return __result;
 }

#line 363
 pair<iterator, bool> insert_unique(const value_type& __obj)
 {
 resize(_M_num_elements._M_data + 1);
 return insert_unique_noresize(__obj);
 }

#line 369
 iterator insert_equal(const value_type& __obj)
 {
 resize(_M_num_elements._M_data + 1);
 return insert_equal_noresize(__obj);
 }

#line 375
 pair<iterator, bool> insert_unique_noresize(const value_type& __obj);
 iterator insert_equal_noresize(const value_type& __obj);

#line 379
 template <class _InputIterator>
 void insert_unique(_InputIterator __f, _InputIterator __l)
 {
 insert_unique(__f, __l, typename iterator_traits< _InputIterator >::iterator_category() );
 }

#line 385
 template <class _InputIterator>
 void insert_equal(_InputIterator __f, _InputIterator __l)
 {
 insert_equal(__f, __l, typename iterator_traits< _InputIterator >::iterator_category() );
 }

#line 391
 template <class _InputIterator>
 void insert_unique(_InputIterator __f, _InputIterator __l,
 const input_iterator_tag &)
 {
 for ( ; __f != __l; ++__f)
 insert_unique(*__f);
 }

#line 399
 template <class _InputIterator>
 void insert_equal(_InputIterator __f, _InputIterator __l,
 const input_iterator_tag &)
 {
 for ( ; __f != __l; ++__f)
 insert_equal(*__f);
 }

#line 407
 template <class _ForwardIterator>
 void insert_unique(_ForwardIterator __f, _ForwardIterator __l,
 const forward_iterator_tag &)
 {
 size_type __n = distance(__f, __l);
 resize(_M_num_elements._M_data + __n);
 for ( ; __n > 0; --__n, ++__f)
 insert_unique_noresize(*__f);
 }

#line 417
 template <class _ForwardIterator>
 void insert_equal(_ForwardIterator __f, _ForwardIterator __l,
 const forward_iterator_tag &)
 {
 size_type __n = distance(__f, __l);
 resize(_M_num_elements._M_data + __n);
 for ( ; __n > 0; --__n, ++__f)
 insert_equal_noresize(*__f);
 }

#line 461
 reference find_or_insert(const value_type& __obj);

#line 463
private:

#line 465
 template <class _KT>
 _Node* _M_find(const _KT& __key) const

#line 470
 {
 size_type __n = _M_hash(__key)% _M_buckets.size();
 _Node* __first;
 for ( __first = (_Node*)_M_buckets[__n];
 __first && !_M_equals(_M_get_key(__first->_M_val), __key);
 __first = __first->_M_next)
 {}
 return __first;
 }

#line 480
public:

#line 482
 template <class _KT>
 iterator find(const _KT& __key)

#line 487
 {
 return iterator(_M_find(__key), this);
 }

#line 492
 template <class _KT>
 const_iterator find(const _KT& __key) const

#line 497
 {
 return const_iterator(_M_find(__key), this);
 }

#line 501
 size_type count(const key_type& __key) const
 {
 const size_type __n = _M_bkt_num_key(__key);
 size_type __result = 0;

#line 506
 for (const _Node* __cur = (_Node*)_M_buckets[__n]; __cur; __cur = __cur->_M_next)
 if (_M_equals(_M_get_key(__cur->_M_val), __key))
 ++__result;
 return __result;
 }

#line 512
 pair<iterator, iterator>
 equal_range(const key_type& __key);

#line 515
 pair<const_iterator, const_iterator>
 equal_range(const key_type& __key) const;

#line 518
 size_type erase(const key_type& __key);

#line 520
 void erase(const const_iterator& __it) ;

#line 525
 void erase(const_iterator __first, const_iterator __last);
 void resize(size_type __num_elements_hint);
 void clear();

#line 529
public:

#line 531
 reference _M_insert(const value_type& __obj);

#line 533
private:

#line 535
 size_type _M_next_size(size_type __n) const;

#line 537
 void _M_initialize_buckets(size_type __n)
 {
 const size_type __n_buckets = _M_next_size(__n);
 _M_buckets.reserve(__n_buckets);
 _M_buckets.insert(_M_buckets.end(), __n_buckets, (void*) 0);
 _M_num_elements._M_data = 0;
 }

#line 545
 size_type _M_bkt_num_key(const key_type& __key) const
 {
 return _M_bkt_num_key(__key, _M_buckets.size());
 }

#line 550
 size_type _M_bkt_num(const value_type& __obj) const
 {
 return _M_bkt_num_key(_M_get_key(__obj));
 }

#line 555
 size_type _M_bkt_num_key(const key_type& __key, size_t __n) const
 {
 return _M_hash(__key) % __n;
 }

#line 560
 size_type _M_bkt_num(const value_type& __obj, size_t __n) const
 {
 return _M_bkt_num_key(_M_get_key(__obj), __n);
 }

#line 565
 _Node* _M_new_node(const value_type& __obj)
 {
 _Node* __n = _M_num_elements.allocate(1);
 __n->_M_next = 0;
 try {
 _Construct(&__n->_M_val, __obj);

#line 572
 }
 catch(...) { _M_num_elements.deallocate(__n, 1); throw; } ;
 return __n;
 }

#line 577
 void _M_delete_node(_Node* __n)
 {
 _Destroy(&__n->_M_val);
 _M_num_elements.deallocate(__n, 1);
 }

#line 583
 void _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);
 void _M_erase_bucket(const size_type __n, _Node* __last);

#line 586
 void _M_copy_from(const _Self& __ht);
};

#line 589
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
inline bool operator==(const hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>& __ht1,
 const hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>& __ht2)
{
 return hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::_M_equal( __ht1, __ht2 );
}

#line 598
template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
 const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {
 return !(__ht1 == __ht2);
}

#line 604
template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
 class _All>
inline void swap(hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>& __ht1,
 hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>& __ht2) {
 __ht1.swap(__ht2);
}

#line 613
 }
#line 1 "../../stlport/stl/_hashtable.c"


#line 37
 namespace _STL {

#line 49
 template <class _Tp>
const size_t _Stl_prime<_Tp>::_M_list[ 28 ] = { 53ul, 97ul, 193ul, 389ul, 769ul, 1543ul, 3079ul, 6151ul, 12289ul, 24593ul, 49157ul, 98317ul, 196613ul, 393241ul, 786433ul, 1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul, 50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul, 1610612741ul, 3221225473ul, 4294967291ul } ;

#line 77
template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
 class _All>
_Hashtable_node<_Val>*
_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::_M_skip_to_next() {
 size_t __bucket = _M_ht->_M_bkt_num(_M_cur->_M_val);
 size_t __h_sz;
 __h_sz = this->_M_ht->bucket_count();

#line 85
 _Node* __i=0;
 while (__i==0 && ++__bucket < __h_sz)
 __i = (_Node*)_M_ht->_M_buckets[__bucket];
 return __i;
}

#line 91
template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
 class _All>
 typename hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>::size_type
 hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::_M_next_size(size_type __n) const {
 const size_type* __first = (const size_type*)_Stl_prime_type::_M_list;
 const size_type* __last = (const size_type*)_Stl_prime_type::_M_list + (int) 28 ;
 const size_type* pos = __lower_bound(__first, __last, __n, __less((size_type*)0), (ptrdiff_t*)0);
 return (pos == __last ? *(__last - 1) : *pos);
}

#line 101
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
bool
hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::_M_equal(
 const hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>& __ht1,
 const hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>& __ht2)
{

#line 108
 if (__ht1.bucket_count() != __ht2.bucket_count())
 return false;
 for (size_t __n = 0; __n < __ht1.bucket_count(); ++__n) {
 const _Node* __cur1 = __ht1._M_get_bucket(__n);
 const _Node* __cur2 = __ht2._M_get_bucket(__n);
 for ( ; __cur1 && __cur2 && __cur1->_M_val == __cur2->_M_val;
 __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)
 {}
 if (__cur1 || __cur2)
 return false;
 }
 return true;
}

#line 122
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
pair< _Ht_iterator<_Val, _Nonconst_traits<_Val>, _Key, _HF, _ExK, _EqK, _All> , bool>
hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::insert_unique_noresize(const value_type& __obj)
{
 const size_type __n = _M_bkt_num(__obj);
 _Node* __first = (_Node*)_M_buckets[__n];

#line 130
 for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)
 if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))
 return pair<iterator, bool>(iterator(__cur, this), false);

#line 134
 _Node* __tmp = _M_new_node(__obj);
 __tmp->_M_next = __first;
 _M_buckets[__n] = __tmp;
 ++_M_num_elements._M_data;
 return pair<iterator, bool>(iterator(__tmp, this), true);
}

#line 141
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
 typename hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>::iterator
 hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::insert_equal_noresize(const value_type& __obj)
{
 const size_type __n = _M_bkt_num(__obj);
 _Node* __first = (_Node*)_M_buckets[__n];

#line 149
 for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)
 if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {
 _Node* __tmp = _M_new_node(__obj);
 __tmp->_M_next = __cur->_M_next;
 __cur->_M_next = __tmp;
 ++_M_num_elements._M_data;
 return iterator(__tmp, this);
 }

#line 158
 _Node* __tmp = _M_new_node(__obj);
 __tmp->_M_next = __first;
 _M_buckets[__n] = __tmp;
 ++_M_num_elements._M_data;
 return iterator(__tmp, this);
}

#line 165
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
 typename hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>::reference
 hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::_M_insert(const value_type& __obj)
{
 resize(_M_num_elements._M_data + 1);

#line 171
 size_type __n = _M_bkt_num(__obj);
 _Node* __first = (_Node*)_M_buckets[__n];

#line 174
 _Node* __tmp = _M_new_node(__obj);
 __tmp->_M_next = __first;
 _M_buckets[__n] = __tmp;
 ++_M_num_elements._M_data;
 return __tmp->_M_val;
}

#line 181
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
 typename hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>::reference
 hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::find_or_insert(const value_type& __obj)
{

#line 186
 _Node* __first = _M_find(_M_get_key(__obj));
 if (__first)
 return __first->_M_val;
 else
 return _M_insert(__obj);
}

#line 193
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
pair< _Ht_iterator<_Val, _Nonconst_traits<_Val>, _Key, _HF, _ExK, _EqK, _All>,
 _Ht_iterator<_Val, _Nonconst_traits<_Val>, _Key, _HF, _ExK, _EqK, _All> >
hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::equal_range(const key_type& __key)
{
 typedef pair<iterator, iterator> _Pii;
 const size_type __n = _M_bkt_num_key(__key);

#line 201
 for (_Node* __first = (_Node*)_M_buckets[__n]; __first; __first = __first->_M_next)
 if (_M_equals(_M_get_key(__first->_M_val), __key)) {
 for (_Node* __cur = __first->_M_next; __cur; __cur = __cur->_M_next)
 if (!_M_equals(_M_get_key(__cur->_M_val), __key))
 return _Pii(iterator(__first, this), iterator(__cur, this));
 for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)
 if (_M_buckets[__m])
 return _Pii(iterator(__first, this),
 iterator((_Node*)_M_buckets[__m], this));
 return _Pii(iterator(__first, this), end());
 }
 return _Pii(end(), end());
}

#line 215
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
pair< _Ht_iterator<_Val, _Const_traits<_Val>, _Key, _HF, _ExK, _EqK, _All>,
 _Ht_iterator<_Val, _Const_traits<_Val>, _Key, _HF, _ExK, _EqK, _All> >
hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::equal_range(const key_type& __key) const
{
 typedef pair<const_iterator, const_iterator> _Pii;
 const size_type __n = _M_bkt_num_key(__key);

#line 224
 for (const _Node* __first = (_Node*)_M_buckets[__n] ;
 __first;
 __first = __first->_M_next) {
 if (_M_equals(_M_get_key(__first->_M_val), __key)) {
 for (const _Node* __cur = __first->_M_next;
 __cur;
 __cur = __cur->_M_next)
 if (!_M_equals(_M_get_key(__cur->_M_val), __key))
 return _Pii(const_iterator(__first, this),
 const_iterator(__cur, this));
 for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)
 if (_M_buckets[__m])
 return _Pii(const_iterator(__first, this),
 const_iterator((_Node*)_M_buckets[__m], this));
 return _Pii(const_iterator(__first, this), end());
 }
 }
 return _Pii(end(), end());
}

#line 244
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
 typename hashtable<_Val, _Key, _HF, _ExK, _EqK, _All>::size_type
 hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::erase(const key_type& __key)
{
 const size_type __n = _M_bkt_num_key(__key);
 _Node* __first = (_Node*)_M_buckets[__n];
 size_type __erased = 0;

#line 252
 if (__first) {
 _Node* __cur = __first;
 _Node* __next = __cur->_M_next;
 while (__next) {
 if (_M_equals(_M_get_key(__next->_M_val), __key)) {
 __cur->_M_next = __next->_M_next;
 _M_delete_node(__next);
 __next = __cur->_M_next;
 ++__erased;
 --_M_num_elements._M_data;
 }
 else {
 __cur = __next;
 __next = __cur->_M_next;
 }
 }
 if (_M_equals(_M_get_key(__first->_M_val), __key)) {
 _M_buckets[__n] = __first->_M_next;
 _M_delete_node(__first);
 ++__erased;
 --_M_num_elements._M_data;
 }
 }
 return __erased;
}

#line 278
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::erase(const const_iterator& __it)
{

#line 282
 const _Node* __p = __it._M_cur;
 if (__p) {
 const size_type __n = _M_bkt_num(__p->_M_val);
 _Node* __cur = (_Node*)_M_buckets[__n];

#line 287
 if (__cur == __p) {
 _M_buckets[__n] = __cur->_M_next;
 _M_delete_node(__cur);
 --_M_num_elements._M_data;
 }
 else {
 _Node* __next = __cur->_M_next;
 while (__next) {
 if (__next == __p) {
 __cur->_M_next = __next->_M_next;
 _M_delete_node(__next);
 --_M_num_elements._M_data;
 break;
 }
 else {
 __cur = __next;
 __next = __cur->_M_next;
 }
 }
 }
 }
}

#line 310
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::erase(const_iterator _c_first, const_iterator _c_last)
{
 iterator& __first = (iterator&)_c_first;
 iterator& __last = (iterator&)_c_last;
 size_type __f_bucket = __first._M_cur ?
 _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();
 size_type __l_bucket = __last._M_cur ?
 _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();
 if (__first._M_cur == __last._M_cur)
 return;
 else if (__f_bucket == __l_bucket)
 _M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);
 else {
 _M_erase_bucket(__f_bucket, __first._M_cur, 0);
 for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)
 _M_erase_bucket(__n, 0);
 if (__l_bucket != _M_buckets.size())
 _M_erase_bucket(__l_bucket, __last._M_cur);
 }
}

#line 333
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::resize(size_type __num_elements_hint)
{
 const size_type __old_n = _M_buckets.size();
 if (__num_elements_hint > __old_n) {
 const size_type __n = _M_next_size(__num_elements_hint);
 if (__n > __old_n) {
 _BucketVector __tmp(__n, (void*)(0),
 _M_buckets.get_allocator());
 try {
 for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {
 _Node* __first = (_Node*)_M_buckets[__bucket];
 while (__first) {
 size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);
 _M_buckets[__bucket] = __first->_M_next;
 __first->_M_next = (_Node*)__tmp[__new_bucket];
 __tmp[__new_bucket] = __first;
 __first = (_Node*)_M_buckets[__bucket];
 }
 }
 _M_buckets.swap(__tmp);
 }

#line 357
 catch(...) {
 for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {
 while (__tmp[__bucket]) {
 _Node* __next = ((_Node*)__tmp[__bucket])->_M_next;
 _M_delete_node((_Node*)__tmp[__bucket]);
 __tmp[__bucket] = __next;
 }
 }
 throw;
 }

#line 368
 }
 }
}

#line 372
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::_M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)
{
 _Node* __cur = (_Node*)_M_buckets[__n];
 if (__cur == __first)
 _M_erase_bucket(__n, __last);
 else {
 _Node* __next;
 for (__next = __cur->_M_next;
 __next != __first;
 __cur = __next, __next = __cur->_M_next)
 ;
 while (__next != __last) {
 __cur->_M_next = __next->_M_next;
 _M_delete_node(__next);
 __next = __cur->_M_next;
 --_M_num_elements._M_data;
 }
 }
}

#line 394
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::_M_erase_bucket(const size_type __n, _Node* __last)
{
 _Node* __cur = (_Node*)_M_buckets[__n];
 while (__cur && __cur != __last) {
 _Node* __next = __cur->_M_next;
 _M_delete_node(__cur);
 __cur = __next;
 _M_buckets[__n] = __cur;
 --_M_num_elements._M_data;
 }
}

#line 408
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::clear()
{
 for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {
 _Node* __cur = (_Node*)_M_buckets[__i];
 while (__cur != 0) {
 _Node* __next = __cur->_M_next;
 _M_delete_node(__cur);
 __cur = __next;
 }
 _M_buckets[__i] = 0;
 }
 _M_num_elements._M_data = 0;
}

#line 424
template <class _Val, class _Key, class _HF, class _ExK, class _EqK, class _All>
void hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>
 ::_M_copy_from(const hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>& __ht)
{
 _M_buckets.clear();
 _M_buckets.reserve(__ht._M_buckets.size());
 _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (void*) 0);
 try {
 for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
 const _Node* __cur = (_Node*)__ht._M_buckets[__i];
 if (__cur) {
 _Node* __xcopy = _M_new_node(__cur->_M_val);
 _M_buckets[__i] = __xcopy;

#line 438
 for (_Node* __next = __cur->_M_next;
 __next;
 __cur = __next, __next = __cur->_M_next) {
 __xcopy->_M_next = _M_new_node(__next->_M_val);
 __xcopy = __xcopy->_M_next;
 }
 }
 }
 _M_num_elements._M_data = __ht._M_num_elements._M_data;
 }
 catch(...) { clear(); throw; } ;
}

#line 462
 }
#line 619 "../../stlport/stl/_hashtable.h"

#line 35 "../../stlport/stl/_hash_map.h"


#line 37
 namespace _STL {

#line 47
 template <class _Key, class _Tp, class _HashFcn = hash<_Key> ,
 class _EqualKey = equal_to<_Key> ,
 class _Alloc = allocator< pair < const _Key, _Tp > > >
class hash_map
 {
private:
 typedef hashtable < pair < const _Key, _Tp >, _Key, _HashFcn, _Select1st< pair< const _Key, _Tp > >, _EqualKey, _Alloc > _Ht;
 typedef hash_map <_Key, _Tp, _HashFcn, _EqualKey, _Alloc> _Self;
public:
 typedef typename _Ht::key_type key_type;
 typedef _Tp data_type;
 typedef _Tp mapped_type;
 typedef typename _Ht::value_type _value_type;
 typedef typename _Ht::value_type value_type;
 typedef typename _Ht::hasher hasher;
 typedef typename _Ht::key_equal key_equal;

#line 64
 typedef typename _Ht::size_type size_type;
 typedef typename _Ht::difference_type difference_type;
 typedef typename _Ht::pointer pointer;
 typedef typename _Ht::const_pointer const_pointer;
 typedef typename _Ht::reference reference;
 typedef typename _Ht::const_reference const_reference;

#line 71
 typedef typename _Ht::iterator iterator;
 typedef typename _Ht::const_iterator const_iterator;

#line 74
 typedef typename _Ht::allocator_type allocator_type;

#line 76
 hasher hash_funct() const { return _M_ht.hash_funct(); }
 key_equal key_eq() const { return _M_ht.key_eq(); }
 allocator_type get_allocator() const { return _M_ht.get_allocator(); }

#line 80
private:
 _Ht _M_ht;
public:
 hash_map () : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
 explicit hash_map (size_type __n)
 : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
 hash_map (size_type __n, const hasher& __hf)
 : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
 hash_map (size_type __n, const hasher& __hf, const key_equal& __eql,
 const allocator_type& __a = allocator_type())
 : _M_ht(__n, __hf, __eql, __a) {}

#line 93
 template <class _InputIterator>
 hash_map (_InputIterator __f, _InputIterator __l)
 : _M_ht(100, hasher(), key_equal(), allocator_type())
 { _M_ht.insert_unique(__f, __l); }
 template <class _InputIterator>
 hash_map (_InputIterator __f, _InputIterator __l, size_type __n)
 : _M_ht(__n, hasher(), key_equal(), allocator_type())
 { _M_ht.insert_unique(__f, __l); }
 template <class _InputIterator>
 hash_map (_InputIterator __f, _InputIterator __l, size_type __n,
 const hasher& __hf)
 : _M_ht(__n, __hf, key_equal(), allocator_type())
 { _M_ht.insert_unique(__f, __l); }

#line 113
 template <class _InputIterator>
 hash_map (_InputIterator __f, _InputIterator __l, size_type __n,
 const hasher& __hf, const key_equal& __eql,
 const allocator_type& __a = allocator_type() )
 : _M_ht(__n, __hf, __eql, __a)
 { _M_ht.insert_unique(__f, __l); }

#line 154
public:
 size_type size() const { return _M_ht.size(); }
 size_type max_size() const { return _M_ht.max_size(); }
 bool empty() const { return _M_ht.empty(); }
 void swap(_Self& __hs) { _M_ht.swap(__hs._M_ht); }
 iterator begin() { return _M_ht.begin(); }
 iterator end() { return _M_ht.end(); }
 const_iterator begin() const { return _M_ht.begin(); }
 const_iterator end() const { return _M_ht.end(); }

#line 164
public:
 pair<iterator,bool> insert(const value_type& __obj)
 { return _M_ht.insert_unique(__obj); }

#line 168
 template <class _InputIterator>
 void insert(_InputIterator __f, _InputIterator __l)
 { _M_ht.insert_unique(__f,__l); }

#line 178
 pair<iterator,bool> insert_noresize(const value_type& __obj)
 { return _M_ht.insert_unique_noresize(__obj); }

#line 181
 iterator find(const key_type& __key) { return _M_ht.find(__key); }
 const_iterator find(const key_type& __key) const { return _M_ht.find(__key); }

#line 184
 _Tp& operator[](const key_type& __key) {
 iterator __it = _M_ht.find(__key);
 return (__it == _M_ht.end() ?
 _M_ht._M_insert(_value_type(__key, _Tp())).second :
 (*__it).second );
 }

#line 191
 size_type count(const key_type& __key) const { return _M_ht.count(__key); }

#line 193
 pair<iterator, iterator> equal_range(const key_type& __key)
 { return _M_ht.equal_range(__key); }
 pair<const_iterator, const_iterator>
 equal_range(const key_type& __key) const
 { return _M_ht.equal_range(__key); }

#line 199
 size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
 void erase(iterator __it) { _M_ht.erase(__it); }
 void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
 void clear() { _M_ht.clear(); }

#line 204
 void resize(size_type __hint) { _M_ht.resize(__hint); }
 size_type bucket_count() const { return _M_ht.bucket_count(); }
 size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
 size_type elems_in_bucket(size_type __n) const
 { return _M_ht.elems_in_bucket(__n); }
 static bool _M_equal (const _Self& __x, const _Self& __y) {
 return _Ht::_M_equal(__x._M_ht,__y._M_ht);
 }
};

#line 215
template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline bool
operator==(const hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
 const hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
 return hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>::_M_equal(__hm1, __hm2);
}

#line 224
template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline bool
operator!=(const hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
 const hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {
 return !(__hm1 == __hm2);
}

#line 231
template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline void
swap( hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
 hash_map <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
 __hm1.swap(__hm2);
}

#line 241
template <class _Key, class _Tp, class _HashFcn = hash<_Key> ,
 class _EqualKey = equal_to<_Key> ,
 class _Alloc = allocator< pair < const _Key, _Tp > > >
class hash_multimap
 {
private:
 typedef hashtable < pair < const _Key, _Tp >, _Key, _HashFcn, _Select1st< pair< const _Key, _Tp > >, _EqualKey, _Alloc > _Ht;
 typedef hash_multimap <_Key, _Tp, _HashFcn, _EqualKey, _Alloc> _Self;
public:
 typedef typename _Ht::key_type key_type;
 typedef _Tp data_type;
 typedef _Tp mapped_type;
 typedef typename _Ht::value_type _value_type;
 typedef _value_type value_type;
 typedef typename _Ht::hasher hasher;
 typedef typename _Ht::key_equal key_equal;

#line 258
 typedef typename _Ht::size_type size_type;
 typedef typename _Ht::difference_type difference_type;
 typedef typename _Ht::pointer pointer;
 typedef typename _Ht::const_pointer const_pointer;
 typedef typename _Ht::reference reference;
 typedef typename _Ht::const_reference const_reference;

#line 265
 typedef typename _Ht::iterator iterator;
 typedef typename _Ht::const_iterator const_iterator;

#line 268
 typedef typename _Ht::allocator_type allocator_type;

#line 270
 hasher hash_funct() const { return _M_ht.hash_funct(); }
 key_equal key_eq() const { return _M_ht.key_eq(); }
 allocator_type get_allocator() const { return _M_ht.get_allocator(); }

#line 274
private:
 _Ht _M_ht;
public:
 hash_multimap () : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
 explicit hash_multimap (size_type __n)
 : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
 hash_multimap (size_type __n, const hasher& __hf)
 : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
 hash_multimap (size_type __n, const hasher& __hf, const key_equal& __eql,
 const allocator_type& __a = allocator_type())
 : _M_ht(__n, __hf, __eql, __a) {}

#line 287
 template <class _InputIterator>
 hash_multimap (_InputIterator __f, _InputIterator __l)
 : _M_ht(100, hasher(), key_equal(), allocator_type())
 { _M_ht.insert_equal(__f, __l); }
 template <class _InputIterator>
 hash_multimap (_InputIterator __f, _InputIterator __l, size_type __n)
 : _M_ht(__n, hasher(), key_equal(), allocator_type())
 { _M_ht.insert_equal(__f, __l); }
 template <class _InputIterator>
 hash_multimap (_InputIterator __f, _InputIterator __l, size_type __n,
 const hasher& __hf)
 : _M_ht(__n, __hf, key_equal(), allocator_type())
 { _M_ht.insert_equal(__f, __l); }

#line 307
 template <class _InputIterator>
 hash_multimap (_InputIterator __f, _InputIterator __l, size_type __n,
 const hasher& __hf, const key_equal& __eql,
 const allocator_type& __a = allocator_type() )
 : _M_ht(__n, __hf, __eql, __a)
 { _M_ht.insert_equal(__f, __l); }

#line 348
public:
 size_type size() const { return _M_ht.size(); }
 size_type max_size() const { return _M_ht.max_size(); }
 bool empty() const { return _M_ht.empty(); }
 void swap(_Self& __hs) { _M_ht.swap(__hs._M_ht); }

#line 354
 iterator begin() { return _M_ht.begin(); }
 iterator end() { return _M_ht.end(); }
 const_iterator begin() const { return _M_ht.begin(); }
 const_iterator end() const { return _M_ht.end(); }

#line 359
public:
 iterator insert(const value_type& __obj)
 { return _M_ht.insert_equal(__obj); }

#line 363
 template <class _InputIterator>
 void insert(_InputIterator __f, _InputIterator __l)
 { _M_ht.insert_equal(__f,__l); }

#line 373
 iterator insert_noresize(const value_type& __obj)
 { return _M_ht.insert_equal_noresize(__obj); }

#line 376
 iterator find(const key_type& __key) { return _M_ht.find(__key); }
 const_iterator find(const key_type& __key) const
 { return _M_ht.find(__key); }

#line 380
 size_type count(const key_type& __key) const { return _M_ht.count(__key); }

#line 382
 pair<iterator, iterator> equal_range(const key_type& __key)
 { return _M_ht.equal_range(__key); }
 pair<const_iterator, const_iterator>
 equal_range(const key_type& __key) const
 { return _M_ht.equal_range(__key); }

#line 388
 size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
 void erase(iterator __it) { _M_ht.erase(__it); }
 void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
 void clear() { _M_ht.clear(); }

#line 393
public:
 void resize(size_type __hint) { _M_ht.resize(__hint); }
 size_type bucket_count() const { return _M_ht.bucket_count(); }
 size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
 size_type elems_in_bucket(size_type __n) const
 { return _M_ht.elems_in_bucket(__n); }
 static bool _M_equal (const _Self& __x, const _Self& __y) {
 return _Ht::_M_equal(__x._M_ht,__y._M_ht);
 }
};

#line 405
template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline bool
operator==(const hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
 const hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
 return hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>::_M_equal(__hm1, __hm2);
}

#line 415
template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline bool
operator!=(const hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
 const hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {
 return !(__hm1 == __hm2);
}

#line 422
template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline void
swap( hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
 hash_multimap <_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
 __hm1.swap(__hm2);
}

#line 438
template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>
class insert_iterator< hash_map <_Key, _Tp, _HashFn, _EqKey, _Alloc> > {
protected:
 typedef hash_map <_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;
 _Container* container;
public:
 typedef _Container container_type;
 typedef output_iterator_tag iterator_category;
 typedef void value_type;
 typedef void difference_type;
 typedef void pointer;
 typedef void reference;

#line 451
 insert_iterator(_Container& __x) : container(&__x) {}
 insert_iterator(_Container& __x, typename _Container::iterator)
 : container(&__x) {}
 insert_iterator<_Container>&
 operator=(const typename _Container::value_type& __val) {
 container->insert(__val);
 return *this;
 }
 insert_iterator<_Container>& operator*() { return *this; }
 insert_iterator<_Container>& operator++() { return *this; }
 insert_iterator<_Container>& operator++(int) { return *this; }
};

#line 464
template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>
class insert_iterator< hash_multimap <_Key, _Tp, _HashFn, _EqKey, _Alloc> > {
protected:
 typedef hash_multimap <_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;
 _Container* container;
 typename _Container::iterator iter;
public:
 typedef _Container container_type;
 typedef output_iterator_tag iterator_category;
 typedef void value_type;
 typedef void difference_type;
 typedef void pointer;
 typedef void reference;

#line 478
 insert_iterator(_Container& __x) : container(&__x) {}
 insert_iterator(_Container& __x, typename _Container::iterator)
 : container(&__x) {}
 insert_iterator<_Container>&
 operator=(const typename _Container::value_type& __val) {
 container->insert(__val);
 return *this;
 }
 insert_iterator<_Container>& operator*() { return *this; }
 insert_iterator<_Container>& operator++() { return *this; }
 insert_iterator<_Container>& operator++(int) { return *this; }
};

#line 501
 }
#line 32 "../../stlport/hash_map"

#line 1 "../../stlport/stl/_epilog.h"

#line 1 "../../stlport/config/_epilog.h"

#line 11 "../../stlport/stl/_epilog.h"

#line 1 "../../stlport/stl/_config_compat_post.h"

#line 15 "../../stlport/stl/_epilog.h"


#line 34
 namespace _STL {}

#line 35
namespace std {
 using namespace _STL ;
}
#line 35 "../../stlport/hash_map"

#line 10 "hmap1.cpp"

#line 1 "../../stlport/rope"

#line 1 "../../stlport/stl/_prolog.h"

#line 1 "../../stlport/config/_prolog.h"

#line 17 "../../stlport/stl/_prolog.h"

#line 20 "../../stlport/rope"

#line 1 "../../stlport/stl/_rope.h"

#line 1 "../../stlport/stl/_algo.h"

#line 1 "../../stlport/stl/_heap.h"


#line 37
 namespace _STL {

#line 41
 template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);

#line 46
template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
 _Compare __comp);

#line 51
template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
 _Distance __len, _Tp __val);

#line 56
template <class _RandomAccessIterator, class _Tp, class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
 _RandomAccessIterator __result, _Tp __val, _Distance*)
{
 *__result = *__first;
 __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __val);
}

#line 65
template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last);

#line 69
template <class _RandomAccessIterator, class _Distance,
 class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
 _Distance __len, _Tp __val, _Compare __comp);

#line 75
template <class _RandomAccessIterator, class _Tp, class _Compare,
 class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
 _RandomAccessIterator __result, _Tp __val, _Compare __comp,
 _Distance*)
{
 *__result = *__first;
 __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
 __val, __comp);
}

#line 87
template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Compare __comp);

#line 92
template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);

#line 96
template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Compare __comp);

#line 101
template <class _RandomAccessIterator>
 inline
 void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
 while (__last - __first > 1)
 pop_heap(__first, __last--);
}

#line 109
template <class _RandomAccessIterator, class _Compare>
 inline
 void
sort_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Compare __comp)
{
 while (__last - __first > 1)
 pop_heap(__first, __last--, __comp);
}

#line 119
 }
#line 1 "../../stlport/stl/_heap.c"


#line 37
 namespace _STL {

#line 39
 template <class _RandomAccessIterator, class _Distance, class _Tp>
 inline
 void
__push_heap(_RandomAccessIterator __first,
 _Distance __holeIndex, _Distance __topIndex, _Tp __val)
{
 _Distance __parent = (__holeIndex - 1) / 2;
 while (__holeIndex > __topIndex && *(__first + __parent) < __val) {
 *(__first + __holeIndex) = *(__first + __parent);
 __holeIndex = __parent;
 __parent = (__holeIndex - 1) / 2;
 }
 *(__first + __holeIndex) = __val;
}

#line 54
template <class _RandomAccessIterator, class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Distance*, _Tp*)
{
 __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
 _Tp(*(__last - 1)));
}

#line 63
template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
 __push_heap_aux(__first, __last,
 (typename iterator_traits< _RandomAccessIterator >::difference_type*)0 , (typename iterator_traits< _RandomAccessIterator >::value_type*)0 );
}

#line 72
template <class _RandomAccessIterator, class _Distance, class _Tp,
 class _Compare>
 inline
 void
__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
 _Distance __topIndex, _Tp __val, _Compare __comp)
{
 _Distance __parent = (__holeIndex - 1) / 2;
 while (__holeIndex > __topIndex && __comp(*(__first + __parent), __val)) {
 *(__first + __holeIndex) = *(__first + __parent);
 __holeIndex = __parent;
 __parent = (__holeIndex - 1) / 2;
 }
 *(__first + __holeIndex) = __val;
}

#line 88
template <class _RandomAccessIterator, class _Compare,
 class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Compare __comp,
 _Distance*, _Tp*)
{
 __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
 _Tp(*(__last - 1)), __comp);
}

#line 99
template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
 _Compare __comp)
{
 __push_heap_aux(__first, __last, __comp,
 (typename iterator_traits< _RandomAccessIterator >::difference_type*)0 , (typename iterator_traits< _RandomAccessIterator >::value_type*)0 );
}

#line 108
template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
 _Distance __len, _Tp __val) {
 _Distance __topIndex = __holeIndex;
 _Distance __secondChild = 2 * __holeIndex + 2;
 while (__secondChild < __len) {
 if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
 __secondChild--;
 *(__first + __holeIndex) = *(__first + __secondChild);
 __holeIndex = __secondChild;
 __secondChild = 2 * (__secondChild + 1);
 }
 if (__secondChild == __len) {
 *(__first + __holeIndex) = *(__first + (__secondChild - 1));
 __holeIndex = __secondChild - 1;
 }
 __push_heap(__first, __holeIndex, __topIndex, __val);
}

#line 129
template <class _RandomAccessIterator, class _Tp>
inline void
__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) {
 __pop_heap(__first, __last - 1, __last - 1,
 _Tp(*(__last - 1)), (typename iterator_traits< _RandomAccessIterator >::difference_type*)0 );
}

#line 136
template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last) {
 __pop_heap_aux(__first, __last, (typename iterator_traits< _RandomAccessIterator >::value_type*)0 );
}

#line 142
template <class _RandomAccessIterator, class _Distance,
 class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
 _Distance __len, _Tp __val, _Compare __comp)
{
 _Distance __topIndex = __holeIndex;
 _Distance __secondChild = 2 * __holeIndex + 2;
 while (__secondChild < __len) {
 if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
 __secondChild--;
 *(__first + __holeIndex) = *(__first + __secondChild);
 __holeIndex = __secondChild;
 __secondChild = 2 * (__secondChild + 1);
 }
 if (__secondChild == __len) {
 *(__first + __holeIndex) = *(__first + (__secondChild - 1));
 __holeIndex = __secondChild - 1;
 }
 __push_heap(__first, __holeIndex, __topIndex, __val, __comp);
}

#line 165
template <class _RandomAccessIterator, class _Tp, class _Compare>
inline void
__pop_heap_aux(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Tp*, _Compare __comp)
{
 __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,
 (typename iterator_traits< _RandomAccessIterator >::difference_type*)0 );
}

#line 175
template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Compare __comp)
{
 __pop_heap_aux(__first, __last, (typename iterator_traits< _RandomAccessIterator >::value_type*)0 , __comp);
}

#line 183
template <class _RandomAccessIterator, class _Tp, class _Distance>
 inline
 void
__make_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Tp*, _Distance*)
{
 if (__last - __first < 2) return;
 _Distance __len = __last - __first;
 _Distance __parent = (__len - 2)/2;

#line 193
 while (true) {
 __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));
 if (__parent == 0) return;
 __parent--;
 }
}

#line 200
template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
 __make_heap(__first, __last,
 (typename iterator_traits< _RandomAccessIterator >::value_type*)0 , (typename iterator_traits< _RandomAccessIterator >::difference_type*)0 );
}

#line 208
template <class _RandomAccessIterator, class _Compare,
 class _Tp, class _Distance>
 inline
 void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
 _Compare __comp, _Tp*, _Distance*)
{
 if (__last - __first < 2) return;
 _Distance __len = __last - __first;
 _Distance __parent = (__len - 2)/2;

#line 219
 while (true) {
 __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),
 __comp);
 if (__parent == 0) return;
 __parent--;
 }
}

#line 227
template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
 _RandomAccessIterator __last, _Compare __comp)
{
 __make_heap(__first, __last, __comp,
 (typename iterator_traits< _RandomAccessIterator >::value_type*)0 , (typename iterator_traits< _RandomAccessIterator >::difference_type*)0 );
}

#line 236
 }
#line 123 "../../stlport/stl/_heap.h"

#line 43 "../../stlport/stl/_algo.h"


#line 58
 namespace _STL {

#line 61
 template <class _InputIter, class _Function>
 inline _Function
for_each(_InputIter __first, _InputIter __last, _Function __f) {
 for ( ; __first != __last; ++__first)
 __f(*__first);
 return __f;
}

#line 70
template <class _InputIter, class _Predicate>
 inline typename iterator_traits<_InputIter>::difference_type
 count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {

#line 74
 typename iterator_traits<_InputIter>::difference_type __n = 0;
 for ( ; __first != __last; ++__first)
 if (__pred(*__first))
 ++__n;
 return __n;
}

#line 83
template <class _ForwardIter, class _BinaryPredicate>
 inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last,
 _BinaryPredicate __binary_pred) {

#line 88
 if (__first == __last)
 return __last;
 _ForwardIter __next = __first;
 while(++__next != __last) {
 if (__binary_pred(*__first, *__next))
 return __first;
 __first = __next;
 }
 return __last;
}

#line 99
template <class _ForwardIter>
 inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last) {
 return adjacent_find(__first, __last,
 __equal_to( (typename iterator_traits< _ForwardIter >::value_type*)0 ));
}

#line 107
template <class _InputIter, class _Tp, class _Size>
 inline void
count(_InputIter __first, _InputIter __last, const _Tp& __val, _Size& __n) {

#line 111
 for ( ; __first != __last; ++__first)
 if (*__first == __val)
 ++__n;
}

#line 116
template <class _InputIter, class _Predicate, class _Size>
 inline void
count_if(_InputIter __first, _InputIter __last, _Predicate __pred, _Size& __n) {

#line 120
 for ( ; __first != __last; ++__first)
 if (__pred(*__first))
 ++__n;
}

#line 126
template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2);

#line 131
template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
 _Integer __count, const _Tp& __val);
template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
 _Integer __count, const _Tp& __val, _BinaryPred __binary_pred);

#line 138
template <class _InputIter, class _ForwardIter>
inline _InputIter find_first_of(_InputIter __first1, _InputIter __last1,
 _ForwardIter __first2, _ForwardIter __last2) {

#line 143
 return __find_first_of(__first1, __last1, __first2, __last2,__equal_to( (typename iterator_traits< _InputIter >::value_type*)0 ));
}

#line 146
template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _InputIter
find_first_of(_InputIter __first1, _InputIter __last1,
 _ForwardIter __first2, _ForwardIter __last2,_BinaryPredicate __comp) {

#line 152
 return __find_first_of(__first1, __last1, __first2, __last2,__comp);
}

#line 155
template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2);

#line 161
template <class _ForwardIter1, class _ForwardIter2>
 inline _ForwardIter2
swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2) {

#line 165
 for ( ; __first1 != __last1; ++__first1, ++__first2)
 iter_swap(__first1, __first2);
 return __first2;
}

#line 171
template <class _InputIter, class _OutputIter, class _UnaryOperation>
 inline _OutputIter
transform(_InputIter __first, _InputIter __last, _OutputIter __result, _UnaryOperation __opr) {

#line 175
 for ( ; __first != __last; ++__first, ++__result)
 *__result = __opr(*__first);
 return __result;
}
template <class _InputIter1, class _InputIter2, class _OutputIter, class _BinaryOperation>
 inline _OutputIter
transform(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _OutputIter __result,_BinaryOperation __binary_op) {

#line 184
 for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
 return __result;
}

#line 191
template <class _ForwardIter, class _Predicate, class _Tp>
 inline void
replace_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred, const _Tp& __new_value) {

#line 195
 for ( ; __first != __last; ++__first)
 if (__pred(*__first))
 *__first = __new_value;
}

#line 200
template <class _InputIter, class _OutputIter, class _Tp>
 inline _OutputIter
replace_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
 const _Tp& __old_value, const _Tp& __new_value) {

#line 205
 for ( ; __first != __last; ++__first, ++__result)
 *__result = *__first == __old_value ? __new_value : *__first;
 return __result;
}

#line 210
template <class _Iterator, class _OutputIter, class _Predicate, class _Tp>
 inline _OutputIter
replace_copy_if(_Iterator __first, _Iterator __last,
 _OutputIter __result,
 _Predicate __pred, const _Tp& __new_value) {

#line 216
 for ( ; __first != __last; ++__first, ++__result)
 *__result = __pred(*__first) ? __new_value : *__first;
 return __result;
}

#line 223
template <class _ForwardIter, class _Generator>
 inline void
generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen) {

#line 227
 for ( ; __first != __last; ++__first)
 *__first = __gen();
}

#line 231
template <class _OutputIter, class _Size, class _Generator>
 inline _OutputIter
generate_n(_OutputIter __first, _Size __n, _Generator __gen) {
 for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
 return __first;
}

#line 241
template <class _InputIter, class _OutputIter, class _Tp>
 inline _OutputIter
remove_copy(_InputIter __first, _InputIter __last,_OutputIter __result, const _Tp& __val) {

#line 245
 for ( ; __first != __last; ++__first)
 if (!(*__first == __val)) {
 *__result = *__first;
 ++__result;
 }
 return __result;
}

#line 253
template <class _InputIter, class _OutputIter, class _Predicate>
 inline _OutputIter
remove_copy_if(_InputIter __first, _InputIter __last, _OutputIter __result, _Predicate __pred) {

#line 257
 for ( ; __first != __last; ++__first)
 if (!__pred(*__first)) {
 *__result = *__first;
 ++__result;
 }
 return __result;
}

#line 265
template <class _ForwardIter, class _Tp>
 inline _ForwardIter
remove(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {

#line 269
 __first = find(__first, __last, __val);
 if (__first == __last)
 return __first;
 else {
 _ForwardIter __next = __first;
 return remove_copy(++__next, __last, __first, __val);
 }
}

#line 278
template <class _ForwardIter, class _Predicate>
 inline _ForwardIter
remove_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {

#line 282
 __first = find_if(__first, __last, __pred);
 if ( __first == __last )
 return __first;
 else {
 _ForwardIter __next = __first;
 return remove_copy_if(++__next, __last, __first, __pred);
 }
}

#line 292
template <class _InputIter, class _OutputIter>
_OutputIter unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result);

#line 295
template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
 _BinaryPredicate __binary_pred);

#line 299
template <class _ForwardIter>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {
 __first = adjacent_find(__first, __last);
 return unique_copy(__first, __last, __first);
}

#line 305
template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last,
 _BinaryPredicate __binary_pred) {
 __first = adjacent_find(__first, __last, __binary_pred);
 return unique_copy(__first, __last, __first, __binary_pred);
}

#line 314
template <class _BidirectionalIter>
 inline void
__reverse(_BidirectionalIter __first, _BidirectionalIter __last, const bidirectional_iterator_tag &) {
 for(; __first != __last && __first != --__last; ++__first)
 iter_swap(__first,__last);
}

#line 322
template <class _RandomAccessIter>
 inline void
__reverse(_RandomAccessIter __first, _RandomAccessIter __last, const random_access_iterator_tag &) {
 for (; __first < __last; ++__first) iter_swap(__first, --__last);
}

#line 328
template <class _BidirectionalIter>
inline void
reverse(_BidirectionalIter __first, _BidirectionalIter __last) {

#line 332
 __reverse(__first, __last, typename iterator_traits< _BidirectionalIter >::iterator_category() );
}

#line 335
template <class _BidirectionalIter, class _OutputIter>
 inline
 _OutputIter reverse_copy(_BidirectionalIter __first,
 _BidirectionalIter __last,
 _OutputIter __result) {

#line 341
 while (__first != __last) {
 --__last;
 *__result = *__last;
 ++__result;
 }
 return __result;
}

#line 351
template <class _EuclideanRingElement>
 inline
 _EuclideanRingElement __gcd(_EuclideanRingElement __m,
 _EuclideanRingElement __n)
{
 while (__n != 0) {
 _EuclideanRingElement __t = __m % __n;
 __m = __n;
 __n = __t;
 }
 return __m;
}

#line 364
template <class _ForwardIter>
_ForwardIter
rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last);

#line 368
template <class _ForwardIter, class _OutputIter>
inline _OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,
 _ForwardIter __last, _OutputIter __result) {
 return copy(__first, __middle, copy(__middle, __last, __result));
}

#line 376
template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last);

#line 379
template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
 _RandomNumberGenerator& __rand);

#line 386
template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
 _OutputIter __out, const _Distance __n);

#line 390
template <class _ForwardIter, class _OutputIter, class _Distance,
 class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
 _OutputIter __out, const _Distance __n,
 _RandomNumberGenerator& __rand);

#line 396
template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
 _RandomAccessIter __out_first, _RandomAccessIter __out_last);

#line 401
template <class _InputIter, class _RandomAccessIter,
 class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
 _RandomAccessIter __out_first, _RandomAccessIter __out_last,
 _RandomNumberGenerator& __rand);

#line 412
template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);

#line 416
template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);

#line 422
template <class _Size>
inline _Size __lg(_Size __n) {
 _Size __k;
 for (__k = 0; __n != 1; __n >>= 1) ++__k;
 return __k;
}

#line 429
template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last);
template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp);

#line 435
template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
 _RandomAccessIter __last);

#line 439
template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
 _RandomAccessIter __last, _Compare __comp);

#line 445
template <class _RandomAccessIter>
void
partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle, _RandomAccessIter __last);

#line 449
template <class _RandomAccessIter, class _Compare>
void
partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
 _RandomAccessIter __last, _Compare __comp);

#line 454
template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
 _RandomAccessIter __result_first, _RandomAccessIter __result_last);

#line 459
template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
 _RandomAccessIter __result_first,
 _RandomAccessIter __result_last, _Compare __comp);

#line 467
template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
 _RandomAccessIter __last);

#line 471
template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
 _RandomAccessIter __last, _Compare __comp);

#line 476
template <class _T1, class _T2>
struct __less_2 {
 bool operator() (const _T1& __x, const _T2 __y) const { return __x < __y ; }
};

#line 481
template <class _T1, class _T2>
__less_2<_T1,_T2> __less2(_T1*, _T2* ) { return __less_2<_T1, _T2>(); }

#line 491
template <class _ForwardIter, class _Tp>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val) {

#line 495
 return __lower_bound(__first, __last, __val,
 __less2( (typename iterator_traits< _ForwardIter >::value_type*)0 , (_Tp*)0),
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 500
template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val, _Compare __comp) {

#line 504
 return __lower_bound(__first, __last, __val, __comp, (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 507
template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val, _Compare __comp, _Distance*);

#line 511
template <class _ForwardIter, class _Tp>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val) {

#line 515
 return __upper_bound(__first, __last, __val,
 __less2( (typename iterator_traits< _ForwardIter >::value_type*)0 , (_Tp*)0),
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 520
template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val, _Compare __comp) {

#line 524
 return __upper_bound(__first, __last, __val, __comp,
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 528
template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
 _Compare __comp, _Distance*);

#line 533
template <class _ForwardIter, class _Tp>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {

#line 537
 return __equal_range(__first, __last, __val,
 __less2( (typename iterator_traits< _ForwardIter >::value_type*)0 , (_Tp*)0),
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 542
template <class _ForwardIter, class _Tp, class _Compare>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
 _Compare __comp) {

#line 547
 return __equal_range(__first, __last, __val, __comp,
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 551
template <class _ForwardIter, class _Tp>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val) {

#line 555
 _ForwardIter __i = __lower_bound(__first, __last, __val,
 __less2( (typename iterator_traits< _ForwardIter >::value_type*)0 , (_Tp*)0),
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
 return __i != __last && !(__val < *__i);
}

#line 561
template <class _ForwardIter, class _Tp, class _Compare>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val,
 _Compare __comp) {

#line 566
 _ForwardIter __i = __lower_bound(__first, __last, __val, __comp, (typename iterator_traits< _ForwardIter >::difference_type*)0 );
 return __i != __last && !__comp(__val, *__i);
}

#line 572
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result);

#line 577
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp);

#line 587
template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last) ;

#line 592
template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last, _Compare __comp);

#line 602
template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2);

#line 606
template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2, _Compare __comp);

#line 610
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result);

#line 615
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp);

#line 621
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result);

#line 626
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp);

#line 634
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result);

#line 639
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp);

#line 645
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result);

#line 652
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result,
 _Compare __comp);

#line 664
template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last);
template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
 _Compare __comp);

#line 670
template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last);

#line 673
template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
 _Compare __comp);

#line 680
template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last);

#line 683
template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
 _Compare __comp);

#line 688
template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last);

#line 692
template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
 _Compare __comp);

#line 702
template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last);

#line 705
template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
 _StrictWeakOrdering __comp);

#line 713
template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
 _StrictWeakOrdering __comp);

#line 717
template <class _ForwardIter>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last) {
 return __is_sorted(__first, __last, __less( (typename iterator_traits< _ForwardIter >::value_type*)0 ));
}

#line 722
template <class _ForwardIter, class _StrictWeakOrdering>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last,
 _StrictWeakOrdering __comp) {
 return __is_sorted(__first, __last, __comp);
}

#line 729
 }
#line 1 "../../stlport/stl/_algo.c"


#line 33
 namespace _STL {

#line 35
 template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last,
 _Distance __len1, _Distance __len2,
 _Compare __comp);

#line 43
template <class _BidirectionalIter1, class _BidirectionalIter2,
 class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
 _BidirectionalIter1 __last1,
 _BidirectionalIter2 __first2,
 _BidirectionalIter2 __last2,
 _BidirectionalIter3 __result,
 _Compare __comp);

#line 52
template <class _Tp>

#line 54
inline

#line 56
const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {
 if (__a < __b)
 if (__b < __c)
 return __b;
 else if (__a < __c)
 return __c;
 else
 return __a;
 else if (__a < __c)
 return __a;
 else if (__b < __c)
 return __c;
 else
 return __b;
}

#line 72
template <class _Tp, class _Compare>

#line 74
inline

#line 76
const _Tp&
__median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {
 if (__comp(__a, __b))
 if (__comp(__b, __c))
 return __b;
 else if (__comp(__a, __c))
 return __c;
 else
 return __a;
 else if (__comp(__a, __c))
 return __a;
 else if (__comp(__b, __c))
 return __c;
 else
 return __b;
}

#line 93
template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2)
{

#line 100
 if (__first1 == __last1 || __first2 == __last2)
 return __first1;

#line 104
 _ForwardIter2 __tmp(__first2);
 ++__tmp;
 if (__tmp == __last2)
 return find(__first1, __last1, *__first2);

#line 110
 _ForwardIter2 __p1 = __first2;
 ++__p1;

#line 113
 _ForwardIter1 __current = __first1;

#line 115
 while (__first1 != __last1) {
 __first1 = find(__first1, __last1, *__first2);
 if (__first1 == __last1)
 return __last1;

#line 120
 _ForwardIter2 __p = __p1;
 __current = __first1;
 if (++__current == __last1)
 return __last1;

#line 125
 while (*__current == *__p) {
 if (++__p == __last2)
 return __first1;
 if (++__current == __last1)
 return __last1;
 }

#line 132
 ++__first1;
 }
 return __first1;
}

#line 139
template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
 _Integer __count, const _Tp& __val) {

#line 143
 if (__count <= 0)
 return __first;
 else {
 __first = find(__first, __last, __val);
 while (__first != __last) {
 _Integer __n = __count - 1;
 _ForwardIter __i = __first;
 ++__i;
 while (__i != __last && __n != 0 && *__i == __val) {
 ++__i;
 --__n;
 }
 if (__n == 0)
 return __first;
 else
 __first = find(__i, __last, __val);
 }
 return __last;
 }
}

#line 164
template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
 _Integer __count, const _Tp& __val,
 _BinaryPred __binary_pred) {

#line 169
 if (__count <= 0)
 return __first;
 else {
 while (__first != __last) {
 if (__binary_pred(*__first, __val))
 break;
 ++__first;
 }
 while (__first != __last) {
 _Integer __n = __count - 1;
 _ForwardIter __i = __first;
 ++__i;
 while (__i != __last && __n != 0 && __binary_pred(*__i, __val)) {
 ++__i;
 --__n;
 }
 if (__n == 0)
 return __first;
 else {
 while (__i != __last) {
 if (__binary_pred(*__i, __val))
 break;
 ++__i;
 }
 __first = __i;
 }
 }
 return __last;
 }
}

#line 200
template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
 _ForwardIter2 __first2, _ForwardIter2 __last2)
{

#line 207
 return __find_end(__first1, __last1, __first2, __last2,

#line 209
 typename iterator_traits< _ForwardIter1 >::iterator_category() ,
 typename iterator_traits< _ForwardIter2 >::iterator_category() ,

#line 215
 __equal_to( (typename iterator_traits< _ForwardIter1 >::value_type*)0 )
 );
}

#line 220
template <class _InputIterator, class _OutputIterator, class _BinaryPredicate,
 class _Tp>
 inline _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result,
 _BinaryPredicate __binary_pred, _Tp*) {
 _Tp __val = *__first;
 *__result = __val;
 while (++__first != __last)
 if (!__binary_pred(__val, *__first)) {
 __val = *__first;
 *++__result = __val;
 }
 return ++__result;
}

#line 236
template <class _InputIter, class _OutputIter, class _BinaryPredicate>
inline _OutputIter
__unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
 _BinaryPredicate __binary_pred, const output_iterator_tag &) {
 return __unique_copy(__first, __last, __result, __binary_pred, (typename iterator_traits< _InputIter >::value_type*)0 );
}

#line 243
template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
 inline _ForwardIter
__unique_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
 _BinaryPredicate __binary_pred, const forward_iterator_tag &) {
 *__result = *__first;
 while (++__first != __last)
 if (!__binary_pred(*__result, *__first)) *++__result = *__first;
 return ++__result;
}

#line 272
template <class _InputIter, class _OutputIter>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result) {

#line 276
 if (__first == __last) return __result;
 return __unique_copy(__first, __last, __result, __equal_to( (typename iterator_traits< _InputIter >::value_type*)0 ),
 typename iterator_traits< _OutputIter >::iterator_category() );
}

#line 281
template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
 _BinaryPredicate __binary_pred) {

#line 286
 if (__first == __last) return __result;
 return __unique_copy(__first, __last, __result, __binary_pred,
 typename iterator_traits< _OutputIter >::iterator_category() );
}

#line 293
template <class _ForwardIter, class _Distance>
_ForwardIter __rotate(_ForwardIter __first,
 _ForwardIter __middle,
 _ForwardIter __last,
 _Distance*,
 const forward_iterator_tag &) {
 if (__first == __middle)
 return __last;
 if (__last == __middle)
 return __first;

#line 304
 _ForwardIter __first2 = __middle;
 do {
 swap(*__first++, *__first2++);
 if (__first == __middle)
 __middle = __first2;
 } while (__first2 != __last);

#line 311
 _ForwardIter __new_middle = __first;

#line 313
 __first2 = __middle;

#line 315
 while (__first2 != __last) {
 swap (*__first++, *__first2++);
 if (__first == __middle)
 __middle = __first2;
 else if (__first2 == __last)
 __first2 = __middle;
 }

#line 323
 return __new_middle;
}

#line 326
template <class _BidirectionalIter, class _Distance>
_BidirectionalIter __rotate(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last,
 _Distance*,
 const bidirectional_iterator_tag &) {
 if (__first == __middle)
 return __last;
 if (__last == __middle)
 return __first;

#line 337
 __reverse(__first, __middle, bidirectional_iterator_tag());
 __reverse(__middle, __last, bidirectional_iterator_tag());

#line 340
 while (__first != __middle && __middle != __last)
 swap (*__first++, *--__last);

#line 343
 if (__first == __middle) {
 __reverse(__middle, __last, bidirectional_iterator_tag());
 return __last;
 }
 else {
 __reverse(__first, __middle, bidirectional_iterator_tag());
 return __first;
 }
}

#line 353
template <class _RandomAccessIter, class _Distance, class _Tp>
_RandomAccessIter __rotate(_RandomAccessIter __first,
 _RandomAccessIter __middle,
 _RandomAccessIter __last,
 _Distance *, _Tp *) {

#line 359
 _Distance __n = __last - __first;
 _Distance __k = __middle - __first;
 _Distance __l = __n - __k;
 _RandomAccessIter __result = __first + (__last - __middle);

#line 364
 if (__k==0)
 return __last;

#line 367
 if (__k == __l) {
 swap_ranges(__first, __middle, __middle);
 return __result;
 }

#line 372
 _Distance __d = __gcd(__n, __k);

#line 374
 for (_Distance __i = 0; __i < __d; __i++) {
 _Tp __tmp = *__first;
 _RandomAccessIter __p = __first;

#line 378
 if (__k < __l) {
 for (_Distance __j = 0; __j < __l/__d; __j++) {
 if (__p > __first + __l) {
 *__p = *(__p - __l);
 __p -= __l;
 }

#line 385
 *__p = *(__p + __k);
 __p += __k;
 }
 }

#line 390
 else {
 for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
 if (__p < __last - __k) {
 *__p = *(__p + __k);
 __p += __k;
 }

#line 397
 *__p = * (__p - __l);
 __p -= __l;
 }
 }

#line 402
 *__p = __tmp;
 ++__first;
 }

#line 406
 return __result;
}

#line 409
template <class _RandomAccessIter, class _Distance>
inline _RandomAccessIter
__rotate(_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last,
 _Distance * __dis, const random_access_iterator_tag &) {
 return __rotate(__first, __middle, __last,
 __dis, (typename iterator_traits< _RandomAccessIter >::value_type*)0 );
}

#line 417
template <class _ForwardIter>
_ForwardIter
rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last) {

#line 422
 return __rotate(__first, __middle, __last,
 (typename iterator_traits< _ForwardIter >::difference_type*)0 ,
 typename iterator_traits< _ForwardIter >::iterator_category() );
}

#line 431
template <class _Distance>
inline _Distance __random_number(_Distance __n) {

#line 434
 return rand() % __n;

#line 438
}

#line 440
template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first,
 _RandomAccessIter __last) {

#line 444
 if (__first == __last) return;
 for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
 iter_swap(__i, __first + __random_number((__i - __first) + 1));
}

#line 449
template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
 _RandomNumberGenerator& __rand) {

#line 453
 if (__first == __last) return;
 for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
 iter_swap(__i, __first + __rand((__i - __first) + 1));
}

#line 462
template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
 _OutputIter __out, const _Distance __n)
{

#line 467
 _Distance __remaining = distance(__first, __last);
 _Distance __m = (min) (__n, __remaining);

#line 470
 while (__m > 0) {
 if (__random_number(__remaining) < __m) {
 *__out = *__first;
 ++__out;
 --__m;
 }

#line 477
 --__remaining;
 ++__first;
 }
 return __out;
}

#line 484
template <class _ForwardIter, class _OutputIter, class _Distance,
 class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
 _OutputIter __out, const _Distance __n,
 _RandomNumberGenerator& __rand)
{

#line 491
 _Distance __remaining = distance(__first, __last);
 _Distance __m = (min) (__n, __remaining);

#line 494
 while (__m > 0) {
 if (__rand(__remaining) < __m) {
 *__out = *__first;
 ++__out;
 --__m;
 }

#line 501
 --__remaining;
 ++__first;
 }
 return __out;
}

#line 507
template <class _InputIter, class _RandomAccessIter, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
 _RandomAccessIter __out,
 const _Distance __n)
{
 _Distance __m = 0;
 _Distance __t = __n;
 for ( ; __first != __last && __m < __n; ++__m, ++__first)
 __out[__m] = *__first;

#line 517
 while (__first != __last) {
 ++__t;
 _Distance __M = __random_number(__t);
 if (__M < __n)
 __out[__M] = *__first;
 ++__first;
 }

#line 525
 return __out + __m;
}

#line 528
template <class _InputIter, class _RandomAccessIter,
 class _RandomNumberGenerator, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
 _RandomAccessIter __out,
 _RandomNumberGenerator& __rand,
 const _Distance __n)
{
 _Distance __m = 0;
 _Distance __t = __n;
 for ( ; __first != __last && __m < __n; ++__m, ++__first)
 __out[__m] = *__first;

#line 540
 while (__first != __last) {
 ++__t;
 _Distance __M = __rand(__t);
 if (__M < __n)
 __out[__M] = *__first;
 ++__first;
 }

#line 548
 return __out + __m;
}

#line 551
template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
 _RandomAccessIter __out_first, _RandomAccessIter __out_last)
{

#line 558
 return __random_sample(__first, __last,
 __out_first, __out_last - __out_first);
}

#line 562
template <class _InputIter, class _RandomAccessIter, class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
 _RandomAccessIter __out_first, _RandomAccessIter __out_last,
 _RandomNumberGenerator& __rand)
{

#line 570
 return __random_sample(__first, __last,
 __out_first, __rand,
 __out_last - __out_first);
}

#line 579
template <class _ForwardIter, class _Predicate>
 inline _ForwardIter __partition(_ForwardIter __first,
 _ForwardIter __last,
 _Predicate __pred,
 const forward_iterator_tag &) {
 if (__first == __last) return __first;

#line 586
 while (__pred(*__first))
 if (++__first == __last) return __first;

#line 589
 _ForwardIter __next = __first;

#line 591
 while (++__next != __last)
 if (__pred(*__next)) {
 swap(*__first, *__next);
 ++__first;
 }
 return __first;
}

#line 599
template <class _BidirectionalIter, class _Predicate>
 inline _BidirectionalIter __partition(_BidirectionalIter __first,
 _BidirectionalIter __last,
 _Predicate __pred,
 const bidirectional_iterator_tag &) {
 while (true) {
 while (true)
 if (__first == __last)
 return __first;
 else if (__pred(*__first))
 ++__first;
 else
 break;
 --__last;
 while (true)
 if (__first == __last)
 return __first;
 else if (!__pred(*__last))
 --__last;
 else
 break;
 iter_swap(__first, __last);
 ++__first;
 }
}

#line 636
template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {

#line 639
 return __partition(__first, __last, __pred, typename iterator_traits< _ForwardIter >::iterator_category() );
}

#line 643
template <class _ForwardIter, class _Predicate, class _Distance>
_ForwardIter __inplace_stable_partition(_ForwardIter __first,
 _ForwardIter __last,
 _Predicate __pred, _Distance __len) {
 if (__len == 1)
 return __pred(*__first) ? __last : __first;
 _ForwardIter __middle = __first;
 advance(__middle, __len / 2);
 return rotate(__inplace_stable_partition(__first, __middle, __pred,
 __len / 2),
 __middle,
 __inplace_stable_partition(__middle, __last, __pred,
 __len - __len / 2));
}

#line 658
template <class _ForwardIter, class _Pointer, class _Predicate,
 class _Distance>
_ForwardIter __stable_partition_adaptive(_ForwardIter __first,
 _ForwardIter __last,
 _Predicate __pred, _Distance __len,
 _Pointer __buffer,
 _Distance __buffer_size)
{
 if (__len <= __buffer_size) {
 _ForwardIter __result1 = __first;
 _Pointer __result2 = __buffer;
 for ( ; __first != __last ; ++__first)
 if (__pred(*__first)) {
 *__result1 = *__first;
 ++__result1;
 }
 else {
 *__result2 = *__first;
 ++__result2;
 }
 copy(__buffer, __result2, __result1);
 return __result1;
 }
 else {
 _ForwardIter __middle = __first;
 advance(__middle, __len / 2);
 return rotate(__stable_partition_adaptive(
 __first, __middle, __pred,
 __len / 2, __buffer, __buffer_size),
 __middle,
 __stable_partition_adaptive(
 __middle, __last, __pred,
 __len - __len / 2, __buffer, __buffer_size));
 }
}

#line 694
template <class _ForwardIter, class _Predicate, class _Tp, class _Distance>
inline _ForwardIter
__stable_partition_aux(_ForwardIter __first, _ForwardIter __last,
 _Predicate __pred, _Tp*, _Distance*)
{
 _Temporary_buffer<_ForwardIter, _Tp> __buf(__first, __last);

#line 701
 return (__buf.size() > 0) ?
 __stable_partition_adaptive(__first, __last, __pred,
 _Distance(__buf.requested_size()),
 __buf.begin(), __buf.size()) :
 __inplace_stable_partition(__first, __last, __pred,
 _Distance(__buf.requested_size()));

#line 708
}

#line 710
template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {

#line 714
 if (__first == __last)
 return __first;
 else
 return __stable_partition_aux(__first, __last, __pred,
 (typename iterator_traits< _ForwardIter >::value_type*)0 ,
 (typename iterator_traits< _ForwardIter >::difference_type*)0 );
}

#line 722
template <class _RandomAccessIter, class _Tp, class _Compare>
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first,
 _RandomAccessIter __last,
 _Tp __pivot, _Compare __comp)
{
 while (true) {
 while (__comp(*__first, __pivot))
 ++__first;
 --__last;
 while (__comp(__pivot, *__last))
 --__last;
 if (!(__first < __last))
 return __first;
 iter_swap(__first, __last);
 ++__first;
 }
}

#line 744
template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val,
 _Compare __comp) {
 _RandomAccessIter __next = __last;
 --__next;
 while (__comp(__val, *__next)) {
 *__last = *__next;
 __last = __next;
 --__next;
 }
 *__last = __val;
}

#line 757
template <class _RandomAccessIter, class _Tp, class _Compare>
inline void __linear_insert(_RandomAccessIter __first,
 _RandomAccessIter __last, _Tp __val, _Compare __comp) {

#line 762
 if (__comp(__val, *__first)) {
 copy_backward(__first, __last, __last + 1);
 *__first = __val;
 }
 else
 __unguarded_linear_insert(__last, __val, __comp);
}

#line 770
template <class _RandomAccessIter, class _Compare>
void __insertion_sort(_RandomAccessIter __first,
 _RandomAccessIter __last, _Compare __comp) {
 if (__first == __last) return;
 for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
 __linear_insert(__first, __i, *__i, __comp);
}

#line 778
template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_insertion_sort_aux(_RandomAccessIter __first,
 _RandomAccessIter __last,
 _Tp*, _Compare __comp) {
 for (_RandomAccessIter __i = __first; __i != __last; ++__i)
 __unguarded_linear_insert(__i, _Tp(*__i), __comp);
}

#line 786
template <class _RandomAccessIter, class _Compare>
inline void __unguarded_insertion_sort(_RandomAccessIter __first,
 _RandomAccessIter __last,
 _Compare __comp) {
 __unguarded_insertion_sort_aux(__first, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0 , __comp);
}

#line 793
template <class _RandomAccessIter, class _Compare>
void __final_insertion_sort(_RandomAccessIter __first,
 _RandomAccessIter __last, _Compare __comp) {
 if (__last - __first > 16 ) {
 __insertion_sort(__first, __first + 16 , __comp);
 __unguarded_insertion_sort(__first + 16 , __last, __comp);
 }
 else
 __insertion_sort(__first, __last, __comp);
}

#line 804
template <class _RandomAccessIter, class _Tp, class _Size, class _Compare>
void __introsort_loop(_RandomAccessIter __first,
 _RandomAccessIter __last, _Tp*,
 _Size __depth_limit, _Compare __comp)
{
 while (__last - __first > 16 ) {
 if (__depth_limit == 0) {
 partial_sort(__first, __last, __last, __comp);
 return;
 }
 --__depth_limit;
 _RandomAccessIter __cut =
 __unguarded_partition(__first, __last,
 _Tp(__median(*__first,
 *(__first + (__last - __first)/2),
 *(__last - 1), __comp)),
 __comp);
 __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit, __comp);
 __last = __cut;
 }
}

#line 826
template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last) {

#line 829
 if (__first != __last) {
 __introsort_loop(__first, __last,
 (typename iterator_traits< _RandomAccessIter >::value_type*)0 ,
 __lg(__last - __first) * 2, __less( (typename iterator_traits< _RandomAccessIter >::value_type*)0 ) );
 __final_insertion_sort(__first, __last, __less( (typename iterator_traits< _RandomAccessIter >::value_type*)0 ));
 }
}

#line 837
template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp) {

#line 840
 if (__first != __last) {
 __introsort_loop(__first, __last,
 (typename iterator_traits< _RandomAccessIter >::value_type*)0 ,
 __lg(__last - __first) * 2,
 __comp);
 __final_insertion_sort(__first, __last, __comp);
 }
}

#line 851
template <class _RandomAccessIter, class _Compare>
void __inplace_stable_sort(_RandomAccessIter __first,
 _RandomAccessIter __last, _Compare __comp) {
 if (__last - __first < 15) {
 __insertion_sort(__first, __last, __comp);
 return;
 }
 _RandomAccessIter __middle = __first + (__last - __first) / 2;
 __inplace_stable_sort(__first, __middle, __comp);
 __inplace_stable_sort(__middle, __last, __comp);
 __merge_without_buffer(__first, __middle, __last,
 __middle - __first,
 __last - __middle,
 __comp);
}

#line 867
template <class _RandomAccessIter1, class _RandomAccessIter2,
 class _Distance, class _Compare>
void __merge_sort_loop(_RandomAccessIter1 __first,
 _RandomAccessIter1 __last,
 _RandomAccessIter2 __result, _Distance __step_size,
 _Compare __comp) {
 _Distance __two_step = 2 * __step_size;

#line 875
 while (__last - __first >= __two_step) {
 __result = merge(__first, __first + __step_size,
 __first + __step_size, __first + __two_step,
 __result,
 __comp);
 __first += __two_step;
 }
 __step_size = (min) (_Distance(__last - __first), __step_size);

#line 884
 merge(__first, __first + __step_size,
 __first + __step_size, __last,
 __result,
 __comp);
}

#line 890
const int __stl_chunk_size = 7;

#line 892
template <class _RandomAccessIter, class _Distance, class _Compare>
void __chunk_insertion_sort(_RandomAccessIter __first,
 _RandomAccessIter __last,
 _Distance __chunk_size, _Compare __comp)
{
 while (__last - __first >= __chunk_size) {
 __insertion_sort(__first, __first + __chunk_size, __comp);
 __first += __chunk_size;
 }
 __insertion_sort(__first, __last, __comp);
}

#line 904
template <class _RandomAccessIter, class _Pointer, class _Distance,
 class _Compare>
void __merge_sort_with_buffer(_RandomAccessIter __first,
 _RandomAccessIter __last, _Pointer __buffer,
 _Distance*, _Compare __comp) {
 _Distance __len = __last - __first;
 _Pointer __buffer_last = __buffer + __len;

#line 912
 _Distance __step_size = __stl_chunk_size;
 __chunk_insertion_sort(__first, __last, __step_size, __comp);

#line 915
 while (__step_size < __len) {
 __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
 __step_size *= 2;
 __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
 __step_size *= 2;
 }
}

#line 923
template <class _BidirectionalIter1, class _BidirectionalIter2,
 class _Distance>
_BidirectionalIter1 __rotate_adaptive(_BidirectionalIter1 __first,
 _BidirectionalIter1 __middle,
 _BidirectionalIter1 __last,
 _Distance __len1, _Distance __len2,
 _BidirectionalIter2 __buffer,
 _Distance __buffer_size) {
 if (__len1 > __len2 && __len2 <= __buffer_size) {
 _BidirectionalIter2 __buffer_end = copy(__middle, __last, __buffer);
 copy_backward(__first, __middle, __last);
 return copy(__buffer, __buffer_end, __first);
 }
 else if (__len1 <= __buffer_size) {
 _BidirectionalIter2 __buffer_end = copy(__first, __middle, __buffer);
 copy(__middle, __last, __first);
 return copy_backward(__buffer, __buffer_end, __last);
 }
 else
 return rotate(__first, __middle, __last);
}

#line 945
template <class _BidirectionalIter, class _Distance, class _Pointer,
 class _Compare>
void __merge_adaptive(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last,
 _Distance __len1, _Distance __len2,
 _Pointer __buffer, _Distance __buffer_size,
 _Compare __comp) {
 if (__len1 <= __len2 && __len1 <= __buffer_size) {
 _Pointer __buffer_end = copy(__first, __middle, __buffer);
 merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
 else if (__len2 <= __buffer_size) {
 _Pointer __buffer_end = copy(__middle, __last, __buffer);
 __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
 __comp);
 }
 else {
 _BidirectionalIter __first_cut = __first;
 _BidirectionalIter __second_cut = __middle;
 _Distance __len11 = 0;
 _Distance __len22 = 0;
 if (__len1 > __len2) {
 __len11 = __len1 / 2;
 advance(__first_cut, __len11);
 __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
 __len22 += distance(__middle, __second_cut);
 }
 else {
 __len22 = __len2 / 2;
 advance(__second_cut, __len22);
 __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
 __len11 += distance(__first, __first_cut);
 }
 _BidirectionalIter __new_middle =
 __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,
 __len22, __buffer, __buffer_size);
 __merge_adaptive(__first, __first_cut, __new_middle, __len11,
 __len22, __buffer, __buffer_size, __comp);
 __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
 __len2 - __len22, __buffer, __buffer_size, __comp);
 }
}

#line 989
template <class _RandomAccessIter, class _Pointer, class _Distance,
 class _Compare>
void __stable_sort_adaptive(_RandomAccessIter __first,
 _RandomAccessIter __last, _Pointer __buffer,
 _Distance __buffer_size, _Compare __comp) {
 _Distance __len = (__last - __first + 1) / 2;
 _RandomAccessIter __middle = __first + __len;
 if (__len > __buffer_size) {
 __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
 __comp);
 __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
 __comp);
 }
 else {
 __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)0,
 __comp);
 __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)0,
 __comp);
 }
 __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
 _Distance(__last - __middle), __buffer, __buffer_size,
 __comp);
}

#line 1013
template <class _RandomAccessIter, class _Tp, class _Distance, class _Compare>
void __stable_sort_aux(_RandomAccessIter __first,
 _RandomAccessIter __last, _Tp*, _Distance*,
 _Compare __comp) {
 _Temporary_buffer<_RandomAccessIter, _Tp> buf(__first, __last);
 if (buf.begin() == 0)
 __inplace_stable_sort(__first, __last, __comp);
 else
 __stable_sort_adaptive(__first, __last, buf.begin(),
 _Distance(buf.size()),
 __comp);
}

#line 1026
template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
 _RandomAccessIter __last) {

#line 1030
 __stable_sort_aux(__first, __last,
 (typename iterator_traits< _RandomAccessIter >::value_type*)0 ,
 (typename iterator_traits< _RandomAccessIter >::difference_type*)0 ,
 __less( (typename iterator_traits< _RandomAccessIter >::value_type*)0 ));
}

#line 1036
template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
 _RandomAccessIter __last, _Compare __comp) {

#line 1040
 __stable_sort_aux(__first, __last,
 (typename iterator_traits< _RandomAccessIter >::value_type*)0 ,
 (typename iterator_traits< _RandomAccessIter >::difference_type*)0 ,
 __comp);
}

#line 1048
template <class _RandomAccessIter, class _Tp, class _Compare>
void __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
 _RandomAccessIter __last, _Tp*, _Compare __comp) {
 make_heap(__first, __middle, __comp);
 for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
 __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,
 (typename iterator_traits< _RandomAccessIter >::difference_type*)0 );
 sort_heap(__first, __middle, __comp);
}

#line 1060
template <class _RandomAccessIter>
void
partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle, _RandomAccessIter __last) {

#line 1065
 __partial_sort(__first, __middle, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0 ,
 __less( (typename iterator_traits< _RandomAccessIter >::value_type*)0 ));
}

#line 1069
template <class _RandomAccessIter, class _Compare>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
 _RandomAccessIter __last, _Compare __comp) {

#line 1074
 __partial_sort(__first, __middle, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0 , __comp);
}

#line 1077
template <class _InputIter, class _RandomAccessIter, class _Compare,
 class _Distance, class _Tp>
_RandomAccessIter __partial_sort_copy(_InputIter __first,
 _InputIter __last,
 _RandomAccessIter __result_first,
 _RandomAccessIter __result_last,
 _Compare __comp, _Distance*, _Tp*) {
 if (__result_first == __result_last) return __result_last;
 _RandomAccessIter __result_real_last = __result_first;
 while(__first != __last && __result_real_last != __result_last) {
 *__result_real_last = *__first;
 ++__result_real_last;
 ++__first;
 }
 make_heap(__result_first, __result_real_last, __comp);
 while (__first != __last) {
 if (__comp(*__first, *__result_first))
 __adjust_heap(__result_first, _Distance(0),
 _Distance(__result_real_last - __result_first),
 _Tp(*__first),
 __comp);
 ++__first;
 }
 sort_heap(__result_first, __result_real_last, __comp);
 return __result_real_last;
}

#line 1104
template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
 _RandomAccessIter __result_first, _RandomAccessIter __result_last) {

#line 1110
 return __partial_sort_copy(__first, __last, __result_first, __result_last,
 __less( (typename iterator_traits< _InputIter >::value_type*)0 ),
 (typename iterator_traits< _RandomAccessIter >::difference_type*)0 ,
 (typename iterator_traits< _InputIter >::value_type*)0 );
}

#line 1116
template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
 _RandomAccessIter __result_first,
 _RandomAccessIter __result_last, _Compare __comp) {

#line 1123
 return __partial_sort_copy(__first, __last, __result_first, __result_last,
 __comp,
 (typename iterator_traits< _RandomAccessIter >::difference_type*)0 ,
 (typename iterator_traits< _InputIter >::value_type*)0 );
}

#line 1131
template <class _RandomAccessIter, class _Tp, class _Compare>
void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
 _RandomAccessIter __last, _Tp*, _Compare __comp) {
 while (__last - __first > 3) {
 _RandomAccessIter __cut =
 __unguarded_partition(__first, __last,
 _Tp(__median(*__first,
 *(__first + (__last - __first)/2),
 *(__last - 1),
 __comp)),
 __comp);
 if (__cut <= __nth)
 __first = __cut;
 else
 __last = __cut;
 }
 __insertion_sort(__first, __last, __comp);
}

#line 1151
template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
 _RandomAccessIter __last) {

#line 1156
 __nth_element(__first, __nth, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0 ,
 __less( (typename iterator_traits< _RandomAccessIter >::value_type*)0 ));
}

#line 1160
template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
 _RandomAccessIter __last, _Compare __comp) {

#line 1165
 __nth_element(__first, __nth, __last, (typename iterator_traits< _RandomAccessIter >::value_type*)0 , __comp);
}

#line 1170
template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,
 const _Tp& __val, _Compare __comp, _Distance*)
{
 _Distance __len = distance(__first, __last);
 _Distance __half;

#line 1177
 while (__len > 0) {
 __half = __len >> 1;
 _ForwardIter __middle = __first;
 advance(__middle, __half);
 if (__comp(__val, *__middle))
 __len = __half;
 else {
 __first = __middle;
 ++__first;
 __len = __len - __half - 1;
 }
 }
 return __first;
}

#line 1192
template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
 _Compare __comp, _Distance*)
{
 _Distance __len = distance(__first, __last);
 _Distance __half;

#line 1200
 while (__len > 0) {
 __half = __len >> 1;
 _ForwardIter __middle = __first;
 advance(__middle, __half);
 if (__comp(*__middle, __val)) {
 __first = __middle;
 ++__first;
 __len = __len - __half - 1;
 }
 else if (__comp(__val, *__middle))
 __len = __half;
 else {
 _ForwardIter __left = lower_bound(__first, __middle, __val, __comp);
 advance(__first, __len);
 _ForwardIter __right = upper_bound(++__middle, __first, __val, __comp);
 return pair<_ForwardIter, _ForwardIter>(__left, __right);
 }
 }
 return pair<_ForwardIter, _ForwardIter>(__first, __first);
}

#line 1221
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result) {

#line 1227
 while (__first1 != __last1 && __first2 != __last2) {
 if (*__first2 < *__first1) {
 *__result = *__first2;
 ++__first2;
 }
 else {
 *__result = *__first1;
 ++__first1;
 }
 ++__result;
 }
 return copy(__first2, __last2, copy(__first1, __last1, __result));
}

#line 1241
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {

#line 1248
 while (__first1 != __last1 && __first2 != __last2) {
 if (__comp(*__first2, *__first1)) {
 *__result = *__first2;
 ++__first2;
 }
 else {
 *__result = *__first1;
 ++__first1;
 }
 ++__result;
 }
 return copy(__first2, __last2, copy(__first1, __last1, __result));
}

#line 1262
template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last,
 _Distance __len1, _Distance __len2,
 _Compare __comp) {
 if (__len1 == 0 || __len2 == 0)
 return;
 if (__len1 + __len2 == 2) {
 if (__comp(*__middle, *__first))
 iter_swap(__first, __middle);
 return;
 }
 _BidirectionalIter __first_cut = __first;
 _BidirectionalIter __second_cut = __middle;
 _Distance __len11 = 0;
 _Distance __len22 = 0;
 if (__len1 > __len2) {
 __len11 = __len1 / 2;
 advance(__first_cut, __len11);
 __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
 __len22 += distance(__middle, __second_cut);
 }
 else {
 __len22 = __len2 / 2;
 advance(__second_cut, __len22);
 __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
 __len11 +=distance(__first, __first_cut);
 }
 _BidirectionalIter __new_middle
 = rotate(__first_cut, __middle, __second_cut);
 __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,
 __comp);
 __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,
 __len2 - __len22, __comp);
}

#line 1299
template <class _BidirectionalIter1, class _BidirectionalIter2,
 class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
 _BidirectionalIter1 __last1,
 _BidirectionalIter2 __first2,
 _BidirectionalIter2 __last2,
 _BidirectionalIter3 __result,
 _Compare __comp) {
 if (__first1 == __last1)
 return copy_backward(__first2, __last2, __result);
 if (__first2 == __last2)
 return copy_backward(__first1, __last1, __result);
 --__last1;
 --__last2;
 while (true) {
 if (__comp(*__last2, *__last1)) {
 *--__result = *__last1;
 if (__first1 == __last1)
 return copy_backward(__first2, ++__last2, __result);
 --__last1;
 }
 else {
 *--__result = *__last2;
 if (__first2 == __last2)
 return copy_backward(__first1, ++__last1, __result);
 --__last2;
 }
 }
}

#line 1329
template <class _BidirectionalIter, class _Tp,
 class _Distance, class _Compare>
inline void __inplace_merge_aux(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last, _Tp*, _Distance*,
 _Compare __comp) {
 _Distance __len1 = distance(__first, __middle);
 _Distance __len2 = distance(__middle, __last);

#line 1338
 _Temporary_buffer<_BidirectionalIter, _Tp> __buf(__first, __last);
 if (__buf.begin() == 0)
 __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
 else
 __merge_adaptive(__first, __middle, __last, __len1, __len2,
 __buf.begin(), _Distance(__buf.size()),
 __comp);
}

#line 1347
template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last) {

#line 1353
 if (__first == __middle || __middle == __last)
 return;
 __inplace_merge_aux(__first, __middle, __last,
 (typename iterator_traits< _BidirectionalIter >::value_type*)0 , (typename iterator_traits< _BidirectionalIter >::difference_type*)0 ,
 __less( (typename iterator_traits< _BidirectionalIter >::value_type*)0 ));
}

#line 1360
template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
 _BidirectionalIter __middle,
 _BidirectionalIter __last, _Compare __comp) {

#line 1366
 if (__first == __middle || __middle == __last)
 return;
 __inplace_merge_aux(__first, __middle, __last,
 (typename iterator_traits< _BidirectionalIter >::value_type*)0 , (typename iterator_traits< _BidirectionalIter >::difference_type*)0 ,
 __comp);
}

#line 1374
template <class _InputIter1, class _InputIter2, class _Compare>
bool __includes(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {

#line 1379
 while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
 return false;
 else if(__comp(*__first1, *__first2))
 ++__first1;
 else
 ++__first1, ++__first2;

#line 1387
 return __first2 == __last2;
}

#line 1390
template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
 return __includes(__first1, __last1, __first2, __last2, __comp);
}

#line 1396
template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2) {
 return __includes(__first1, __last1, __first2, __last2, __less( (typename iterator_traits< _InputIter1 >::value_type*)0 ));
}

#line 1402
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter __set_union(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {

#line 1409
 while (__first1 != __last1 && __first2 != __last2) {
 if (__comp(*__first1, *__first2)) {
 *__result = *__first1;
 ++__first1;
 }
 else if (__comp(*__first2, *__first1)) {
 *__result = *__first2;
 ++__first2;
 }
 else {
 *__result = *__first1;
 ++__first1;
 ++__first2;
 }
 ++__result;
 }
 return copy(__first2, __last2, copy(__first1, __last1, __result));
}

#line 1428
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result) {
 return __set_union(__first1, __last1, __first2, __last2, __result, __less( (typename iterator_traits< _InputIter1 >::value_type*)0 ));
}

#line 1435
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {
 return __set_union(__first1, __last1, __first2, __last2, __result, __comp);
}

#line 1443
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter __set_intersection(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {

#line 1450
 while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
 ++__first1;
 else if (__comp(*__first2, *__first1))
 ++__first2;
 else {
 *__result = *__first1;
 ++__first1;
 ++__first2;
 ++__result;
 }
 return __result;
}

#line 1464
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result) {
 return __set_intersection(__first1, __last1, __first2, __last2, __result, __less( (typename iterator_traits< _InputIter1 >::value_type*)0 ));
}

#line 1471
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {
 return __set_intersection(__first1, __last1, __first2, __last2, __result, __comp);
}

#line 1479
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter __set_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {

#line 1486
 while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2)) {
 *__result = *__first1;
 ++__first1;
 ++__result;
 }
 else if (__comp(*__first2, *__first1))
 ++__first2;
 else {
 ++__first1;
 ++__first2;
 }
 return copy(__first1, __last1, __result);
}

#line 1501
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result) {
 return __set_difference(__first1, __last1, __first2, __last2, __result,
 __less( (typename iterator_traits< _InputIter1 >::value_type*)0 ));
}

#line 1509
template <class _InputIter1, class _InputIter2, class _OutputIter,
 class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {
 return __set_difference(__first1, __last1, __first2, __last2, __result, __comp);
}

#line 1517
template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
__set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result, _Compare __comp) {

#line 1524
 while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2)) {
 *__result = *__first1;
 ++__first1;
 ++__result;
 }
 else if (__comp(*__first2, *__first1)) {
 *__result = *__first2;
 ++__first2;
 ++__result;
 }
 else {
 ++__first1;
 ++__first2;
 }
 return copy(__first2, __last2, copy(__first1, __last1, __result));
}

#line 1542
template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result) {
 return __set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
 __less( (typename iterator_traits< _InputIter1 >::value_type*)0 ));
}

#line 1551
template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
 _InputIter2 __first2, _InputIter2 __last2,
 _OutputIter __result,
 _Compare __comp) {
 return __set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);
}

#line 1563
template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
 _Compare __comp) {

#line 1567
 if (__first == __last) return __first;
 _ForwardIter __result = __first;
 while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
 return __result;
}

#line 1574
template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {

#line 1577
 if (__first == __last) return __first;
 _ForwardIter __result = __first;
 while (++__first != __last)
 if (*__result < *__first)
 __result = __first;
 return __result;
}

#line 1585
template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {

#line 1588
 if (__first == __last) return __first;
 _ForwardIter __result = __first;
 while (++__first != __last)
 if (*__first < *__result)
 __result = __first;
 return __result;
}

#line 1596
template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
 _Compare __comp) {

#line 1600
 if (__first == __last) return __first;
 _ForwardIter __result = __first;
 while (++__first != __last)
 if (__comp(*__first, *__result)) __result = __first;
 return __result;
}

#line 1609
template <class _BidirectionalIter, class _Compare>
bool __next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
 _Compare __comp) {

#line 1613
 if (__first == __last)
 return false;
 _BidirectionalIter __i = __first;
 ++__i;
 if (__i == __last)
 return false;
 __i = __last;
 --__i;

#line 1622
 for(;;) {
 _BidirectionalIter __ii = __i;
 --__i;
 if (__comp(*__i, *__ii)) {
 _BidirectionalIter __j = __last;
 while (!__comp(*__i, *--__j))
 {}
 iter_swap(__i, __j);
 reverse(__ii, __last);
 return true;
 }
 if (__i == __first) {
 reverse(__first, __last);
 return false;
 }
 }

#line 1641
}

#line 1643
template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {

#line 1646
 return __next_permutation(__first, __last, __less( (typename iterator_traits< _BidirectionalIter >::value_type*)0 ));
}

#line 1649
template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
 _Compare __comp) {

#line 1653
 return __next_permutation(__first, __last, __comp);
}

#line 1656
template <class _BidirectionalIter, class _Compare>
bool __prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
 _Compare __comp) {
 if (__first == __last)
 return false;
 _BidirectionalIter __i = __first;
 ++__i;
 if (__i == __last)
 return false;
 __i = __last;
 --__i;

#line 1668
 for(;;) {
 _BidirectionalIter __ii = __i;
 --__i;
 if (__comp(*__ii, *__i)) {
 _BidirectionalIter __j = __last;
 while (!__comp(*--__j, *__i))
 {}
 iter_swap(__i, __j);
 reverse(__ii, __last);
 return true;
 }
 if (__i == __first) {
 reverse(__first, __last);
 return false;
 }
 }

#line 1687
}

#line 1689
template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {

#line 1692
 return __prev_permutation(__first, __last, __less( (typename iterator_traits< _BidirectionalIter >::value_type*)0 ));
}

#line 1695
template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
 _Compare __comp) {

#line 1699
 return __prev_permutation(__first, __last, __comp);
}

#line 1709
template <class _RandomAccessIter, class _Distance, class _StrictWeakOrdering>
bool __is_heap(_RandomAccessIter __first, _StrictWeakOrdering __comp,
 _Distance __n)
{
 _Distance __parent = 0;
 for (_Distance __child = 1; __child < __n; ++__child) {
 if (__comp(__first[__parent], __first[__child]))
 return false;
 if ((__child & 1) == 0)
 ++__parent;
 }
 return true;
}

#line 1723
template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last)
{

#line 1727
 return __is_heap(__first, __less( (typename iterator_traits< _RandomAccessIter >::value_type*)0 ), __last - __first);
}

#line 1730
template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
 _StrictWeakOrdering __comp)
{

#line 1735
 return __is_heap(__first, __comp, __last - __first);
}

#line 1739
template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
 _StrictWeakOrdering __comp)
{

#line 1744
 if (__first == __last)
 return true;

#line 1747
 _ForwardIter __next = __first;
 for (++__next; __next != __last; __first = __next, ++__next) {
 if (__comp(*__next, *__first))
 return false;
 }

#line 1753
 return true;
}

#line 1758
 }
#line 733 "../../stlport/stl/_algo.h"

#line 54 "../../stlport/stl/_rope.h"

#line 1 "../../stlport/stl/_numeric.h"


#line 39
 namespace _STL {

#line 41
 template <class _InputIterator, class _Tp>
 inline
 _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp _Init)
{

#line 46
 for ( ; __first != __last; ++__first)
 _Init = _Init + *__first;
 return _Init;
}

#line 51
template <class _InputIterator, class _Tp, class _BinaryOperation>
 inline
 _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp _Init,
 _BinaryOperation __binary_op)
{

#line 57
 for ( ; __first != __last; ++__first)
 _Init = __binary_op(_Init, *__first);
 return _Init;
}

#line 62
template <class _InputIterator1, class _InputIterator2, class _Tp>
 inline
 _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
 _InputIterator2 __first2, _Tp _Init)
{

#line 68
 for ( ; __first1 != __last1; ++__first1, ++__first2)
 _Init = _Init + (*__first1 * *__first2);
 return _Init;
}

#line 73
template <class _InputIterator1, class _InputIterator2, class _Tp,
 class _BinaryOperation1, class _BinaryOperation2>
 inline
 _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
 _InputIterator2 __first2, _Tp _Init,
 _BinaryOperation1 __binary_op1,
 _BinaryOperation2 __binary_op2)
{

#line 82
 for ( ; __first1 != __last1; ++__first1, ++__first2)
 _Init = __binary_op1(_Init, __binary_op2(*__first1, *__first2));
 return _Init;
}

#line 87
template <class _InputIterator, class _OutputIterator, class _Tp,
 class _BinaryOperation>
_OutputIterator
__partial_sum(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result, _Tp*, _BinaryOperation __binary_op);

#line 94
template <class _InputIterator, class _OutputIterator>
inline _OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result) {
 return __partial_sum(__first, __last, __result, (typename iterator_traits< _InputIterator >::value_type*)0 ,
 __plus( (typename iterator_traits< _InputIterator >::value_type*)0 ));
}

#line 102
template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
inline _OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result, _BinaryOperation __binary_op) {
 return __partial_sum(__first, __last, __result, (typename iterator_traits< _InputIterator >::value_type*)0 ,
 __binary_op);
}

#line 111
template <class _InputIterator, class _OutputIterator, class _Tp,
 class _BinaryOperation>
_OutputIterator
__adjacent_difference(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result, _Tp*,
 _BinaryOperation __binary_op);

#line 118
template <class _InputIterator, class _OutputIterator>
inline _OutputIterator
adjacent_difference(_InputIterator __first,
 _InputIterator __last, _OutputIterator __result) {
 return __adjacent_difference(__first, __last, __result,
 (typename iterator_traits< _InputIterator >::value_type*)0 ,
 __minus( (typename iterator_traits< _InputIterator >::value_type*)0 ));
}

#line 127
template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
_OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result, _BinaryOperation __binary_op) {
 return __adjacent_difference(__first, __last, __result,
 (typename iterator_traits< _InputIterator >::value_type*)0 ,
 __binary_op);
}

#line 136
template <class _Tp, class _Integer, class _MonoidOperation>
_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr);

#line 144
template <class _Tp, class _Integer>
inline _Tp __power(_Tp __x, _Integer __n)
{
 return __power(__x, __n, multiplies<_Tp>());
}

#line 152
template <class _Tp, class _Integer, class _MonoidOperation>
inline _Tp power(_Tp __x, _Integer __n, _MonoidOperation __opr) {
 return __power(__x, __n, __opr);
}

#line 158
template <class _Tp, class _Integer>
inline _Tp power(_Tp __x, _Integer __n) {
 return __power(__x, __n, multiplies<_Tp>());
}

#line 165
template <class _ForwardIterator, class _Tp>
 inline
 void
iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __val)
{

#line 171
 while (__first != __last)
 *__first++ = __val++;
}

#line 176
 }
#line 1 "../../stlport/stl/_numeric.c"


#line 33
 namespace _STL {

#line 35
 template <class _InputIterator, class _OutputIterator, class _Tp,
 class _BinaryOperation>
_OutputIterator
__partial_sum(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result, _Tp*, _BinaryOperation __binary_op)
{

#line 42
 if (__first == __last) return __result;
 *__result = *__first;

#line 45
 _Tp __val = *__first;
 while (++__first != __last) {
 __val = __binary_op(__val, *__first);
 *++__result = __val;
 }
 return ++__result;
}

#line 53
template <class _InputIterator, class _OutputIterator, class _Tp,
 class _BinaryOperation>
_OutputIterator
__adjacent_difference(_InputIterator __first, _InputIterator __last,
 _OutputIterator __result, _Tp*,
 _BinaryOperation __binary_op) {

#line 60
 if (__first == __last) return __result;
 *__result = *__first;
 _Tp __val = *__first;
 while (++__first != __last) {
 _Tp __tmp = *__first;
 *++__result = __binary_op(__tmp, __val);
 __val = __tmp;
 }
 return ++__result;
}

#line 72
template <class _Tp, class _Integer, class _MonoidOperation>
_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr)
{

#line 76
 if (__n == 0)
 return __identity_element(__opr);
 else {
 while ((__n & 1) == 0) {
 __n >>= 1;
 __x = __opr(__x, __x);
 }
 _Tp __result = __x;

#line 85
 __n >>= 1;
 while (__n != 0) {
 __x = __opr(__x, __x);
 if ((__n & 1) != 0)
 __result = __opr(__result, __x);
 __n >>= 1;
 }
 return __result;

#line 94
 }

#line 96
}

#line 98
 }
#line 180 "../../stlport/stl/_numeric.h"

#line 62 "../../stlport/stl/_rope.h"


#line 86
 namespace _STL {

#line 91
 template<class _CharT, class _Alloc = allocator< _CharT > > class rope;
template<class _CharT, class _Alloc> struct _Rope_RopeConcatenation;
template<class _CharT, class _Alloc> struct _Rope_RopeRep;
template<class _CharT, class _Alloc> struct _Rope_RopeLeaf;
template<class _CharT, class _Alloc> struct _Rope_RopeFunction;
template<class _CharT, class _Alloc> struct _Rope_RopeSubstring;
template<class _CharT, class _Alloc> class _Rope_iterator;
template<class _CharT, class _Alloc> class _Rope_const_iterator;
template<class _CharT, class _Alloc> class _Rope_char_ref_proxy;
template<class _CharT, class _Alloc> class _Rope_char_ptr_proxy;

#line 107
template<class _CharT, class _Alloc>
struct _Rope_Concat_fn
 : public binary_function<rope<_CharT,_Alloc>, rope<_CharT,_Alloc>,
 rope<_CharT,_Alloc> > {
 rope<_CharT,_Alloc> operator() (const rope<_CharT,_Alloc>& __x,
 const rope<_CharT,_Alloc>& __y) {
 return __x + __y;
 }
};

#line 117
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>
__identity_element(_Rope_Concat_fn<_CharT, _Alloc>)
{
 return rope<_CharT,_Alloc>();
}

#line 130
template <class _CharT>
inline _CharT _S_eos(_CharT*) { return _CharT(); }

#line 134
inline const char _S_eos(const char*) { return 0; }

#line 136
inline const wchar_t _S_eos(const wchar_t*) { return 0; }

#line 141
template <class _CharT>
inline bool _S_is_basic_char_type(_CharT*) { return false; }
template <class _CharT>
inline bool _S_is_one_byte_char_type(_CharT*) { return false; }

#line 146
inline bool _S_is_basic_char_type(char*) { return true; }
inline bool _S_is_one_byte_char_type(char*) { return true; }

#line 149
inline bool _S_is_basic_char_type(wchar_t*) { return true; }

#line 154
template <class _CharT>
inline void _S_cond_store_eos(_CharT&) {}

#line 157
inline void _S_cond_store_eos(char& __c) { __c = 0; }

#line 159
inline void _S_cond_store_eos(wchar_t& __c) { __c = 0; }

#line 166
template <class _CharT>
class char_producer {
public:
 virtual ~char_producer() {};
 virtual void operator()(size_t __start_pos, size_t __len,
 _CharT* __buffer) = 0;

#line 176
};

#line 192
template<class _Sequence

#line 195
, size_t _Buf_sz = 100

#line 201
>

#line 203
class sequence_buffer : public iterator <output_iterator_tag, void, void, void, void> {
public:

#line 206
 typedef typename _Sequence::value_type value_type;
 typedef sequence_buffer<_Sequence

#line 210
 , _Buf_sz
 > _Self;

#line 221
protected:
 _Sequence* _M_prefix;
 value_type _M_buffer[_Buf_sz];
 size_t _M_buf_count;
public:
 void flush() {
 _M_prefix->append(_M_buffer, _M_buffer + _M_buf_count);
 _M_buf_count = 0;
 }
 ~sequence_buffer() { flush(); }
 sequence_buffer() : _M_prefix(0), _M_buf_count(0) {}
 sequence_buffer(const _Self& __x) {
 _M_prefix = __x._M_prefix;
 _M_buf_count = __x._M_buf_count;
 copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);
 }
 sequence_buffer(_Self& __x) {
 __x.flush();
 _M_prefix = __x._M_prefix;
 _M_buf_count = 0;
 }
 sequence_buffer(_Sequence& __s) : _M_prefix(&__s), _M_buf_count(0) {}
 _Self& operator= (_Self& __x) {
 __x.flush();
 _M_prefix = __x._M_prefix;
 _M_buf_count = 0;
 return *this;
 }
 _Self& operator= (const _Self& __x) {
 _M_prefix = __x._M_prefix;
 _M_buf_count = __x._M_buf_count;
 copy(__x._M_buffer, __x._M_buffer + __x._M_buf_count, _M_buffer);
 return *this;
 }
 void push_back(value_type __x)
 {
 if (_M_buf_count < _Buf_sz) {
 _M_buffer[_M_buf_count] = __x;
 ++_M_buf_count;
 } else {
 flush();
 _M_buffer[0] = __x;
 _M_buf_count = 1;
 }
 }
 void append(value_type* __s, size_t __len)
 {
 if (__len + _M_buf_count <= _Buf_sz) {
 size_t __i = _M_buf_count;
 size_t __j = 0;
 for (; __j < __len; __i++, __j++) {
 _M_buffer[__i] = __s[__j];
 }
 _M_buf_count += __len;
 } else if (0 == _M_buf_count) {
 _M_prefix->append(__s, __s + __len);
 } else {
 flush();
 append(__s, __len);
 }
 }
 _Self& write(value_type* __s, size_t __len)
 {
 append(__s, __len);
 return *this;
 }
 _Self& put(value_type __x)
 {
 push_back(__x);
 return *this;
 }
 _Self& operator=(const value_type& __rhs)
 {
 push_back(__rhs);
 return *this;
 }
 _Self& operator*() { return *this; }
 _Self& operator++() { return *this; }
 _Self& operator++(int) { return *this; }
};

#line 303
template<class _CharT>
class _Rope_char_consumer {
public:

#line 311
 virtual ~_Rope_char_consumer() {};
 virtual bool operator()(const _CharT* __buffer, size_t __len) = 0;
};

#line 367
template<class _CharT, class _Alloc>
struct _Rope_RopeRep

#line 370
 : public _Refcount_Base

#line 372
{
 typedef _Rope_RopeRep<_CharT, _Alloc> _Self;
public:

#line 377
 enum { _S_max_rope_depth = 45 };
 enum _Tag {_S_leaf, _S_concat, _S_substringfn, _S_function};

#line 383
 enum { _S_alloc_granularity = 8 };

#line 386
 _Tag _M_tag:8;
 bool _M_is_balanced:8;

#line 389
 typedef typename _Alloc_traits<_CharT,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_CharT>::other _STLP_dummy_type2;
 typedef typename _Alloc_traits<_CharT,_Alloc>::allocator_type
 allocator_type;

#line 393
 allocator_type get_allocator() const { return allocator_type(_M_size); }

#line 395
 unsigned char _M_depth;
 _CharT* _M_c_string;
 _STLP_alloc_proxy<size_t, _CharT, allocator_type> _M_size;

#line 409
 _Rope_RopeRep(_Tag __t, int __d, bool __b, size_t _p_size,
 allocator_type __a) :

#line 412
 _Refcount_Base(1),

#line 414
 _M_tag(__t), _M_is_balanced(__b), _M_depth(__d), _M_c_string(0), _M_size(__a, _p_size)
 { }

#line 421
 static size_t _S_rounded_up_size(size_t __n) {
 size_t __size_with_eos;

#line 424
 if (_S_is_basic_char_type((_CharT*)0)) {
 __size_with_eos = __n + 1;
 } else {
 __size_with_eos = __n;
 }

#line 433
 return (__size_with_eos + _S_alloc_granularity-1)
 &~ (_S_alloc_granularity-1);

#line 436
 }

#line 438
 static void _S_free_string( _CharT* __s, size_t __len,
 allocator_type __a) {

#line 441
 if (!_S_is_basic_char_type((_CharT*)0)) {
 _Destroy(__s, __s + __len);
 }

#line 446
 __a.deallocate(__s, _S_rounded_up_size(__len));

#line 450
 }

#line 459
 void _M_free_c_string();
 void _M_free_tree();

#line 462
 void _M_unref_nonnil()
 {
 _M_decr(); if (!_M_ref_count) _M_free_tree();
 }
 void _M_ref_nonnil()
 {
 _M_incr();
 }
 static void _S_unref(_Self* __t)
 {
 if (0 != __t) {
 __t->_M_unref_nonnil();
 }
 }
 static void _S_ref(_Self* __t)
 {
 if (0 != __t) __t->_M_incr();
 }
 static void _S_free_if_unref(_Self* __t)
 {
 if (0 != __t && 0 == __t->_M_ref_count) __t->_M_free_tree();
 }

#line 492
 typedef typename _Alloc_traits<_CharT,_Alloc>::allocator_type _DataAllocator; typedef _Rope_RopeConcatenation<_CharT,_Alloc> __C; typedef typename _Alloc_traits<__C,_Alloc>::allocator_type _CAllocator; typedef _Rope_RopeLeaf<_CharT,_Alloc> __L; typedef typename _Alloc_traits<__L,_Alloc>::allocator_type _LAllocator; typedef _Rope_RopeFunction<_CharT,_Alloc> __F; typedef typename _Alloc_traits<__F,_Alloc>::allocator_type _FAllocator; typedef _Rope_RopeSubstring<_CharT,_Alloc> __S; typedef typename _Alloc_traits<__S,_Alloc>::allocator_type _SAllocator;
 };

#line 495
template<class _CharT, class _Alloc>
struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {
public:
 _CharT* _M_data;

#line 503
 typedef typename _Alloc_traits<_CharT,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_CharT>::other _STLP_dummy_type2;
 typedef typename _Rope_RopeRep<_CharT,_Alloc>::allocator_type allocator_type;
 _Rope_RopeLeaf( _CharT* __d, size_t _p_size, allocator_type __a)
 : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_leaf, 0, true, _p_size, __a),
 _M_data(__d)
 {

#line 510
 if (_S_is_basic_char_type((_CharT *)0)) {

#line 512
 this->_M_c_string = __d;
 }
 }

#line 525
 ~_Rope_RopeLeaf() {
 if (_M_data != this->_M_c_string) {
 this->_M_free_c_string();
 }
 _S_free_string(_M_data, this->_M_size._M_data, this->get_allocator());
 }

#line 532
};

#line 534
template<class _CharT, class _Alloc>
struct _Rope_RopeConcatenation : public _Rope_RopeRep<_CharT,_Alloc> {
public:
 _Rope_RopeRep<_CharT,_Alloc>* _M_left;
 _Rope_RopeRep<_CharT,_Alloc>* _M_right;
 typedef typename _Alloc_traits<_CharT,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_CharT>::other _STLP_dummy_type2;
 typedef typename _Rope_RopeRep<_CharT,_Alloc>::allocator_type allocator_type;
 _Rope_RopeConcatenation(_Rope_RopeRep<_CharT,_Alloc>* __l,
 _Rope_RopeRep<_CharT,_Alloc>* __r,
 allocator_type __a)
 : _Rope_RopeRep<_CharT,_Alloc>(
 _Rope_RopeRep<_CharT,_Alloc>::_S_concat,
 (max)(__l->_M_depth, __r->_M_depth) + 1, false,
 __l->_M_size._M_data + __r->_M_size._M_data, __a), _M_left(__l), _M_right(__r)
 {}

#line 555
 ~_Rope_RopeConcatenation() {
 this->_M_free_c_string();
 _M_left->_M_unref_nonnil();
 _M_right->_M_unref_nonnil();
 }

#line 561
};

#line 563
template<class _CharT, class _Alloc>
struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {
public:
 char_producer<_CharT>* _M_fn;

#line 568
 bool _M_delete_when_done;

#line 582
 typedef typename _Alloc_traits<_CharT,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_CharT>::other _STLP_dummy_type2;
 typedef typename _Rope_RopeRep<_CharT,_Alloc>::allocator_type allocator_type;

#line 589
 _Rope_RopeFunction(char_producer<_CharT>* __f, size_t _p_size,
 bool __d, allocator_type __a)
 :
 _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_function, 0, true, _p_size, __a),
 _M_fn(__f)

#line 595
 , _M_delete_when_done(__d)

#line 597
 {

#line 604


#line 605
 }

#line 607
 ~_Rope_RopeFunction() {
 this->_M_free_c_string();
 if (_M_delete_when_done) {
 delete _M_fn;
 }
 }

#line 614
};

#line 622
template<class _CharT, class _Alloc>

#line 626
struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,
 public char_producer<_CharT>

#line 629
{
public:

#line 632
 typedef _Rope_RopeRep<_CharT,_Alloc> _Base;
 _Rope_RopeRep<_CharT,_Alloc>* _M_base;
 size_t _M_start;
 virtual void operator()(size_t __start_pos, size_t __req_len,
 _CharT* __buffer) {
 switch(_M_base->_M_tag) {
 case _Base::_S_function:
 case _Base::_S_substringfn:
 {
 char_producer<_CharT>* __fn =
 ((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;

#line 645
 (*__fn)(__start_pos + _M_start, __req_len, __buffer);
 }
 break;
 case _Base::_S_leaf:
 {
 _CharT* __s =
 ((_Rope_RopeLeaf<_CharT,_Alloc>*)_M_base)->_M_data;
 uninitialized_copy_n(__s + __start_pos + _M_start, __req_len,
 __buffer);
 }
 break;
 default:

#line 658
 ;
 }
 }

#line 662
 typedef typename _Alloc_traits<_CharT,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_CharT>::other _STLP_dummy_type2;
 typedef typename _Rope_RopeRep<_CharT,_Alloc>::allocator_type allocator_type;

#line 665
 _Rope_RopeSubstring(_Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,
 size_t __l, allocator_type __a)
 : _Rope_RopeFunction<_CharT,_Alloc>(this, __l, false, __a),
 _M_base(__b),
 _M_start(__s)

#line 671
 {

#line 674


#line 675
 _M_base->_M_ref_nonnil();

#line 677
 this->_M_tag = _Base::_S_substringfn;
 }
 virtual ~_Rope_RopeSubstring()
 {

#line 682
 _M_base->_M_unref_nonnil();

#line 684
 }
};

#line 697
template<class _CharT, class _Alloc>
struct _Rope_self_destruct_ptr {
 _Rope_RopeRep<_CharT,_Alloc>* _M_ptr;
 ~_Rope_self_destruct_ptr()
 { _Rope_RopeRep<_CharT,_Alloc>::_S_unref(_M_ptr); }

#line 703
 _Rope_self_destruct_ptr() : _M_ptr(0) {};

#line 707
 _Rope_self_destruct_ptr(_Rope_RopeRep<_CharT,_Alloc>* __p) : _M_ptr(__p) {}
 _Rope_RopeRep<_CharT,_Alloc>& operator*() { return *_M_ptr; }
 _Rope_RopeRep<_CharT,_Alloc>* operator->() { return _M_ptr; }
 operator _Rope_RopeRep<_CharT,_Alloc>*() { return _M_ptr; }
 _Rope_self_destruct_ptr<_CharT, _Alloc>&
 operator= (_Rope_RopeRep<_CharT,_Alloc>* __x)
 { _M_ptr = __x; return *this; }
};

#line 722
template<class _CharT, class _Alloc>
class _Rope_char_ref_proxy {
 typedef _Rope_char_ref_proxy<_CharT, _Alloc> _Self;
 friend class rope<_CharT,_Alloc>;
 friend class _Rope_iterator<_CharT,_Alloc>;
 friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;

#line 731
 typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;

#line 733
 typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;
 typedef rope<_CharT,_Alloc> _My_rope;
 size_t _M_pos;
 _CharT _M_current;
 bool _M_current_valid;
 _My_rope* _M_root;
public:
 _Rope_char_ref_proxy(_My_rope* __r, size_t __p) :
 _M_pos(__p), _M_current_valid(false), _M_root(__r) {}
 _Rope_char_ref_proxy(const _Self& __x) :
 _M_pos(__x._M_pos), _M_current_valid(false), _M_root(__x._M_root) {}

#line 748
 _Rope_char_ref_proxy(_My_rope* __r, size_t __p,
 _CharT __c) :
 _M_pos(__p), _M_current(__c), _M_current_valid(true), _M_root(__r) {}
 inline operator _CharT () const;
 _Self& operator= (_CharT __c);
 _Rope_char_ptr_proxy<_CharT, _Alloc> operator& () const;
 _Self& operator= (const _Self& __c) {
 return operator=((_CharT)__c);
 }
};

#line 760
template<class _CharT, class __Alloc>
inline void swap(_Rope_char_ref_proxy <_CharT, __Alloc > __a,
 _Rope_char_ref_proxy <_CharT, __Alloc > __b) {
 _CharT __tmp = __a;
 __a = __b;
 __b = __tmp;
}

#line 786
 template<class _CharT, class _Alloc>
class _Rope_char_ptr_proxy {

#line 789
public:
 typedef _Rope_char_ptr_proxy<_CharT, _Alloc> _Self;
 friend class _Rope_char_ref_proxy<_CharT,_Alloc>;
 size_t _M_pos;
 rope<_CharT,_Alloc>* _M_root;

#line 795
 _Rope_char_ptr_proxy(const _Rope_char_ref_proxy<_CharT,_Alloc>& __x)
 : _M_pos(__x._M_pos), _M_root(__x._M_root) {}
 _Rope_char_ptr_proxy(const _Self& __x)
 : _M_pos(__x._M_pos), _M_root(__x._M_root) {}
 _Rope_char_ptr_proxy() {}
 _Rope_char_ptr_proxy(_CharT* __x) : _M_pos(0), _M_root(0) {

#line 802
 }
 _Self&
 operator= (const _Self& __x) {
 _M_pos = __x._M_pos;
 _M_root = __x._M_root;
 return *this;
 }

#line 810
 _Rope_char_ref_proxy<_CharT,_Alloc> operator*() const {
 return _Rope_char_ref_proxy<_CharT,_Alloc>(_M_root, _M_pos);
 }
};

#line 825
template<class _CharT, class _Alloc>
class _Rope_iterator_base

#line 828
{
 friend class rope<_CharT,_Alloc>;
 typedef _Rope_iterator_base<_CharT, _Alloc> _Self;
public:
 typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;

#line 835
 enum { _S_path_cache_len = 4 };
 enum { _S_iterator_buf_len = 15 };
 size_t _M_current_pos;
 _RopeRep* _M_root;
 size_t _M_leaf_pos;
 _CharT* _M_buf_start;

#line 843
 _CharT* _M_buf_ptr;

#line 846
 _CharT* _M_buf_end;

#line 852
 const _RopeRep* _M_path_end[_S_path_cache_len];
 int _M_leaf_index;

#line 856
 unsigned char _M_path_directions;

#line 861
 _CharT _M_tmp_buf[_S_iterator_buf_len];

#line 869
 static void _S_setbuf(_Rope_iterator_base<_CharT, _Alloc>& __x);

#line 872
 static void _S_setcache(_Rope_iterator_base<_CharT, _Alloc>& __x);

#line 875
 static void _S_setcache_for_incr(_Rope_iterator_base<_CharT, _Alloc>& __x);

#line 878
 _Rope_iterator_base() {}
 _Rope_iterator_base(_RopeRep* __root, size_t __pos)
 : _M_current_pos(__pos),_M_root(__root), _M_buf_ptr(0) {}
 void _M_incr(size_t __n);
 void _M_decr(size_t __n);
public:
 size_t index() const { return _M_current_pos; }
 _Rope_iterator_base(const _Self& __x) {
 if (0 != __x._M_buf_ptr) {
 *this = __x;
 } else {
 _M_current_pos = __x._M_current_pos;
 _M_root = __x._M_root;
 _M_buf_ptr = 0;
 }
 }
};

#line 896
template<class _CharT, class _Alloc> class _Rope_iterator;

#line 898
template<class _CharT, class _Alloc>
class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {
 friend class rope<_CharT,_Alloc>;
 typedef _Rope_const_iterator<_CharT, _Alloc> _Self;
 typedef _Rope_iterator_base<_CharT,_Alloc> _Base;

#line 904
public:

#line 906
 typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;

#line 909
 _Rope_const_iterator(const _RopeRep* __root, size_t __pos):
 _Rope_iterator_base<_CharT,_Alloc>(
 const_cast<_RopeRep*>(__root) , __pos)

#line 913
 {}
public:
 typedef _CharT reference;

#line 918
 typedef const _CharT* pointer;
 typedef _CharT value_type;
 typedef ptrdiff_t difference_type;
 typedef random_access_iterator_tag iterator_category;

#line 923
public:
 _Rope_const_iterator() {};
 _Rope_const_iterator(const _Self& __x) :
 _Rope_iterator_base<_CharT,_Alloc>(__x) { }
 _Rope_const_iterator(const _Rope_iterator<_CharT,_Alloc>& __x):
 _Rope_iterator_base<_CharT,_Alloc>(__x) {}
 _Rope_const_iterator(const rope<_CharT,_Alloc>& __r, size_t __pos) :
 _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr._M_data, __pos) {}
 _Self& operator= (const _Self& __x) {
 if (0 != __x._M_buf_ptr) {
 *( static_cast<_Base*>(this) ) = __x;
 } else {
 this->_M_current_pos = __x._M_current_pos;
 this->_M_root = __x._M_root;
 this->_M_buf_ptr = 0;
 }
 return(*this);
 }
 reference operator*() {
 if (0 == this->_M_buf_ptr) _S_setcache(*this);
 return *(this->_M_buf_ptr);
 }
 _Self& operator++() {
 _CharT* __next;
 if (0 != this->_M_buf_ptr && (__next = this->_M_buf_ptr + 1) < this->_M_buf_end) {
 this->_M_buf_ptr = __next;
 ++this->_M_current_pos;
 } else {
 this->_M_incr(1);
 }
 return *this;
 }
 _Self& operator+=(ptrdiff_t __n) {
 if (__n >= 0) {
 this->_M_incr(__n);
 } else {
 this->_M_decr(-__n);
 }
 return *this;
 }
 _Self& operator--() {
 this->_M_decr(1);
 return *this;
 }
 _Self& operator-=(ptrdiff_t __n) {
 if (__n >= 0) {
 this->_M_decr(__n);
 } else {
 this->_M_incr(-__n);
 }
 return *this;
 }
 _Self operator++(int) {
 size_t __old_pos = this->_M_current_pos;
 this->_M_incr(1);
 return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);

#line 982
 }
 _Self operator--(int) {
 size_t __old_pos = this->_M_current_pos;
 this->_M_decr(1);
 return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);
 }
 inline reference operator[](size_t __n);
};

#line 991
template<class _CharT, class _Alloc>
class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {
 friend class rope<_CharT,_Alloc>;
 typedef _Rope_iterator<_CharT, _Alloc> _Self;
 typedef _Rope_iterator_base<_CharT,_Alloc> _Base;
 typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;

#line 998
public:
 rope<_CharT,_Alloc>* _M_root_rope;

#line 1007
 _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos);

#line 1009
 void _M_check();
public:
 typedef _Rope_char_ref_proxy<_CharT,_Alloc> reference;
 typedef _Rope_char_ref_proxy<_CharT,_Alloc>* pointer;
 typedef _CharT value_type;
 typedef ptrdiff_t difference_type;
 typedef random_access_iterator_tag iterator_category;
public:
 ~_Rope_iterator()
 {
 _RopeRep::_S_unref(this->_M_root);
 }

#line 1022
 rope<_CharT,_Alloc>& container() { return *_M_root_rope; }
 _Rope_iterator() {
 this->_M_root = 0;
 };
 _Rope_iterator(const _Self& __x) :
 _Rope_iterator_base<_CharT,_Alloc>(__x) {
 _M_root_rope = __x._M_root_rope;
 _RopeRep::_S_ref(this->_M_root);
 }
 _Rope_iterator(rope<_CharT,_Alloc>& __r, size_t __pos);
 _Self& operator= (const _Self& __x) {
 _RopeRep* __old = this->_M_root;

#line 1035
 _RopeRep::_S_ref(__x._M_root);
 if (0 != __x._M_buf_ptr) {
 _M_root_rope = __x._M_root_rope;
 *( static_cast<_Base*>(this) ) = __x;
 } else {
 this->_M_current_pos = __x._M_current_pos;
 this->_M_root = __x._M_root;
 _M_root_rope = __x._M_root_rope;
 this->_M_buf_ptr = 0;
 }
 _RopeRep::_S_unref(__old);
 return(*this);
 }
 reference operator*() {
 _M_check();
 if (0 == this->_M_buf_ptr) {
 return _Rope_char_ref_proxy<_CharT,_Alloc>(
 _M_root_rope, this->_M_current_pos);
 } else {
 return _Rope_char_ref_proxy<_CharT,_Alloc>(
 _M_root_rope, this->_M_current_pos, *(this->_M_buf_ptr));
 }
 }
 _Self& operator++() {
 this->_M_incr(1);
 return *this;
 }
 _Self& operator+=(ptrdiff_t __n) {
 if (__n >= 0) {
 this->_M_incr(__n);
 } else {
 this->_M_decr(-__n);
 }
 return *this;
 }
 _Self& operator--() {
 this->_M_decr(1);
 return *this;
 }
 _Self& operator-=(ptrdiff_t __n) {
 if (__n >= 0) {
 this->_M_decr(__n);
 } else {
 this->_M_incr(-__n);
 }
 return *this;
 }
 _Self operator++(int) {
 size_t __old_pos = this->_M_current_pos;
 this->_M_incr(1);
 return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);
 }
 _Self operator--(int) {
 size_t __old_pos = this->_M_current_pos;
 this->_M_decr(1);
 return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);
 }
 reference operator[](ptrdiff_t __n) {
 return _Rope_char_ref_proxy<_CharT,_Alloc>(
 _M_root_rope, this->_M_current_pos + __n);
 }
};

#line 1115
template <class _CharT, class _Alloc>
class rope {
 typedef rope<_CharT,_Alloc> _Self;
public:
 typedef _CharT value_type;
 typedef ptrdiff_t difference_type;
 typedef size_t size_type;
 typedef _CharT const_reference;
 typedef const _CharT* const_pointer;
 typedef _Rope_iterator<_CharT,_Alloc> iterator;
 typedef _Rope_const_iterator<_CharT,_Alloc> const_iterator;
 typedef _Rope_char_ref_proxy<_CharT,_Alloc> reference;
 typedef _Rope_char_ptr_proxy<_CharT,_Alloc> pointer;

#line 1129
 friend class _Rope_iterator<_CharT,_Alloc>;
 friend class _Rope_const_iterator<_CharT,_Alloc>;
 friend struct _Rope_RopeRep<_CharT,_Alloc>;
 friend class _Rope_iterator_base<_CharT,_Alloc>;
 friend class _Rope_char_ptr_proxy<_CharT,_Alloc>;
 friend class _Rope_char_ref_proxy<_CharT,_Alloc>;
 friend struct _Rope_RopeSubstring<_CharT,_Alloc>;

#line 1137
 typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator ;

#line 1139
protected:
 typedef _CharT* _Cstrptr;

#line 1142
 static _CharT _S_empty_c_str[1];

#line 1144
 static bool _S_is0(_CharT __c) { return __c == _S_eos((_CharT*)0); }
 enum { _S_copy_max = 23 };

#line 1149
public:
 typedef _Rope_RopeRep<_CharT, _Alloc> _RopeRep;
 typedef typename _Alloc_traits<_CharT,_Alloc>::_Orig _STLP_dummy_type1; typedef typename _STLP_dummy_type1:: template rebind<_CharT>::other _STLP_dummy_type2;
 typedef typename _Alloc_traits<_CharT,_Alloc>::allocator_type allocator_type;
 allocator_type get_allocator() const { return allocator_type(_M_tree_ptr); }
public:

#line 1156
 _STLP_alloc_proxy<_RopeRep*, _CharT, allocator_type> _M_tree_ptr;

#line 1158
 typedef _Rope_RopeConcatenation<_CharT,_Alloc> _RopeConcatenation;
 typedef _Rope_RopeLeaf<_CharT,_Alloc> _RopeLeaf;
 typedef _Rope_RopeFunction<_CharT,_Alloc> _RopeFunction;
 typedef _Rope_RopeSubstring<_CharT,_Alloc> _RopeSubstring;

#line 1166
 static _CharT _S_fetch(_RopeRep* __r, size_type __pos);

#line 1175
 static _CharT* _S_fetch_ptr(_RopeRep* __r, size_type __pos);

#line 1178
 static bool _S_apply_to_pieces(

#line 1180
 _Rope_char_consumer<_CharT>& __c,
 const _RopeRep* __r,
 size_t __begin, size_t __end);

#line 1186
 static void _S_unref(_RopeRep* __t)
 {
 _RopeRep::_S_unref(__t);
 }
 static void _S_ref(_RopeRep* __t)
 {
 _RopeRep::_S_ref(__t);
 }

#line 1203
 typedef _Rope_self_destruct_ptr<_CharT,_Alloc> _Self_destruct_ptr;

#line 1207
 static _RopeRep* _S_substring(_RopeRep* __base,
 size_t __start, size_t __endp1);

#line 1210
 static _RopeRep* _S_concat_char_iter(_RopeRep* __r,
 const _CharT* __iter, size_t __slen);

#line 1215
 static _RopeRep* _S_destr_concat_char_iter(_RopeRep* __r,
 const _CharT* __iter, size_t __slen)

#line 1224
 ;

#line 1227
 static _RopeRep* _S_concat_rep(_RopeRep* __left, _RopeRep* __right);

#line 1231
public:
 void apply_to_pieces( size_t __begin, size_t __end,
 _Rope_char_consumer<_CharT>& __c) const {
 _S_apply_to_pieces(__c, _M_tree_ptr._M_data, __begin, __end);
 }

#line 1238
protected:

#line 1240
 static size_t _S_rounded_up_size(size_t __n) {
 return _RopeRep::_S_rounded_up_size(__n);
 }

#line 1244
 static size_t _S_allocated_capacity(size_t __n) {
 if (_S_is_basic_char_type((_CharT*)0)) {
 return _S_rounded_up_size(__n) - 1;
 } else {
 return _S_rounded_up_size(__n);
 }
 }

#line 1254
 static _RopeLeaf* _S_new_RopeLeaf( _CharT *__s,
 size_t _p_size, allocator_type __a)
 {
 _RopeLeaf* __space = (_Alloc_traits<_RopeLeaf,allocator_type>::create_allocator(__a)) .allocate(1,(const void*)0);
 try {
 new (__space) _RopeLeaf(__s, _p_size, __a);
 }
 catch(...) { (_Alloc_traits<_RopeLeaf,allocator_type>::create_allocator(__a)).deallocate(__space, 1); throw; }
 return
 __space;
 }

#line 1266
 static _RopeConcatenation* _S_new_RopeConcatenation(
 _RopeRep* __left, _RopeRep* __right,
 allocator_type __a)
 {
 _RopeConcatenation* __space = (_Alloc_traits<_RopeConcatenation,allocator_type>::create_allocator(__a)) .
allocate(1,(const void*)0);
 return new (__space) _RopeConcatenation(__left, __right, __a);
 }

#line 1275
 static _RopeFunction* _S_new_RopeFunction(char_producer<_CharT>* __f,
 size_t _p_size, bool __d, allocator_type __a)
 {
 _RopeFunction* __space = (_Alloc_traits<_RopeFunction,allocator_type>::create_allocator(__a)) .
allocate(1,(const void*)0);
 return new (__space) _RopeFunction(__f, _p_size, __d, __a);
 }

#line 1283
 static _RopeSubstring* _S_new_RopeSubstring(
 _Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,
 size_t __l, allocator_type __a)
 {
 _RopeSubstring* __space = (_Alloc_traits<_RopeSubstring,allocator_type>::create_allocator(__a)) .
allocate(1,(const void*)0);
 return new (__space) _RopeSubstring(__b, __s, __l, __a);
 }

#line 1295
 static
 _RopeLeaf* _S_RopeLeaf_from_unowned_char_ptr(const _CharT *__s,
 size_t _p_size, allocator_type __a)
 {
 if (0 == _p_size) return 0;

#line 1301
 _CharT* __buf = (_Alloc_traits<_CharT,allocator_type>::create_allocator(__a)) .allocate(_S_rounded_up_size(_p_size));

#line 1303
 uninitialized_copy_n(__s, _p_size, __buf);
 _S_cond_store_eos(__buf[_p_size]);

#line 1306
 try {
 return _S_new_RopeLeaf(__buf, _p_size, __a);
 }
 catch(...) { _RopeRep::_S_free_string(__buf, _p_size, __a); throw; }

#line 1314
 }

#line 1323
 static _RopeRep*
 _S_tree_concat(_RopeRep* __left, _RopeRep* __right);

#line 1327
 static _RopeLeaf*
 _S_leaf_concat_char_iter(_RopeLeaf* __r,
 const _CharT* __iter, size_t __slen);

#line 1334
 static _RopeLeaf* _S_destr_leaf_concat_char_iter
 (_RopeLeaf* __r, const _CharT* __iter, size_t __slen);

#line 1343
 friend struct _Rope_Concat_fn<_CharT,_Alloc>;
 typedef _Rope_Concat_fn<_CharT,_Alloc> _Concat_fn;

#line 1346
public:
 static size_t _S_char_ptr_len(const _CharT* __s) {
 const _CharT* __p = __s;

#line 1350
 while (!_S_is0(*__p)) { ++__p; }
 return (__p - __s);
 }

#line 1354
public:
 rope(_RopeRep* __t, const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, __t) { }
private:

#line 1361
 static _CharT* _S_flatten(_RopeRep* __r, _CharT* __buffer);

#line 1365
 static _CharT* _S_flatten(_RopeRep* __r,
 size_t __start, size_t __len,
 _CharT* __buffer);

#line 1370
public:
 static const unsigned long _S_min_len[46];
protected:
 static bool _S_is_balanced(_RopeRep* __r)
 { return (__r->_M_size._M_data >= _S_min_len[__r->_M_depth]); }

#line 1376
 static bool _S_is_almost_balanced(_RopeRep* __r)
 { return (__r->_M_depth == 0 ||
 __r->_M_size._M_data >= _S_min_len[__r->_M_depth - 1]); }

#line 1380
 static bool _S_is_roughly_balanced(_RopeRep* __r)
 { return (__r->_M_depth <= 1 ||
 __r->_M_size._M_data >= _S_min_len[__r->_M_depth - 2]); }

#line 1385
 static _RopeRep* _S_concat_and_set_balanced(_RopeRep* __left,
 _RopeRep* __right)
 {
 _RopeRep* __result = _S_concat_rep(__left, __right);
 if (_S_is_balanced(__result)) __result->_M_is_balanced = true;
 return __result;
 }

#line 1398
 static _RopeRep* _S_balance(_RopeRep* __r);

#line 1402
 static void _S_add_to_forest(_RopeRep*__r, _RopeRep** __forest);

#line 1405
 static void _S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest);

#line 1408
 static void _S_dump(_RopeRep* __r, int __indent = 0);

#line 1411
 static int _S_compare(const _RopeRep* __x, const _RopeRep* __y);

#line 1413
public:
 bool empty() const { return 0 == _M_tree_ptr._M_data; }

#line 1419
 int compare(const _Self& __y) const {
 return _S_compare(_M_tree_ptr._M_data, __y._M_tree_ptr._M_data);
 }

#line 1423
 rope(const _CharT* __s, const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, _S_RopeLeaf_from_unowned_char_ptr(__s, _S_char_ptr_len(__s), __a) )
 { }

#line 1427
 rope(const _CharT* __s, size_t __len,
 const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, ( _S_RopeLeaf_from_unowned_char_ptr(__s, __len, __a) ))
 { }

#line 1435
 rope(const _CharT *__s, const _CharT *__e,
 const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, _S_RopeLeaf_from_unowned_char_ptr(__s, __e - __s, __a) )
 { }

#line 1440
 rope(const const_iterator& __s, const const_iterator& __e,
 const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, _S_substring(__s._M_root, __s._M_current_pos,
 __e._M_current_pos))
 { }

#line 1446
 rope(const iterator& __s, const iterator& __e,
 const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, _S_substring(__s._M_root, __s._M_current_pos,
 __e._M_current_pos))
 { }

#line 1452
 rope(_CharT __c, const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, (_RopeRep*)0)
 {
 _CharT* __buf = _M_tree_ptr.allocate(_S_rounded_up_size(1));

#line 1457
 _Construct(__buf, __c);
 try {
 _M_tree_ptr._M_data = _S_new_RopeLeaf(__buf, 1, __a);
 }
 catch(...) { _RopeRep::_S_free_string(__buf, 1, __a); throw; }
 }

#line 1464
 rope(size_t __n, _CharT __c,
 const allocator_type& __a = allocator_type()):
 _M_tree_ptr(__a, (_RopeRep*)0) {
 rope<_CharT,_Alloc> __result;

#line 1469
 _RopeRep* __remainder;
 rope<_CharT,_Alloc> __remainder_rope;

#line 1473
 typedef _Rope_Concat_fn<_CharT,_Alloc> _Concat_fn;

#line 1475
 if (0 == __n)
 return;

#line 1478
 size_t __exponent = __n / size_t(32) ;
 size_t __rest = __n % size_t(32) ;
 if (0 == __rest) {
 __remainder = 0;
 } else {
 _CharT* __rest_buffer = _M_tree_ptr.allocate(_S_rounded_up_size(__rest));
 uninitialized_fill_n(__rest_buffer, __rest, __c);
 _S_cond_store_eos(__rest_buffer[__rest]);
 try {
 __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a);
 }
 catch(...) { _RopeRep::_S_free_string(__rest_buffer, __rest, __a); throw; }
 }
 __remainder_rope._M_tree_ptr._M_data = __remainder;
 if (__exponent != 0) {
 _CharT* __base_buffer =
 _M_tree_ptr.allocate(_S_rounded_up_size( size_t(32) ));
 _RopeLeaf* __base_leaf;
 rope<_CharT,_Alloc> __base_rope;
 uninitialized_fill_n(__base_buffer, size_t(32) , __c);
 _S_cond_store_eos(__base_buffer[ size_t(32) ]);
 try {
 __base_leaf = _S_new_RopeLeaf(__base_buffer,
 size_t(32) , __a);
 }
 catch(...) { _RopeRep::_S_free_string(__base_buffer, size_t(32), __a); throw; }
 __base_rope
._M_tree_ptr._M_data = __base_leaf;
 if (1 == __exponent) {
 __result = __base_rope;

#line 1511


#line 1512
 } else {
 __result = power(__base_rope, __exponent, _Concat_fn());
 }
 if (0 != __remainder) {
 __result += __remainder_rope;
 }
 } else {
 __result = __remainder_rope;
 }
 _M_tree_ptr._M_data = __result._M_tree_ptr._M_data;
 _M_tree_ptr._M_data->_M_ref_nonnil();

#line 1524
 }

#line 1526
 rope(const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, (_RopeRep*)0) {}

#line 1530
 rope(char_producer<_CharT> *__fn, size_t __len, bool __delete_fn,
 const allocator_type& __a = allocator_type())
 : _M_tree_ptr(__a, (_RopeRep*)0)
 {
 _M_tree_ptr._M_data = (0 == __len) ?
 0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);
 }

#line 1538
 rope(const _Self& __x)
 : _M_tree_ptr(__x.get_allocator(), __x._M_tree_ptr._M_data)
 {
 _S_ref(_M_tree_ptr._M_data);
 }

#line 1544
 ~rope()
 {
 _S_unref(_M_tree_ptr._M_data);
 }

#line 1549
 _Self& operator=(const _Self& __x)
 {
 _RopeRep* __old = _M_tree_ptr._M_data;

#line 1553
 _M_tree_ptr._M_data = __x._M_tree_ptr._M_data;
 _S_ref(_M_tree_ptr._M_data);
 _S_unref(__old);
 return(*this);
 }
 void clear()
 {
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = 0;
 }
 void push_back(_CharT __x)
 {
 _RopeRep* __old = _M_tree_ptr._M_data;
 _M_tree_ptr._M_data = _S_destr_concat_char_iter(_M_tree_ptr._M_data, &__x, 1);
 _S_unref(__old);
 }

#line 1570
 void pop_back()
 {
 _RopeRep* __old = _M_tree_ptr._M_data;
 _M_tree_ptr._M_data =
 _S_substring(_M_tree_ptr._M_data, 0, _M_tree_ptr._M_data->_M_size._M_data - 1);
 _S_unref(__old);
 }

#line 1578
 _CharT back() const
 {
 return _S_fetch(_M_tree_ptr._M_data, _M_tree_ptr._M_data->_M_size._M_data - 1);
 }

#line 1583
 void push_front(_CharT __x)
 {
 _RopeRep* __old = _M_tree_ptr._M_data;
 _RopeRep* __left =
 _S_RopeLeaf_from_unowned_char_ptr(&__x, 1, get_allocator()) ;
 try {
 _M_tree_ptr._M_data = _S_concat_rep(__left, _M_tree_ptr._M_data);
 _S_unref(__old);
 _S_unref(__left);
 }
 catch(...) { _S_unref(__left); throw; }
 }

#line 1596
 void pop_front()
 {
 _RopeRep* __old = _M_tree_ptr._M_data;
 _M_tree_ptr._M_data = _S_substring(_M_tree_ptr._M_data, 1, _M_tree_ptr._M_data->_M_size._M_data);
 _S_unref(__old);
 }

#line 1603
 _CharT front() const
 {
 return _S_fetch(_M_tree_ptr._M_data, 0);
 }

#line 1608
 void balance()
 {
 _RopeRep* __old = _M_tree_ptr._M_data;
 _M_tree_ptr._M_data = _S_balance(_M_tree_ptr._M_data);
 _S_unref(__old);
 }

#line 1615
 void copy(_CharT* __buffer) const {
 _Destroy(__buffer, __buffer + size());
 _S_flatten(_M_tree_ptr._M_data, __buffer);
 }

#line 1625
 size_type copy(size_type __pos, size_type __n, _CharT* __buffer) const
 {
 size_t _p_size = size();
 size_t __len = (__pos + __n > _p_size? _p_size - __pos : __n);

#line 1630
 _Destroy(__buffer, __buffer + __len);
 _S_flatten(_M_tree_ptr._M_data, __pos, __len, __buffer);
 return __len;
 }

#line 1637
 void dump() {
 _S_dump(_M_tree_ptr._M_data);
 }

#line 1643
 const _CharT* c_str() const;

#line 1647
 const _CharT* replace_with_c_str();

#line 1652
 void delete_c_str () {
 if (0 == _M_tree_ptr._M_data) return;
 if (_RopeRep::_S_leaf == _M_tree_ptr._M_data->_M_tag &&
 ((_RopeLeaf*)_M_tree_ptr._M_data)->_M_data ==
 _M_tree_ptr._M_data->_M_c_string) {

#line 1658
 return;
 }

#line 1661
 _M_tree_ptr._M_data->_M_free_c_string();

#line 1663
 _M_tree_ptr._M_data->_M_c_string = 0;
 }

#line 1666
 _CharT operator[] (size_type __pos) const {
 return _S_fetch(_M_tree_ptr._M_data, __pos);
 }

#line 1670
 _CharT at(size_type __pos) const {

#line 1672
 return (*this)[__pos];
 }

#line 1675
 const_iterator begin() const {
 return(const_iterator(_M_tree_ptr._M_data, 0));
 }

#line 1680
 const_iterator const_begin() const {
 return(const_iterator(_M_tree_ptr._M_data, 0));
 }

#line 1684
 const_iterator end() const {
 return(const_iterator(_M_tree_ptr._M_data, size()));
 }

#line 1688
 const_iterator const_end() const {
 return(const_iterator(_M_tree_ptr._M_data, size()));
 }

#line 1692
 size_type size() const {
 return(0 == _M_tree_ptr._M_data? 0 : _M_tree_ptr._M_data->_M_size._M_data);
 }

#line 1696
 size_type length() const {
 return size();
 }

#line 1700
 size_type max_size() const {
 return _S_min_len[ 45 -1] - 1;

#line 1705
 }

#line 1707
 const_reverse_iterator rbegin() const {
 return const_reverse_iterator(end());
 }

#line 1711
 const_reverse_iterator const_rbegin() const {
 return const_reverse_iterator(end());
 }

#line 1715
 const_reverse_iterator rend() const {
 return const_reverse_iterator(begin());
 }

#line 1719
 const_reverse_iterator const_rend() const {
 return const_reverse_iterator(begin());
 }

#line 1728
 _Self& append(const _CharT* __iter, size_t __n) {
 _RopeRep* __result =
 _S_destr_concat_char_iter(_M_tree_ptr._M_data, __iter, __n);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 return *this;
 }

#line 1736
 _Self& append(const _CharT* __c_string) {
 size_t __len = _S_char_ptr_len(__c_string);
 append(__c_string, __len);
 return(*this);
 }

#line 1742
 _Self& append(const _CharT* __s, const _CharT* __e) {
 _RopeRep* __result =
 _S_destr_concat_char_iter(_M_tree_ptr._M_data, __s, __e - __s);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 return *this;
 }

#line 1750
 _Self& append(const_iterator __s, const_iterator __e) {

#line 1753
 _Self_destruct_ptr __appendee(_S_substring(
 __s._M_root, __s._M_current_pos, __e._M_current_pos));
 _RopeRep* __result =
 _S_concat_rep(_M_tree_ptr._M_data, (_RopeRep*)__appendee);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 return *this;
 }

#line 1762
 _Self& append(_CharT __c) {
 _RopeRep* __result =
 _S_destr_concat_char_iter(_M_tree_ptr._M_data, &__c, 1);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 return *this;
 }

#line 1770
 _Self& append() { return append(_CharT()); }

#line 1772
 _Self& append(const _Self& __y) {

#line 1774
 _RopeRep* __result = _S_concat_rep(_M_tree_ptr._M_data, __y._M_tree_ptr._M_data);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 return *this;
 }

#line 1780
 _Self& append(size_t __n, _CharT __c) {
 rope<_CharT,_Alloc> __last(__n, __c);
 return append(__last);
 }

#line 1785
 void swap(_Self& __b) {

#line 1787
 _RopeRep* __tmp = _M_tree_ptr._M_data;
 _M_tree_ptr._M_data = __b._M_tree_ptr._M_data;
 __b._M_tree_ptr._M_data = __tmp;
 }

#line 1793
protected:

#line 1795
 static _RopeRep* replace(_RopeRep* __old, size_t __pos1,
 size_t __pos2, _RopeRep* __r) {
 if (0 == __old) { _S_ref(__r); return __r; }
 _Self_destruct_ptr __left(
 _S_substring(__old, 0, __pos1));
 _Self_destruct_ptr __right(
 _S_substring(__old, __pos2, __old->_M_size._M_data));

#line 1803
 _RopeRep* __result;

#line 1805
 if (0 == __r) {
 __result = _S_concat_rep(__left, __right);
 } else {

#line 1809
 _Self_destruct_ptr __left_result(_S_concat_rep(__left, __r));
 __result = _S_concat_rep(__left_result, __right);
 }
 return __result;

#line 1814
 }

#line 1816
public:
 void insert(size_t __p, const _Self& __r) {
 _RopeRep* __result =
 replace(_M_tree_ptr._M_data, __p, __p, __r._M_tree_ptr._M_data);

#line 1821
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 }

#line 1825
 void insert(size_t __p, size_t __n, _CharT __c) {
 rope<_CharT,_Alloc> __r(__n,__c);
 insert(__p, __r);
 }

#line 1830
 void insert(size_t __p, const _CharT* __i, size_t __n) {
 _Self_destruct_ptr __left(_S_substring(_M_tree_ptr._M_data, 0, __p));
 _Self_destruct_ptr __right(_S_substring(_M_tree_ptr._M_data, __p, size()));
 _Self_destruct_ptr __left_result(
 _S_concat_char_iter(__left, __i, __n));

#line 1838
 _RopeRep* __result = _S_concat_rep(__left_result, __right);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 }

#line 1843
 void insert(size_t __p, const _CharT* __c_string) {
 insert(__p, __c_string, _S_char_ptr_len(__c_string));
 }

#line 1847
 void insert(size_t __p, _CharT __c) {
 insert(__p, &__c, 1);
 }

#line 1851
 void insert(size_t __p) {
 _CharT __c = _CharT();
 insert(__p, &__c, 1);
 }

#line 1856
 void insert(size_t __p, const _CharT* __i, const _CharT* __j) {
 _Self __r(__i, __j);
 insert(__p, __r);
 }

#line 1861
 void insert(size_t __p, const const_iterator& __i,
 const const_iterator& __j) {
 _Self __r(__i, __j);
 insert(__p, __r);
 }

#line 1867
 void insert(size_t __p, const iterator& __i,
 const iterator& __j) {
 _Self __r(__i, __j);
 insert(__p, __r);
 }

#line 1875
 void replace(size_t __p, size_t __n, const _Self& __r) {
 _RopeRep* __result =
 replace(_M_tree_ptr._M_data, __p, __p + __n, __r._M_tree_ptr._M_data);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 }

#line 1882
 void replace(size_t __p, size_t __n,
 const _CharT* __i, size_t __i_len) {
 _Self __r(__i, __i_len);
 replace(__p, __n, __r);
 }

#line 1888
 void replace(size_t __p, size_t __n, _CharT __c) {
 _Self __r(__c);
 replace(__p, __n, __r);
 }

#line 1893
 void replace(size_t __p, size_t __n, const _CharT* __c_string) {
 _Self __r(__c_string);
 replace(__p, __n, __r);
 }

#line 1898
 void replace(size_t __p, size_t __n,
 const _CharT* __i, const _CharT* __j) {
 _Self __r(__i, __j);
 replace(__p, __n, __r);
 }

#line 1904
 void replace(size_t __p, size_t __n,
 const const_iterator& __i, const const_iterator& __j) {
 _Self __r(__i, __j);
 replace(__p, __n, __r);
 }

#line 1910
 void replace(size_t __p, size_t __n,
 const iterator& __i, const iterator& __j) {
 _Self __r(__i, __j);
 replace(__p, __n, __r);
 }

#line 1917
 void replace(size_t __p, _CharT __c) {
 iterator __i(this, __p);
 *__i = __c;
 }

#line 1922
 void replace(size_t __p, const _Self& __r) {
 replace(__p, 1, __r);
 }

#line 1926
 void replace(size_t __p, const _CharT* __i, size_t __i_len) {
 replace(__p, 1, __i, __i_len);
 }

#line 1930
 void replace(size_t __p, const _CharT* __c_string) {
 replace(__p, 1, __c_string);
 }

#line 1934
 void replace(size_t __p, const _CharT* __i, const _CharT* __j) {
 replace(__p, 1, __i, __j);
 }

#line 1938
 void replace(size_t __p, const const_iterator& __i,
 const const_iterator& __j) {
 replace(__p, 1, __i, __j);
 }

#line 1943
 void replace(size_t __p, const iterator& __i,
 const iterator& __j) {
 replace(__p, 1, __i, __j);
 }

#line 1949
 void erase(size_t __p, size_t __n) {
 _RopeRep* __result = replace(_M_tree_ptr._M_data, __p, __p + __n, 0);
 _S_unref(_M_tree_ptr._M_data);
 _M_tree_ptr._M_data = __result;
 }

#line 1956
 void erase(size_t __p) {
 erase(__p, __p + 1);
 }

#line 1961
 iterator insert(const iterator& __p, const _Self& __r)
 { insert(__p.index(), __r); return __p; }
 iterator insert(const iterator& __p, size_t __n, _CharT __c)
 { insert(__p.index(), __n, __c); return __p; }
 iterator insert(const iterator& __p, _CharT __c)
 { insert(__p.index(), __c); return __p; }
 iterator insert(const iterator& __p )
 { insert(__p.index()); return __p; }
 iterator insert(const iterator& __p, const _CharT* c_string)
 { insert(__p.index(), c_string); return __p; }
 iterator insert(const iterator& __p, const _CharT* __i, size_t __n)
 { insert(__p.index(), __i, __n); return __p; }
 iterator insert(const iterator& __p, const _CharT* __i,
 const _CharT* __j)
 { insert(__p.index(), __i, __j); return __p; }
 iterator insert(const iterator& __p,
 const const_iterator& __i, const const_iterator& __j)
 { insert(__p.index(), __i, __j); return __p; }
 iterator insert(const iterator& __p,
 const iterator& __i, const iterator& __j)
 { insert(__p.index(), __i, __j); return __p; }

#line 1984
 void replace(const iterator& __p, const iterator& __q,
 const _Self& __r)
 { replace(__p.index(), __q.index() - __p.index(), __r); }
 void replace(const iterator& __p, const iterator& __q, _CharT __c)
 { replace(__p.index(), __q.index() - __p.index(), __c); }
 void replace(const iterator& __p, const iterator& __q,
 const _CharT* __c_string)
 { replace(__p.index(), __q.index() - __p.index(), __c_string); }
 void replace(const iterator& __p, const iterator& __q,
 const _CharT* __i, size_t __n)
 { replace(__p.index(), __q.index() - __p.index(), __i, __n); }
 void replace(const iterator& __p, const iterator& __q,
 const _CharT* __i, const _CharT* __j)
 { replace(__p.index(), __q.index() - __p.index(), __i, __j); }
 void replace(const iterator& __p, const iterator& __q,
 const const_iterator& __i, const const_iterator& __j)
 { replace(__p.index(), __q.index() - __p.index(), __i, __j); }
 void replace(const iterator& __p, const iterator& __q,
 const iterator& __i, const iterator& __j)
 { replace(__p.index(), __q.index() - __p.index(), __i, __j); }

#line 2006
 void replace(const iterator& __p, const _Self& __r)
 { replace(__p.index(), __r); }
 void replace(const iterator& __p, _CharT __c)
 { replace(__p.index(), __c); }
 void replace(const iterator& __p, const _CharT* __c_string)
 { replace(__p.index(), __c_string); }
 void replace(const iterator& __p, const _CharT* __i, size_t __n)
 { replace(__p.index(), __i, __n); }
 void replace(const iterator& __p, const _CharT* __i, const _CharT* __j)
 { replace(__p.index(), __i, __j); }
 void replace(const iterator& __p, const_iterator __i,
 const_iterator __j)
 { replace(__p.index(), __i, __j); }
 void replace(const iterator& __p, iterator __i, iterator __j)
 { replace(__p.index(), __i, __j); }

#line 2023
 iterator erase(const iterator& __p, const iterator& __q) {
 size_t __p_index = __p.index();
 erase(__p_index, __q.index() - __p_index);
 return iterator(this, __p_index);
 }
 iterator erase(const iterator& __p) {
 size_t __p_index = __p.index();
 erase(__p_index, 1);
 return iterator(this, __p_index);
 }

#line 2034
 _Self substr(size_t __start, size_t __len = 1) const {
 return rope<_CharT,_Alloc>(
 _S_substring(_M_tree_ptr._M_data, __start, __start + __len));
 }

#line 2039
 _Self substr(iterator __start, iterator __end) const {
 return rope<_CharT,_Alloc>(
 _S_substring(_M_tree_ptr._M_data, __start.index(), __end.index()));
 }

#line 2044
 _Self substr(iterator __start) const {
 size_t __pos = __start.index();
 return rope<_CharT,_Alloc>(
 _S_substring(_M_tree_ptr._M_data, __pos, __pos + 1));
 }

#line 2050
 _Self substr(const_iterator __start, const_iterator __end) const {

#line 2053
 return rope<_CharT,_Alloc>(
 _S_substring(_M_tree_ptr._M_data, __start.index(), __end.index()));
 }

#line 2057
 rope<_CharT,_Alloc> substr(const_iterator __start) {
 size_t __pos = __start.index();
 return rope<_CharT,_Alloc>(
 _S_substring(_M_tree_ptr._M_data, __pos, __pos + 1));
 }

#line 2063
 enum { npos = -1 };

#line 2067
 size_type find(_CharT __c, size_type __pos = 0) const;
 size_type find(const _CharT* __s, size_type __pos = 0) const {
 size_type __result_pos;
 const_iterator __result = search(const_begin() + (ptrdiff_t)__pos, const_end(),
 __s, __s + _S_char_ptr_len(__s));
 __result_pos = __result.index();

#line 2074
 if (__result_pos == size()) __result_pos = npos;

#line 2076
 return __result_pos;
 }

#line 2079
 iterator mutable_begin() {
 return(iterator(this, 0));
 }

#line 2083
 iterator mutable_end() {
 return(iterator(this, size()));
 }

#line 2087
 reverse_iterator mutable_rbegin() {
 return reverse_iterator(mutable_end());
 }

#line 2091
 reverse_iterator mutable_rend() {
 return reverse_iterator(mutable_begin());
 }

#line 2095
 reference mutable_reference_at(size_type __pos) {
 return reference(this, __pos);
 }

#line 2134
 const_iterator end() { return const_end(); }

#line 2136
 const_iterator begin() { return const_begin(); }

#line 2138
 const_reverse_iterator rend() { return const_rend(); }

#line 2140
 const_reverse_iterator rbegin() { return const_rbegin(); }

#line 2144
 typedef typename _Alloc_traits<_CharT,_Alloc>::allocator_type _DataAllocator; typedef _Rope_RopeConcatenation<_CharT,_Alloc> __C; typedef typename _Alloc_traits<__C,_Alloc>::allocator_type _CAllocator; typedef _Rope_RopeLeaf<_CharT,_Alloc> __L; typedef typename _Alloc_traits<__L,_Alloc>::allocator_type _LAllocator; typedef _Rope_RopeFunction<_CharT,_Alloc> __F; typedef typename _Alloc_traits<__F,_Alloc>::allocator_type _FAllocator; typedef _Rope_RopeSubstring<_CharT,_Alloc> __S; typedef typename _Alloc_traits<__S,_Alloc>::allocator_type _SAllocator;
 };

#line 2150
template <class _CharT, class _Alloc>
inline _CharT
_Rope_const_iterator< _CharT, _Alloc>::operator[](size_t __n)
{
 return rope<_CharT,_Alloc>::_S_fetch(this->_M_root, this->_M_current_pos + __n);
}

#line 2157
template <class _CharT, class _Alloc>
inline bool operator== (const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return (__x._M_current_pos == __y._M_current_pos &&
 __x._M_root == __y._M_root);
}

#line 2164
template <class _CharT, class _Alloc>
inline bool operator< (const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return (__x._M_current_pos < __y._M_current_pos);
}

#line 2172
template <class _CharT, class _Alloc>
inline bool operator!= (const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return !(__x == __y);
}

#line 2178
template <class _CharT, class _Alloc>
inline bool operator> (const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return __y < __x;
}

#line 2184
template <class _CharT, class _Alloc>
inline bool operator<= (const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return !(__y < __x);
}

#line 2190
template <class _CharT, class _Alloc>
inline bool operator>= (const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return !(__x < __y);
}

#line 2198
template <class _CharT, class _Alloc>
inline ptrdiff_t operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x,
 const _Rope_const_iterator<_CharT,_Alloc>& __y) {
 return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;
}

#line 2205
template <class _CharT, class _Alloc>
inline _Rope_const_iterator<_CharT,_Alloc>
operator-(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {
 return _Rope_const_iterator<_CharT,_Alloc>(
 __x._M_root, __x._M_current_pos - __n);
}

#line 2213
template <class _CharT, class _Alloc>
inline _Rope_const_iterator<_CharT,_Alloc>
operator+(const _Rope_const_iterator<_CharT,_Alloc>& __x, ptrdiff_t __n) {
 return _Rope_const_iterator<_CharT,_Alloc>(
 __x._M_root, __x._M_current_pos + __n);
}

#line 2220
template <class _CharT, class _Alloc>
inline _Rope_const_iterator<_CharT,_Alloc>
operator+(ptrdiff_t __n, const _Rope_const_iterator<_CharT,_Alloc>& __x) {
 return _Rope_const_iterator<_CharT,_Alloc>(
 __x._M_root, __x._M_current_pos + __n);
}

#line 2227
template <class _CharT, class _Alloc>
inline bool operator== (const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return (__x._M_current_pos == __y._M_current_pos &&
 __x._M_root_rope == __y._M_root_rope);
}

#line 2234
template <class _CharT, class _Alloc>
inline bool operator< (const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return (__x._M_current_pos < __y._M_current_pos);
}

#line 2242
template <class _CharT, class _Alloc>
inline bool operator!= (const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return !(__x == __y);
}

#line 2248
template <class _CharT, class _Alloc>
inline bool operator> (const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return __y < __x;
}

#line 2254
template <class _CharT, class _Alloc>
inline bool operator<= (const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return !(__y < __x);
}

#line 2260
template <class _CharT, class _Alloc>
inline bool operator>= (const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return !(__x < __y);
}

#line 2268
template <class _CharT, class _Alloc>
inline ptrdiff_t operator-(const _Rope_iterator<_CharT,_Alloc>& __x,
 const _Rope_iterator<_CharT,_Alloc>& __y) {
 return (ptrdiff_t)__x._M_current_pos - (ptrdiff_t)__y._M_current_pos;
}

#line 2275
template <class _CharT, class _Alloc>
inline _Rope_iterator<_CharT,_Alloc>
operator-(const _Rope_iterator<_CharT,_Alloc>& __x,
 ptrdiff_t __n) {
 return _Rope_iterator<_CharT,_Alloc>(
 __x._M_root_rope, __x._M_current_pos - __n);
}

#line 2284
template <class _CharT, class _Alloc>
inline _Rope_iterator<_CharT,_Alloc>
operator+(const _Rope_iterator<_CharT,_Alloc>& __x,
 ptrdiff_t __n) {
 return _Rope_iterator<_CharT,_Alloc>(
 __x._M_root_rope, __x._M_current_pos + __n);
}

#line 2292
template <class _CharT, class _Alloc>
inline _Rope_iterator<_CharT,_Alloc>
operator+(ptrdiff_t __n, const _Rope_iterator<_CharT,_Alloc>& __x) {
 return _Rope_iterator<_CharT,_Alloc>(
 __x._M_root_rope, __x._M_current_pos + __n);
}

#line 2299
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>
operator+ (const rope<_CharT,_Alloc>& __left,
 const rope<_CharT,_Alloc>& __right)
{

#line 2306
 return rope<_CharT,_Alloc>(rope<_CharT,_Alloc>::_S_concat_rep(__left._M_tree_ptr._M_data, __right._M_tree_ptr._M_data));

#line 2309
}

#line 2311
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>&
operator+= (rope<_CharT,_Alloc>& __left,
 const rope<_CharT,_Alloc>& __right)
{
 __left.append(__right);
 return __left;
}

#line 2321
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>
operator+ (const rope<_CharT,_Alloc>& __left,
 const _CharT* __right) {
 size_t __rlen = rope<_CharT,_Alloc>::_S_char_ptr_len(__right);
 return rope<_CharT,_Alloc>(
 rope<_CharT,_Alloc>::_S_concat_char_iter(
 __left._M_tree_ptr._M_data, __right, __rlen));
}

#line 2332
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>&
operator+= (rope<_CharT,_Alloc>& __left,
 const _CharT* __right) {
 __left.append(__right);
 return __left;
}

#line 2341
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>
operator+ (const rope<_CharT,_Alloc>& __left, _CharT __right) {
 return rope<_CharT,_Alloc>(
 rope<_CharT,_Alloc>::_S_concat_char_iter(
 __left._M_tree_ptr._M_data, &__right, 1));
}

#line 2350
template <class _CharT, class _Alloc>
inline
rope<_CharT,_Alloc>&
operator+= (rope<_CharT,_Alloc>& __left, _CharT __right) {
 __left.append(__right);
 return __left;
}

#line 2358
template <class _CharT, class _Alloc>
inline bool
operator< (const rope<_CharT,_Alloc>& __left,
 const rope<_CharT,_Alloc>& __right) {
 return __left.compare(__right) < 0;
}

#line 2365
template <class _CharT, class _Alloc>
inline bool
operator== (const rope<_CharT,_Alloc>& __left,
 const rope<_CharT,_Alloc>& __right) {
 return __left.compare(__right) == 0;
}

#line 2374
template <class _CharT, class _Alloc>
inline bool
operator!= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
 return !(__x == __y);
}

#line 2380
template <class _CharT, class _Alloc>
inline bool
operator> (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
 return __y < __x;
}

#line 2386
template <class _CharT, class _Alloc>
inline bool
operator<= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
 return !(__y < __x);
}

#line 2392
template <class _CharT, class _Alloc>
inline bool
operator>= (const rope<_CharT,_Alloc>& __x, const rope<_CharT,_Alloc>& __y) {
 return !(__x < __y);
}

#line 2398
template <class _CharT, class _Alloc>
inline bool operator!= (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,
 const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {
 return !(__x == __y);
}

#line 2406
template <class _CharT, class _Alloc>
inline bool operator== (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,
 const _Rope_char_ptr_proxy<_CharT,_Alloc>& __y) {
 return (__x._M_pos == __y._M_pos && __x._M_root == __y._M_root);
}

#line 2413
template<class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>& operator<< (
 basic_ostream<_CharT, _Traits>& __o,
 const rope<_CharT, _Alloc>& __r);

#line 2422
typedef rope<char, allocator< char > > crope;

#line 2424
typedef rope<wchar_t, allocator< wchar_t > > wrope;

#line 2427
inline crope::reference __mutable_reference_at(crope& __c, size_t __i)
{
 return __c.mutable_reference_at(__i);
}

#line 2433
inline wrope::reference __mutable_reference_at(wrope& __c, size_t __i)
{
 return __c.mutable_reference_at(__i);
}

#line 2441
template <class _CharT, class _Alloc>
inline void swap(rope<_CharT,_Alloc>& __x, rope<_CharT,_Alloc>& __y) {
 __x.swap(__y);
}

#line 2456
 template<> struct hash<crope>
{
 size_t operator()(const crope& __str) const
 {
 size_t _p_size = __str.size();

#line 2462
 if (0 == _p_size) return 0;
 return 13*__str[0] + 5*__str[_p_size - 1] + _p_size;
 }
};

#line 2468
 template<> struct hash<wrope>
{
 size_t operator()(const wrope& __str) const
 {
 size_t _p_size = __str.size();

#line 2474
 if (0 == _p_size) return 0;
 return 13*__str[0] + 5*__str[_p_size - 1] + _p_size;
 }
};

#line 2482
template<class _CharT,class _Alloc>
void
_Rope_rotate(_Rope_iterator<_CharT,_Alloc> __first,
 _Rope_iterator<_CharT,_Alloc> __middle,
 _Rope_iterator<_CharT,_Alloc> __last);

#line 2490
inline void rotate(_Rope_iterator<char, allocator< char > > __first,
 _Rope_iterator<char, allocator< char > > __middle,
 _Rope_iterator<char, allocator< char > > __last) {
 _Rope_rotate(__first, __middle, __last);
}

#line 2499
template <class _CharT, class _Alloc>
inline _Rope_char_ref_proxy<_CharT, _Alloc>::operator _CharT () const
{
 if (_M_current_valid) {
 return _M_current;
 } else {
 return _My_rope::_S_fetch(_M_root->_M_tree_ptr._M_data, _M_pos);
 }
}
 }
#line 1 "../../stlport/stl/_rope.c"


#line 44
 namespace _STL {

#line 52
 template<class _CharT, class _Alloc>
_Rope_iterator<_CharT, _Alloc>::_Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)
 : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr._M_data, __pos),
 _M_root_rope(__r) { _RopeRep::_S_ref(this->_M_root); }

#line 57
template<class _CharT, class _Alloc>
_Rope_iterator<_CharT, _Alloc>::_Rope_iterator(rope<_CharT,_Alloc>& __r, size_t __pos):
 _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr._M_data, __pos),
 _M_root_rope(&__r) {
 _RopeRep::_S_ref(this->_M_root); if (!(__r.empty()))_S_setcache(*this);
}

#line 64
template<class _CharT, class _Alloc>
void
_Rope_RopeRep<_CharT, _Alloc>::_M_free_c_string()
{
 _CharT* __cstr = _M_c_string;
 if (0 != __cstr) {
 size_t _p_size = _M_size._M_data + 1;
 _Destroy(__cstr, __cstr + _p_size);
 _M_size.deallocate(__cstr, _p_size);
 }
}

#line 81
template <class _CharT, class _Alloc>
void _Rope_iterator_base<_CharT,_Alloc>::_S_setbuf(
 _Rope_iterator_base<_CharT,_Alloc>& __x)
{
 const _RopeRep* __leaf = __x._M_path_end[__x._M_leaf_index];
 size_t __leaf_pos = __x._M_leaf_pos;
 size_t __pos = __x._M_current_pos;

#line 89
 switch(__leaf->_M_tag) {
 case _RopeRep::_S_leaf:
 __x._M_buf_start =
 ((_Rope_RopeLeaf<_CharT,_Alloc>*)__leaf)->_M_data;
 __x._M_buf_ptr = __x._M_buf_start + (__pos - __leaf_pos);
 __x._M_buf_end = __x._M_buf_start + __leaf->_M_size._M_data;
 break;
 case _RopeRep::_S_function:
 case _RopeRep::_S_substringfn:
 {
 size_t __len = _S_iterator_buf_len;
 size_t __buf_start_pos = __leaf_pos;
 size_t __leaf_end = __leaf_pos + __leaf->_M_size._M_data;
 char_producer<_CharT>* __fn =
 ((_Rope_RopeFunction<_CharT,_Alloc>*)__leaf)->_M_fn;

#line 105
 if (__buf_start_pos + __len <= __pos) {
 __buf_start_pos = __pos - __len/4;
 if (__buf_start_pos + __len > __leaf_end) {
 __buf_start_pos = __leaf_end - __len;
 }
 }
 if (__buf_start_pos + __len > __leaf_end) {
 __len = __leaf_end - __buf_start_pos;
 }
 (*__fn)(__buf_start_pos - __leaf_pos, __len, __x._M_tmp_buf);
 __x._M_buf_ptr = __x._M_tmp_buf + (__pos - __buf_start_pos);
 __x._M_buf_start = __x._M_tmp_buf;
 __x._M_buf_end = __x._M_tmp_buf + __len;
 }
 break;
 default:

#line 122
 ;
 }
}

#line 128
template <class _CharT, class _Alloc>
void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache
(_Rope_iterator_base<_CharT,_Alloc>& __x)
{
 const _RopeRep* __path[_RopeRep::_S_max_rope_depth+1];
 const _RopeRep* __curr_rope;
 int __curr_depth = -1;
 size_t __curr_start_pos = 0;
 size_t __pos = __x._M_current_pos;
 unsigned char __dirns = 0;

#line 140
 if (__pos >= __x._M_root->_M_size._M_data) {
 __x._M_buf_ptr = 0;
 return;
 }
 __curr_rope = __x._M_root;
 if (0 != __curr_rope->_M_c_string) {

#line 147
 __x._M_buf_start = __curr_rope->_M_c_string;
 __x._M_buf_end = __curr_rope->_M_c_string + __curr_rope->_M_size._M_data;
 __x._M_buf_ptr = __curr_rope->_M_c_string + __pos;
 __x._M_path_end[0] = __curr_rope;
 __x._M_leaf_index = 0;
 __x._M_leaf_pos = 0;
 return;
 }
 for(;;) {
 ++__curr_depth;

#line 158
 __path[__curr_depth] = __curr_rope;
 switch(__curr_rope->_M_tag) {
 case _RopeRep::_S_leaf:
 case _RopeRep::_S_function:
 case _RopeRep::_S_substringfn:
 __x._M_leaf_pos = __curr_start_pos;
 goto done;
 case _RopeRep::_S_concat:
 {
 _Rope_RopeConcatenation<_CharT,_Alloc>* __c =
 (_Rope_RopeConcatenation<_CharT,_Alloc>*)__curr_rope;
 _RopeRep* __left = __c->_M_left;
 size_t __left_len = __left->_M_size._M_data;

#line 172
 __dirns <<= 1;
 if (__pos >= __curr_start_pos + __left_len) {
 __dirns |= 1;
 __curr_rope = __c->_M_right;
 __curr_start_pos += __left_len;
 } else {
 __curr_rope = __left;
 }
 }
 break;
 }
 }
 done:

#line 186
 {
 int __i = -1;
 int __j = __curr_depth + 1 - _S_path_cache_len;

#line 190
 if (__j < 0) __j = 0;
 while (__j <= __curr_depth) {
 __x._M_path_end[++__i] = __path[__j++];
 }
 __x._M_leaf_index = __i;
 }
 __x._M_path_directions = __dirns;
 _S_setbuf(__x);
}

#line 202
template <class _CharT, class _Alloc>
void _Rope_iterator_base<_CharT,_Alloc>::_S_setcache_for_incr
(_Rope_iterator_base<_CharT,_Alloc>& __x)
{
 int __current_index = __x._M_leaf_index;
 const _RopeRep* __current_node = __x._M_path_end[__current_index];
 size_t __len = __current_node->_M_size._M_data;
 size_t __node_start_pos = __x._M_leaf_pos;
 unsigned char __dirns = __x._M_path_directions;
 _Rope_RopeConcatenation<_CharT,_Alloc>* __c;

#line 214
 if (__x._M_current_pos - __node_start_pos < __len) {

#line 216
 _S_setbuf(__x);
 return;
 }

#line 221
 while (--__current_index >= 0) {
 if (!(__dirns & 1) )
 break;
 __current_node = __x._M_path_end[__current_index];
 __c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;

#line 228
 __node_start_pos -= __c->_M_left->_M_size._M_data;
 __dirns >>= 1;
 }
 if (__current_index < 0) {

#line 233
 _S_setcache(__x);
 return;
 }
 __current_node = __x._M_path_end[__current_index];
 __c = (_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node;

#line 241
 __node_start_pos += __c->_M_left->_M_size._M_data;
 __current_node = __c->_M_right;
 __x._M_path_end[++__current_index] = __current_node;
 __dirns |= 1;
 while (_RopeRep::_S_concat == __current_node->_M_tag) {
 ++__current_index;
 if (_S_path_cache_len == __current_index) {
 int __i;
 for (__i = 0; __i < _S_path_cache_len-1; __i++) {
 __x._M_path_end[__i] = __x._M_path_end[__i+1];
 }
 --__current_index;
 }
 __current_node =
 ((_Rope_RopeConcatenation<_CharT,_Alloc>*)__current_node)->_M_left;
 __x._M_path_end[__current_index] = __current_node;
 __dirns <<= 1;

#line 259
 }
 __x._M_leaf_index = __current_index;
 __x._M_leaf_pos = __node_start_pos;
 __x._M_path_directions = __dirns;
 _S_setbuf(__x);
}

#line 266
template <class _CharT, class _Alloc>
void _Rope_iterator_base<_CharT,_Alloc>::_M_incr(size_t __n) {
 _M_current_pos += __n;
 if (0 != _M_buf_ptr) {
 size_t __chars_left = _M_buf_end - _M_buf_ptr;
 if (__chars_left > __n) {
 _M_buf_ptr += __n;
 } else if (__chars_left == __n) {
 _M_buf_ptr += __n;
 _S_setcache_for_incr(*this);
 } else {
 _M_buf_ptr = 0;
 }
 }
}

#line 282
template <class _CharT, class _Alloc>
void _Rope_iterator_base<_CharT,_Alloc>::_M_decr(size_t __n) {
 if (0 != _M_buf_ptr) {
 size_t __chars_left = _M_buf_ptr - _M_buf_start;
 if (__chars_left >= __n) {
 _M_buf_ptr -= __n;
 } else {
 _M_buf_ptr = 0;
 }
 }
 _M_current_pos -= __n;
}

#line 295
template <class _CharT, class _Alloc>
void _Rope_iterator<_CharT,_Alloc>::_M_check() {
 if (_M_root_rope->_M_tree_ptr._M_data != this->_M_root) {

#line 299
 _RopeRep::_S_unref(this->_M_root);
 this->_M_root = _M_root_rope->_M_tree_ptr._M_data;
 _RopeRep::_S_ref(this->_M_root);
 this->_M_buf_ptr = 0;
 }
}

#line 313
template <class _CharT, class _Alloc>
void _Rope_RopeRep<_CharT,_Alloc>::_M_free_tree()
{
 switch(_M_tag) {
 case _S_leaf:
 {
 typedef _Rope_RopeLeaf<_CharT,_Alloc> _Rope_RopeLeaf_T;
 _Rope_RopeLeaf_T* __l = (_Rope_RopeLeaf_T*)this;
 _Destroy(__l);
 (_Alloc_traits<_Rope_RopeLeaf_T,allocator_type>::create_allocator((const allocator_type&)_M_size)) .deallocate(__l, 1);
 break;
 }
 case _S_concat:
 {
 typedef _Rope_RopeConcatenation<_CharT,_Alloc> _Rope_RopeConcatenation_T;
 _Rope_RopeConcatenation_T* __c = (_Rope_RopeConcatenation_T*)this;
 _Destroy(__c);
 (_Alloc_traits<_Rope_RopeConcatenation_T,allocator_type>::create_allocator((const allocator_type&)_M_size)) .
deallocate(__c, 1);
 break;
 }
 case _S_function:
 {
 typedef _Rope_RopeFunction<_CharT,_Alloc> _Rope_RopeFunctionT;
 _Rope_RopeFunctionT* __f = (_Rope_RopeFunctionT*)this;
 _Destroy(__f);
 (_Alloc_traits<_Rope_RopeFunctionT,allocator_type>::create_allocator((const allocator_type&)_M_size)) .
deallocate(__f, 1);
 break;
 }
 case _S_substringfn:
 {
 typedef _Rope_RopeSubstring<_CharT,_Alloc> _Rope_RopeSubstring_T;
 _Rope_RopeSubstring_T* __ss = (_Rope_RopeSubstring_T*)this;
 _Destroy(__ss);
 (_Alloc_traits<_Rope_RopeSubstring_T,allocator_type>::create_allocator((const allocator_type&)_M_size)) .
deallocate(__ss, 1);
 break;
 }
 }
}

#line 369
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeLeaf *
rope<_CharT,_Alloc>::_S_leaf_concat_char_iter
 (_RopeLeaf* __r, const _CharT* __iter, size_t __len)
{
 size_t __old_len = __r->_M_size._M_data;
 _CharT* __new_data = __r->_M_size.allocate(_S_rounded_up_size(__old_len + __len));
 _RopeLeaf* __result;

#line 378
 uninitialized_copy_n(__r->_M_data, __old_len, __new_data);
 uninitialized_copy_n(__iter, __len, __new_data + __old_len);
 _S_cond_store_eos(__new_data[__old_len + __len]);
 try {
 __result = _S_new_RopeLeaf(__new_data, __old_len + __len,
 __r->get_allocator());
 }
 catch(...) { _RopeRep::_S_free_string(__new_data, __old_len + __len, __r->get_allocator()); throw; } ;

 return __result;
}

#line 392
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeLeaf *
rope<_CharT,_Alloc>::_S_destr_leaf_concat_char_iter
 (_RopeLeaf* __r, const _CharT* __iter, size_t __len)
{

#line 398
 if (__r->_M_ref_count > 1)
 return _S_leaf_concat_char_iter(__r, __iter, __len);
 size_t __old_len = __r->_M_size._M_data;
 if (_S_allocated_capacity(__old_len) >= __old_len + __len) {

#line 404
 uninitialized_copy_n(__iter, __len, __r->_M_data + __old_len);
 if (_S_is_basic_char_type((_CharT*)0)) {
 _S_cond_store_eos(__r->_M_data[__old_len + __len]);

#line 408
 } else if (__r->_M_c_string != __r->_M_data && 0 != __r->_M_c_string) {
 __r->_M_free_c_string();
 __r->_M_c_string = 0;
 }
 __r->_M_size._M_data = __old_len + __len;

#line 414
 __r->_M_ref_count = 2;
 return __r;
 } else {
 _RopeLeaf* __result = _S_leaf_concat_char_iter(__r, __iter, __len);

#line 419
 return __result;
 }
}

#line 427
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeRep *
rope<_CharT,_Alloc>::_S_tree_concat (_RopeRep* __left, _RopeRep* __right)
{
 _RopeConcatenation* __result =
 _S_new_RopeConcatenation(__left, __right, __left->get_allocator());
 size_t __depth = __result->_M_depth;

#line 436
 if (__depth > 20 && (__result->_M_size._M_data < 1000 ||
 __depth > _RopeRep::_S_max_rope_depth)) {
 _RopeRep* __balanced;

#line 440
 try {
 __balanced = _S_balance(__result);

#line 443
 if (__result != __balanced) {

#line 446
 }


#line 448
 __result->_M_unref_nonnil();
 }
 catch(...) { ((_Alloc_traits<_RopeConcatenation,allocator_type>::create_allocator((allocator_type&)__left->_M_size)).deallocate(__result,1)); throw; } ;


#line 456
 return __balanced;
 } else {
 return __result;
 }
}

#line 462
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeRep *
rope<_CharT,_Alloc>::_S_concat_char_iter
 (_RopeRep* __r, const _CharT*__s, size_t __slen)
{
 _RopeRep* __result;
 if (0 == __slen) {
 _S_ref(__r);
 return __r;
 }
 if (0 == __r)
 return _S_RopeLeaf_from_unowned_char_ptr(__s, __slen, allocator_type()) ;

 if (_RopeRep::_S_leaf == __r->_M_tag &&
 __r->_M_size._M_data + __slen <= _S_copy_max) {
 __result = _S_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);

#line 480


#line 481
 return __result;
 }
 if (_RopeRep::_S_concat == __r->_M_tag
 && _RopeRep::_S_leaf == ((_RopeConcatenation*)__r)->_M_right->_M_tag) {
 _RopeLeaf* __right =
 (_RopeLeaf* )(((_RopeConcatenation* )__r)->_M_right);
 if (__right->_M_size._M_data + __slen <= _S_copy_max) {
 _RopeRep* __left = ((_RopeConcatenation*)__r)->_M_left;
 _RopeRep* __nright =
 _S_leaf_concat_char_iter((_RopeLeaf*)__right, __s, __slen);
 __left->_M_ref_nonnil();
 try {
 __result = _S_tree_concat(__left, __nright);
 }
 catch(...) { _S_unref(__left); _S_unref(__nright); throw; } ;

#line 498


#line 499
 return __result;
 }
 }
 _RopeRep* __nright =
 _S_RopeLeaf_from_unowned_char_ptr(__s, __slen, __r->get_allocator()) ;
 try {
 __r->_M_ref_nonnil();
 __result = _S_tree_concat(__r, __nright);
 }
 catch(...) { _S_unref(__r); _S_unref(__nright); throw; } ;

#line 511


#line 512
 return __result;
}

#line 516
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeRep *
rope<_CharT,_Alloc>::_S_destr_concat_char_iter(
 _RopeRep* __r, const _CharT* __s, size_t __slen)
{
 _RopeRep* __result;
 if (0 == __r)
 return _S_RopeLeaf_from_unowned_char_ptr(__s, __slen, allocator_type()) ;

 size_t __count = __r->_M_ref_count;
 size_t __orig_size = __r->_M_size._M_data;

#line 528
 if (__count > 1) return _S_concat_char_iter(__r, __s, __slen);
 if (0 == __slen) {
 __r->_M_ref_count = 2;
 return __r;
 }
 if (__orig_size + __slen <= _S_copy_max &&
 _RopeRep::_S_leaf == __r->_M_tag) {
 __result = _S_destr_leaf_concat_char_iter((_RopeLeaf*)__r, __s, __slen);
 return __result;
 }
 if (_RopeRep::_S_concat == __r->_M_tag) {
 _RopeLeaf* __right = (_RopeLeaf*)(((_RopeConcatenation*)__r)->_M_right);
 if (_RopeRep::_S_leaf == __right->_M_tag
 && __right->_M_size._M_data + __slen <= _S_copy_max) {
 _RopeRep* __new_right =
 _S_destr_leaf_concat_char_iter(__right, __s, __slen);
 if (__right == __new_right) {

#line 546
 __new_right->_M_ref_count = 1;
 } else {

#line 549
 __right->_M_unref_nonnil();
 }

#line 552
 __r->_M_ref_count = 2;
 ((_RopeConcatenation*)__r)->_M_right = __new_right;

#line 556
 if (0 != __r->_M_c_string) {
 __r->_M_free_c_string();
 __r->_M_c_string = 0;
 }
 __r->_M_size._M_data = __orig_size + __slen;
 return __r;
 }
 }
 _RopeRep* __right =
 _S_RopeLeaf_from_unowned_char_ptr(__s, __slen, __r->get_allocator()) ;
 __r->_M_ref_nonnil();
 try {
 __result = _S_tree_concat(__r, __right);
 }
 catch(...) { _S_unref(__r); _S_unref(__right); throw; }

#line 572
 return __result;
}

#line 576
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeRep *
rope<_CharT,_Alloc>::_S_concat_rep(_RopeRep* __left, _RopeRep* __right)
{
 if (0 == __left) {
 _S_ref(__right);
 return __right;
 }
 if (0 == __right) {
 __left->_M_ref_nonnil();
 return __left;
 }
 if (_RopeRep::_S_leaf == __right->_M_tag) {
 if (_RopeRep::_S_leaf == __left->_M_tag) {
 if (__right->_M_size._M_data + __left->_M_size._M_data <= _S_copy_max) {
 return _S_leaf_concat_char_iter((_RopeLeaf*)__left,
 ((_RopeLeaf*)__right)->_M_data,
 __right->_M_size._M_data);
 }
 } else if (_RopeRep::_S_concat == __left->_M_tag
 && _RopeRep::_S_leaf ==
 ((_RopeConcatenation*)__left)->_M_right->_M_tag) {
 _RopeLeaf* __leftright =
 (_RopeLeaf*)(((_RopeConcatenation*)__left)->_M_right);
 if (__leftright->_M_size._M_data + __right->_M_size._M_data <= _S_copy_max) {
 _RopeRep* __leftleft = ((_RopeConcatenation*)__left)->_M_left;
 _RopeRep* __rest = _S_leaf_concat_char_iter(__leftright,
 ((_RopeLeaf*)__right)->_M_data,
 __right->_M_size._M_data);
 __leftleft->_M_ref_nonnil();
 try {
 return(_S_tree_concat(__leftleft, __rest));
 }
 catch(...) { _S_unref(__leftleft); _S_unref(__rest); throw; }
 }
 }
 }
 __left->_M_ref_nonnil();
 __right->_M_ref_nonnil();
 try {
 return(_S_tree_concat(__left, __right));
 }
 catch(...) { _S_unref(__left); _S_unref(__right); throw; } ;

#line 622
}

#line 624
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeRep *
rope<_CharT,_Alloc>::_S_substring(_RopeRep* __base,
 size_t __start, size_t __endp1)
{
 if (0 == __base) return 0;
 size_t __len = __base->_M_size._M_data;
 size_t __adj_endp1;
 const size_t __lazy_threshold = 128;

#line 634
 if (__endp1 >= __len) {
 if (0 == __start) {
 __base->_M_ref_nonnil();
 return __base;
 } else {
 __adj_endp1 = __len;
 }
 } else {
 __adj_endp1 = __endp1;
 }
 switch(__base->_M_tag) {
 case _RopeRep::_S_concat:
 {
 _RopeConcatenation* __c = (_RopeConcatenation*)__base;
 _RopeRep* __left = __c->_M_left;
 _RopeRep* __right = __c->_M_right;
 size_t __left_len = __left->_M_size._M_data;
 _RopeRep* __result;

#line 653
 if (__adj_endp1 <= __left_len) {
 return _S_substring(__left, __start, __endp1);
 } else if (__start >= __left_len) {
 return _S_substring(__right, __start - __left_len,
 __adj_endp1 - __left_len);
 }
 _Self_destruct_ptr __left_result(
 _S_substring(__left, __start, __left_len));
 _Self_destruct_ptr __right_result(
 _S_substring(__right, 0, __endp1 - __left_len));

#line 664
 __result = _S_concat_rep(__left_result, __right_result);

#line 667


#line 668
 return __result;

#line 670
 }
 case _RopeRep::_S_leaf:
 {
 _RopeLeaf* __l = (_RopeLeaf*)__base;
 _RopeLeaf* __result;
 size_t __result_len;
 if (__start >= __adj_endp1) return 0;
 __result_len = __adj_endp1 - __start;
 if (__result_len > __lazy_threshold) goto lazy;

#line 686
 __result = _S_RopeLeaf_from_unowned_char_ptr(__l->_M_data + __start, __result_len, __base->get_allocator()) ;



#line 690
 return __result;
 }
 case _RopeRep::_S_substringfn:

#line 694
 {
 _RopeSubstring* __old = (_RopeSubstring*)__base;
 size_t __result_len;
 if (__start >= __adj_endp1) return 0;
 __result_len = __adj_endp1 - __start;
 if (__result_len > __lazy_threshold) {
 _RopeSubstring* __result =
 _S_new_RopeSubstring(__old->_M_base,
 __start + __old->_M_start,
 __adj_endp1 - __start,
 __base->get_allocator());
 return __result;

#line 707
 }
 }
 case _RopeRep::_S_function:
 {
 _RopeFunction* __f = (_RopeFunction*)__base;
 if (__start >= __adj_endp1) return 0;
 size_t __result_len = __adj_endp1 - __start;

#line 715
 if (__result_len > __lazy_threshold) goto lazy;
 _CharT* __section = __base->_M_size.allocate(_S_rounded_up_size(__result_len));
 try {
 (*(__f->_M_fn))(__start, __result_len, __section);
 }
 catch(...) { _RopeRep::_S_free_string( __section, __result_len, __base->get_allocator()); throw; } ;

 _S_cond_store_eos(__section[__result_len]);
 return _S_new_RopeLeaf(__section, __result_len,
 __base->get_allocator());
 }
 }

#line 729
 lazy:
 {

#line 732
 return _S_new_RopeSubstring(__base, __start, __adj_endp1 - __start,
 __base->get_allocator());
 }
}

#line 737
template<class _CharT>
class _Rope_flatten_char_consumer : public _Rope_char_consumer<_CharT> {
 private:
 _CharT* _M_buf_ptr;
 public:

#line 744
 _Rope_flatten_char_consumer(_CharT* __buffer) {
 _M_buf_ptr = __buffer;
 };
 ~_Rope_flatten_char_consumer() {}
 bool operator() (const _CharT* __leaf, size_t __n) {
 uninitialized_copy_n(__leaf, __n, _M_buf_ptr);
 _M_buf_ptr += __n;
 return true;
 }
};

#line 755
template<class _CharT>
class _Rope_find_char_char_consumer : public _Rope_char_consumer<_CharT> {
 private:
 _CharT _M_pattern;
 public:
 size_t _M_count;
 _Rope_find_char_char_consumer(_CharT __p)
 : _M_pattern(__p), _M_count(0) {}
 ~_Rope_find_char_char_consumer() {}
 bool operator() (const _CharT* __leaf, size_t __n) {
 size_t __i;
 for (__i = 0; __i < __n; __i++) {
 if (__leaf[__i] == _M_pattern) {
 _M_count += __i; return false;
 }
 }
 _M_count += __n; return true;
 }
};

#line 777
 template<class _CharT, class _Traits>

#line 785
class _Rope_insert_char_consumer : public _Rope_char_consumer<_CharT> {
 private:

#line 788
 typedef basic_ostream<_CharT,_Traits> _Insert_ostream;

#line 792
 _Insert_ostream& _M_o;
 public:

#line 795
 _Rope_insert_char_consumer(_Insert_ostream& __writer)
 : _M_o(__writer) {};

#line 800
 ~_Rope_insert_char_consumer() {}

#line 803
 bool operator() (const _CharT* __leaf, size_t __n);

#line 805
};

#line 813
 template<class _CharT, class _Traits>
 bool _Rope_insert_char_consumer<_CharT, _Traits>::operator()
 (const _CharT* __leaf, size_t __n)
{
 size_t __i;

#line 819
 for (__i = 0; __i < __n; __i++) _M_o.put(__leaf[__i]);
 return true;
}

#line 853
template <class _CharT, class _Alloc>
bool rope<_CharT, _Alloc>::_S_apply_to_pieces(
 _Rope_char_consumer<_CharT>& __c,
 const _RopeRep* __r,
 size_t __begin, size_t __end)
{
 if (0 == __r) return true;
 switch(__r->_M_tag) {
 case _RopeRep::_S_concat:
 {
 _RopeConcatenation* __conc = (_RopeConcatenation*)__r;
 _RopeRep* __left = __conc->_M_left;
 size_t __left_len = __left->_M_size._M_data;
 if (__begin < __left_len) {
 size_t __left_end = (min) (__left_len, __end);
 if (!_S_apply_to_pieces(__c, __left, __begin, __left_end))
 return false;
 }
 if (__end > __left_len) {
 _RopeRep* __right = __conc->_M_right;
 size_t __right_start = (max)(__left_len, __begin);
 if (!_S_apply_to_pieces(__c, __right,
 __right_start - __left_len,
 __end - __left_len)) {
 return false;
 }
 }
 }
 return true;
 case _RopeRep::_S_leaf:
 {
 _RopeLeaf* __l = (_RopeLeaf*)__r;
 return __c.operator()(__l->_M_data + __begin, __end - __begin);
 }
 case _RopeRep::_S_function:
 case _RopeRep::_S_substringfn:
 {
 _RopeFunction* __f = (_RopeFunction*)__r;
 size_t __len = __end - __begin;
 bool __result;
 _CharT* __buffer =
 (_CharT*)__sgi_alloc::allocate(__len * sizeof(_CharT));
 try {
 (*(__f->_M_fn))(__begin, __len, __buffer);
 __result = __c.operator()(__buffer, __len);
 __sgi_alloc::deallocate(__buffer, __len * sizeof(_CharT));
 }
 catch(...) { (__sgi_alloc::deallocate(__buffer, __len * sizeof(_CharT))); throw; }
 return
 __result;
 }
 default:

#line 907
 return false;
 }
}

#line 911
template <class _CharT> inline bool _Rope_is_simple(_CharT*) { return false; }
inline bool _Rope_is_simple(char*) { return true; }

#line 914
inline bool _Rope_is_simple(wchar_t*) { return true; }

#line 919
 template<class _CharT, class _Traits>
 inline void _Rope_fill(basic_ostream<_CharT, _Traits>& __o, size_t __n)

#line 924
{
 char __f = __o.fill();
 size_t __i;

#line 928
 for (__i = 0; __i < __n; __i++) __o.put(__f);
}

#line 932
 template<class _CharT, class _Traits, class _Alloc>
 basic_ostream<_CharT, _Traits>& operator<<
 (basic_ostream<_CharT, _Traits>& __o,
 const rope<_CharT, _Alloc>& __r)

#line 940
{
 size_t __w = __o.width();
 bool __left = bool(__o.flags() & ios::left);
 size_t __pad_len;
 size_t __rope_len = __r.size();

#line 946
 _Rope_insert_char_consumer<_CharT, _Traits> __c(__o);

#line 950
 bool __is_simple = _Rope_is_simple((_CharT*)0);

#line 952
 if (__rope_len < __w) {
 __pad_len = __w - __rope_len;
 } else {
 __pad_len = 0;
 }
 if (!__is_simple) __o.width(__w/__rope_len);
 try {
 if (__is_simple && !__left && __pad_len > 0) {
 _Rope_fill(__o, __pad_len);
 }
 __r.apply_to_pieces(0, __r.size(), __c);
 if (__is_simple && __left && __pad_len > 0) {
 _Rope_fill(__o, __pad_len);
 }
 if (!__is_simple)
 __o.width(__w);
 }
 catch(...) { if (!__is_simple) __o.width(__w); throw; }
 return __o;
}

#line 975
template <class _CharT, class _Alloc>
_CharT*
rope<_CharT,_Alloc>::_S_flatten(_RopeRep* __r,
 size_t __start, size_t __len,
 _CharT* __buffer)
{
 _Rope_flatten_char_consumer<_CharT> __c(__buffer);
 _S_apply_to_pieces(__c, __r, __start, __start + __len);
 return(__buffer + __len);
}

#line 986
template <class _CharT, class _Alloc>
size_t
rope<_CharT,_Alloc>::find(_CharT __pattern, size_t __start) const
{
 _Rope_find_char_char_consumer<_CharT> __c(__pattern);
 _S_apply_to_pieces(__c, _M_tree_ptr._M_data, __start, size());
 size_type __result_pos = __start + __c._M_count;

#line 994
 if (__result_pos == size()) __result_pos = npos;

#line 996
 return __result_pos;
}

#line 999
template <class _CharT, class _Alloc>
_CharT*
rope<_CharT,_Alloc>::_S_flatten(_Rope_RopeRep<_CharT, _Alloc>* __r, _CharT* __buffer)
{
 if (0 == __r) return __buffer;
 switch(__r->_M_tag) {
 case _RopeRep::_S_concat:
 {
 _RopeConcatenation* __c = (_RopeConcatenation*)__r;
 _RopeRep* __left = __c->_M_left;
 _RopeRep* __right = __c->_M_right;
 _CharT* __rest = _S_flatten(__left, __buffer);
 return _S_flatten(__right, __rest);
 }
 case _RopeRep::_S_leaf:
 {
 _RopeLeaf* __l = (_RopeLeaf*)__r;
 return copy_n(__l->_M_data, __l->_M_size._M_data, __buffer).second;
 }
 case _RopeRep::_S_function:
 case _RopeRep::_S_substringfn:

#line 1022
 {
 _RopeFunction* __f = (_RopeFunction*)__r;
 (*(__f->_M_fn))(0, __f->_M_size._M_data, __buffer);
 return __buffer + __f->_M_size._M_data;
 }
 default:

#line 1030
 return 0;
 }
}

#line 1036
template <class _CharT, class _Alloc>
void
rope<_CharT,_Alloc>::_S_dump(_RopeRep* __r, int __indent)
{
 for (int __i = 0; __i < __indent; __i++) (--((&__iob[1]))->__cnt >= 0 ? (int) (*((&__iob[1]))->__ptr++ = (unsigned char) ((' '))) : __flsbuf((unsigned char) ((' ')), ((&__iob[1])))) ;
 if (0 == __r) {
 printf("NULL\n"); return;
 }
 if (_RopeRep::_S_concat == __r->_M_tag) {
 _RopeConcatenation* __c = (_RopeConcatenation*)__r;
 _RopeRep* __left = __c->_M_left;
 _RopeRep* __right = __c->_M_right;

#line 1053
 printf("Concatenation %p (rc = %ld, depth = %d, len = %ld, %s balanced)\n",
 __r, __r->_M_ref_count, __r->_M_depth, __r->_M_size._M_data,
 __r->_M_is_balanced? "" : "not");

#line 1058
 _S_dump(__left, __indent + 2);
 _S_dump(__right, __indent + 2);
 return;
 } else {
 const char* __kind;

#line 1064
 switch (__r->_M_tag) {
 case _RopeRep::_S_leaf:
 __kind = "Leaf";
 break;
 case _RopeRep::_S_function:
 __kind = "Function";
 break;
 case _RopeRep::_S_substringfn:
 __kind = "Function representing substring";
 break;
 default:
 __kind = "(corrupted kind field!)";
 }

#line 1081
 printf("%s %p (rc = %ld, depth = %d, len = %ld) ",
 __kind, __r, __r->_M_ref_count, __r->_M_depth, __r->_M_size._M_data);

#line 1084
 if (_S_is_one_byte_char_type((_CharT*)0)) {
 const int __max_len = 40;
 _Self_destruct_ptr __prefix(_S_substring(__r, 0, __max_len));
 _CharT __buffer[__max_len + 1];
 bool __too_big = __r->_M_size._M_data > __prefix->_M_size._M_data;

#line 1090
 _S_flatten(__prefix, __buffer);
 __buffer[__prefix->_M_size._M_data] = _S_eos((_CharT*)0);
 printf("%s%s\n",
 (char*)__buffer, __too_big? "...\n" : "\n");
 } else {
 printf("\n");
 }
 }
}

#line 1114
template <class _CharT, class _Alloc>
const unsigned long
rope<_CharT,_Alloc>::_S_min_len[ 46 ] = { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765ul, 10946ul, 17711ul, 28657ul, 46368ul, 75025ul, 121393ul, 196418ul, 317811ul, 514229ul, 832040ul, 1346269ul, 2178309ul, 3524578ul, 5702887ul, 9227465ul, 14930352ul, 24157817ul, 39088169ul, 63245986ul, 102334155ul, 165580141ul, 267914296ul, 433494437ul, 701408733ul, 1134903170ul, 1836311903ul, 2971215073ul } ;

#line 1133
template <class _CharT, class _Alloc>
 typename rope<_CharT,_Alloc>::_RopeRep *
rope<_CharT,_Alloc>::_S_balance(_RopeRep* __r)
{
 _RopeRep* __forest[_RopeRep::_S_max_rope_depth + 1];
 _RopeRep* __result = 0;
 int __i;

#line 1146
 for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i)
 __forest[__i] = 0;
 try {
 _S_add_to_forest(__r, __forest);
 for (__i = 0; __i <= _RopeRep::_S_max_rope_depth; ++__i)
 if (0 != __forest[__i]) {

#line 1153
 _Self_destruct_ptr __old(__result);

#line 1155
 __result = _S_concat_rep(__forest[__i], __result);
 __forest[__i]->_M_unref_nonnil();

#line 1158
 __forest[__i] = 0;

#line 1160
 }
 }
 catch(...) { for(__i = 0; __i <= _RopeRep::_S_max_rope_depth; __i++) _S_unref(__forest[__i]); throw; }
 if
 (__result->_M_depth > _RopeRep::_S_max_rope_depth) {
 __stl_throw_range_error("rope too long");
 }
 return(__result);
}

#line 1171
template <class _CharT, class _Alloc>
void
rope<_CharT,_Alloc>::_S_add_to_forest(_RopeRep* __r, _RopeRep** __forest)
{
 if (__r -> _M_is_balanced) {
 _S_add_leaf_to_forest(__r, __forest);
 return;
 }

#line 1180
 {
 _RopeConcatenation* __c = (_RopeConcatenation*)__r;

#line 1183
 _S_add_to_forest(__c->_M_left, __forest);
 _S_add_to_forest(__c->_M_right, __forest);
 }
}

#line 1189
template <class _CharT, class _Alloc>
void
rope<_CharT,_Alloc>::_S_add_leaf_to_forest(_RopeRep* __r, _RopeRep** __forest)
{
 _RopeRep* __insertee;
 _RopeRep* __too_tiny = 0;
 int __i;
 size_t __s = __r->_M_size._M_data;

#line 1198
 for (__i = 0; __s >= _S_min_len[__i+1] ; ++__i) {
 if (0 != __forest[__i]) {

#line 1201
 _Self_destruct_ptr __old(__too_tiny);

#line 1203
 __too_tiny = _S_concat_and_set_balanced(__forest[__i], __too_tiny);
 __forest[__i]->_M_unref_nonnil();
 __forest[__i] = 0;
 }
 }
 {

#line 1210
 _Self_destruct_ptr __old(__too_tiny);

#line 1212
 __insertee = _S_concat_and_set_balanced(__too_tiny, __r);
 }

#line 1218
 for (;; ++__i) {
 if (0 != __forest[__i]) {

#line 1221
 _Self_destruct_ptr __old(__insertee);

#line 1223
 __insertee = _S_concat_and_set_balanced(__forest[__i], __insertee);
 __forest[__i]->_M_unref_nonnil();
 __forest[__i] = 0;

#line 1227
 }

#line 1230
 if (__i == _RopeRep::_S_max_rope_depth ||
 __insertee->_M_size._M_data < _S_min_len[__i+1]) {
 __forest[__i] = __insertee;

#line 1234
 return;
 }
 }
}

#line 1239
template <class _CharT, class _Alloc>
_CharT
rope<_CharT,_Alloc>::_S_fetch(_RopeRep* __r, size_type __i)
{
 _CharT* __cstr = __r->_M_c_string;

#line 1246
 if (0 != __cstr) return __cstr[__i];
 for(;;) {
 switch(__r->_M_tag) {
 case _RopeRep::_S_concat:
 {
 _RopeConcatenation* __c = (_RopeConcatenation*)__r;
 _RopeRep* __left = __c->_M_left;
 size_t __left_len = __left->_M_size._M_data;

#line 1255
 if (__i >= __left_len) {
 __i -= __left_len;
 __r = __c->_M_right;
 } else {
 __r = __left;
 }
 }
 break;
 case _RopeRep::_S_leaf:
 {
 _RopeLeaf* __l = (_RopeLeaf*)__r;
 return __l->_M_data[__i];
 }
 case _RopeRep::_S_function:
 case _RopeRep::_S_substringfn:
 {
 _RopeFunction* __f = (_RopeFunction*)__r;
 _CharT __result;

#line 1274
 (*(__f->_M_fn))(__i, 1, &__result);
 return __result;
 }
 }
 }

#line 1282
}

#line 1287
template <class _CharT, class _Alloc>
_CharT*
rope<_CharT,_Alloc>::_S_fetch_ptr(_RopeRep* __r, size_type __i)
{
 _RopeRep* __clrstack[_RopeRep::_S_max_rope_depth];
 size_t __csptr = 0;

#line 1294
 for(;;) {
 if (__r->_M_ref_count > 1) return 0;
 switch(__r->_M_tag) {
 case _RopeRep::_S_concat:
 {
 _RopeConcatenation* __c = (_RopeConcatenation*)__r;
 _RopeRep* __left = __c->_M_left;
 size_t __left_len = __left->_M_size._M_data;

#line 1303
 if (__c->_M_c_string != 0) __clrstack[__csptr++] = __c;
 if (__i >= __left_len) {
 __i -= __left_len;
 __r = __c->_M_right;
 } else {
 __r = __left;
 }
 }
 break;
 case _RopeRep::_S_leaf:
 {
 _RopeLeaf* __l = (_RopeLeaf*)__r;
 if (__l->_M_c_string != __l->_M_data && __l->_M_c_string != 0)
 __clrstack[__csptr++] = __l;
 while (__csptr > 0) {
 -- __csptr;
 _RopeRep* __d = __clrstack[__csptr];
 __d->_M_free_c_string();
 __d->_M_c_string = 0;
 }
 return __l->_M_data + __i;
 }
 case _RopeRep::_S_function:
 case _RopeRep::_S_substringfn:
 return 0;
 }
 }

#line 1334
}

#line 1341
template <class _CharT, class _Alloc>
int
rope<_CharT,_Alloc>::_S_compare (const _RopeRep* __left,
 const _RopeRep* __right)
{
 size_t __left_len;
 size_t __right_len;

#line 1349
 if (0 == __right) return 0 != __left;
 if (0 == __left) return -1;
 __left_len = __left->_M_size._M_data;
 __right_len = __right->_M_size._M_data;
 if (_RopeRep::_S_leaf == __left->_M_tag) {
 _RopeLeaf* __l = (_RopeLeaf*) __left;
 if (_RopeRep::_S_leaf == __right->_M_tag) {
 _RopeLeaf* __r = (_RopeLeaf*) __right;
 return lexicographical_compare_3way(
 __l->_M_data, __l->_M_data + __left_len,
 __r->_M_data, __r->_M_data + __right_len);
 } else {
 const_iterator __rstart(__right, 0);
 const_iterator __rend(__right, __right_len);
 return lexicographical_compare_3way(
 __l->_M_data, __l->_M_data + __left_len,
 __rstart, __rend);
 }
 } else {
 const_iterator __lstart(__left, 0);
 const_iterator __lend(__left, __left_len);
 if (_RopeRep::_S_leaf == __right->_M_tag) {
 _RopeLeaf* __r = (_RopeLeaf*) __right;
 return lexicographical_compare_3way(
 __lstart, __lend,
 __r->_M_data, __r->_M_data + __right_len);
 } else {
 const_iterator __rstart(__right, 0);
 const_iterator __rend(__right, __right_len);
 return lexicographical_compare_3way(
 __lstart, __lend,
 __rstart, __rend);
 }
 }
}

#line 1386
template <class _CharT, class _Alloc>
_Rope_char_ref_proxy<_CharT, _Alloc>&
_Rope_char_ref_proxy<_CharT, _Alloc>::operator= (_CharT __c) {
 _RopeRep* __old = _M_root->_M_tree_ptr._M_data;

#line 1393
 _CharT* __ptr = _My_rope::_S_fetch_ptr(__old, _M_pos);
 if (0 != __ptr) {
 *__ptr = __c;
 return *this;
 }

#line 1399
 _Self_destruct_ptr __left(
 _My_rope::_S_substring(__old, 0, _M_pos));
 _Self_destruct_ptr __right(
 _My_rope::_S_substring(__old, _M_pos+1, __old->_M_size._M_data));
 _Self_destruct_ptr __result_left(
 _My_rope::_S_destr_concat_char_iter(__left, &__c, 1));

#line 1408


#line 1409
 _RopeRep* __result =
 _My_rope::_S_concat_rep(__result_left, __right);

#line 1413
 _RopeRep::_S_unref(__old);

#line 1415
 _M_root->_M_tree_ptr._M_data = __result;
 return *this;
}

#line 1419
template <class _CharT, class _Alloc>
_Rope_char_ptr_proxy<_CharT, _Alloc>
_Rope_char_ref_proxy<_CharT, _Alloc>::operator& () const {
 return _Rope_char_ptr_proxy<_CharT, _Alloc>(*this);
}

#line 1426
template<class _CharT, class _Alloc>
_CharT rope<_CharT,_Alloc>::_S_empty_c_str[1] = { _CharT() };

#line 1436
template<class _CharT, class _Alloc>
const _CharT* rope<_CharT,_Alloc>::c_str() const {
 if (0 == _M_tree_ptr._M_data) {
 _S_empty_c_str[0] = _S_eos((_CharT*)0);

#line 1441
 return _S_empty_c_str;
 }
 _CharT* __old_c_string = _M_tree_ptr._M_data->_M_c_string;
 if (0 != __old_c_string) return(__old_c_string);
 size_t __s = size();
 _CharT* __result = (_Alloc_traits<_CharT,allocator_type>::create_allocator((const allocator_type&)_M_tree_ptr)) .allocate(__s + 1);
 _S_flatten(_M_tree_ptr._M_data, __result);
 __result[__s] = _S_eos((_CharT*)0);

#line 1452
 if ((__old_c_string = ( _CharT*)
 _Atomic_swap((__stl_atomic_t *)(&(_M_tree_ptr._M_data->_M_c_string)),
 (__stl_atomic_t)__result)) != 0) {

#line 1458
 _Destroy(__old_c_string, __old_c_string + __s + 1);
 (_Alloc_traits<_CharT,allocator_type>::create_allocator((const allocator_type&)_M_tree_ptr)) .deallocate(__old_c_string, __s + 1);
 }

#line 1462
 return(__result);
}

#line 1465
template<class _CharT, class _Alloc>
const _CharT* rope<_CharT,_Alloc>::replace_with_c_str() {
 if (0 == _M_tree_ptr._M_data) {
 _S_empty_c_str[0] = _S_eos((_CharT*)0);
 return _S_empty_c_str;
 }
 _CharT* __old_c_string = _M_tree_ptr._M_data->_M_c_string;
 if (_RopeRep::_S_leaf == _M_tree_ptr._M_data->_M_tag && 0 != __old_c_string) {
 return(__old_c_string);
 }
 size_t __s = size();
 _CharT* __result = _M_tree_ptr.allocate(_S_rounded_up_size(__s));
 _S_flatten(_M_tree_ptr._M_data, __result);
 __result[__s] = _S_eos((_CharT*)0);
 _M_tree_ptr._M_data->_M_unref_nonnil();
 _M_tree_ptr._M_data = _S_new_RopeLeaf(__result, __s, get_allocator());
 return(__result);
}

#line 1488
template<class _CharT,class _Alloc>
void
_Rope_rotate(_Rope_iterator<_CharT,_Alloc> __first,
 _Rope_iterator<_CharT,_Alloc> __middle,
 _Rope_iterator<_CharT,_Alloc> __last)
{

#line 1496
 rope
<_CharT,_Alloc>& __r(__first.container());
 rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());
 rope<_CharT,_Alloc> __suffix =
 __r.substr(__last.index(), __r.size() - __last.index());
 rope<_CharT,_Alloc> __part1 =
 __r.substr(__middle.index(), __last.index() - __middle.index());
 rope<_CharT,_Alloc> __part2 =
 __r.substr(__first.index(), __middle.index() - __first.index());
 __r = __prefix;
 __r += __part1;
 __r += __part2;
 __r += __suffix;
}

#line 1534
 }
#line 2512 "../../stlport/stl/_rope.h"

#line 27 "../../stlport/rope"

#line 1 "../../stlport/stl/_epilog.h"

#line 1 "../../stlport/config/_epilog.h"

#line 11 "../../stlport/stl/_epilog.h"

#line 1 "../../stlport/stl/_config_compat_post.h"

#line 15 "../../stlport/stl/_epilog.h"


#line 34
 namespace _STL {}

#line 35
namespace std {
 using namespace _STL ;
}
#line 30 "../../stlport/rope"

#line 11 "hmap1.cpp"


#line 13
using namespace std;

#line 16
int hmap1_test(int, char**)
{
 cout<<"Results of hmap1_test:"<<endl;
 typedef hash_map<char, crope, hash<char>, equal_to<char> > maptype;
 maptype m;

#line 22
 m['l'] = "50";
 m['x'] = "20";
 m['v'] = "5";
 m['i'] = "1";
 cout << "m['x'] = " << m['x'] << endl;
 m['x'] = "10";
 cout << "m['x'] = " << m['x'] << endl;
 cout << "m['z'] = " << m['z'] << endl;
 cout << "m.count('z') = " << m.count('z') << endl;
 pair<maptype::iterator, bool> p =
 m.insert(pair<const char, crope>('c', crope("100")));
 if(p.second)
 cout << "First insertion successful" << endl;
 p = m.insert(pair<const char, crope>('c', crope("100")));
 if(p.second)
 cout << "Second insertion successful" << endl;
 else
 cout << "Existing pair " <<(*(p.first)).first
 << " -> " <<(*(p.first)).second << endl;
 return 0;
}
